{"error": null, "issues": [{"address": 1363, "debug": "calldata_AceDice_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_AceDice_0: 0xc73ea36700000000000000000000000000000000000000000000000000000000\ncalldatasize_AceDice: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setNickName(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/ACEDICE-0.sol", "function": "setNickName(string)", "lineno": 782, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1369, "debug": "calldata_AceDice_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc\ncalldata_AceDice_0: 0xc73ea36700000000000000000000000000000000000000000000000000000000\ncalldatasize_AceDice: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setNickName(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/ACEDICE-0.sol", "function": "setNickName(string)", "lineno": 782, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2405, "debug": "calldata_AceDice_32 + 4: 0xde9aa0007ffff9dbbb05d00001000207fffdffbfffbfbfbfffbfbfefbfbff7f6\nstorage_5: 0xff3717ddf147ba7fd6976a72ee859c9c251431c6dd4346e384e0fd941c87b69c\nstorage_0: 0x0\ncaller: 0x0\ncalldata_AceDice_0: 0xea5edea00000000000000000000000000000000000000000000000000000000\ncalldatasize_AceDice: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `payTodayReward(address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/ACEDICE-0.sol", "function": "payTodayReward(address,uint256)", "lineno": 782, "title": "Integer Overflow ", "type": "Warning"}, {"address": 19375, "code": "tract AceDice {\n  /// *** Constants section\n  \n  // Each bet is deducted 1% in favour of the house, but no less than some minimum.\n  // The lower bound is dictated by gas costs of the settleBet transaction, providing\n  // headroom for up to 10 Gwei prices.\n  uint constant HOUSE_EDGE_PERCENT = 2;\n  uint constant HOUSE_EDGE_MINIMUM_AMOUNT = 0.0004 ether;\n  \n  // Bets lower than this amount do not participate in jackpot rolls (and are\n  // not deducted JACKPOT_FEE).\n  uint constant MIN_JACKPOT_BET = 0.1 ether;\n  \n  // Chance to win jackpot (currently 0.1%) and fee deducted into jackpot fund.\n  uint constant JACKPOT_MODULO = 1000;\n  uint constant JACKPOT_FEE = 0.001 ether;\n  \n  // There is minimum and maximum bets.\n  uint constant MIN_BET = 0.01 ether;\n  uint constant MAX_AMOUNT = 300000 ether;\n  \n  // Modulo is a number of equiprobable outcomes in a game:\n  // - 2 for coin flip\n  // - 6 for dice\n  // - 6*6 = 36 for double dice\n  // - 100 for etheroll\n  // - 37 for roulette\n  // etc.\n  // It's called so because 256-bit entropy is treated like a huge integer and\n  // the remainder of its division by modulo is considered bet outcome.\n  // uint constant MAX_MODULO = 100;\n  \n  // For modulos below this threshold rolls are checked against a bit mask,\n  // thus allowing betting on any combination of outcomes. For example, given\n  // modulo 6 for dice, 101000 mask (base-2, big endian) means betting on\n  // 4 and 6; for games with modulos higher than threshold (Etheroll), a simple\n  // limit is used, allowing betting on any outcome in [0, N) range.\n  //\n  // The specific value is dictated by the fact that 256-bit intermediate\n  // multiplication result allows implementing population count efficiently\n  // for numbers that are up to 42 bits, and 40 is the highest multiple of\n  // eight below 42.\n  uint constant MAX_MASK_MODULO = 40;\n  \n  // This is a check on bet mask overflow.\n  uint constant MAX_BET_MASK = 2 ** MAX_MASK_MODULO;\n  \n  // EVM BLOCKHASH opcode can query no further than 256 blocks into the\n  // past. Given that settleBet uses block hash of placeBet as one of\n  // complementary entropy sources, we cannot process bets older than this\n  // threshold. On rare occasions AceDice croupier may fail to invoke\n  // settleBet in this timespan due to technical issues or extreme Ethereum\n  // congestion; such bets can be refunded via invoking refundBet.\n  uint constant BET_EXPIRATION_BLOCKS = 250;\n  \n  // Some deliberately invalid address to initialize the secret signer with.\n  // Forces maintainers to invoke setSecretSigner before processing any bets.\n  address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n  \n  // Standard contract ownership transfer.\n  address public owner;\n  address private nextOwner;\n  \n  // Adjustable max bet profit. Used to cap bets against dynamic odds.\n  uint public maxProfit;\n  \n  // The address corresponding to a private key used to sign placeBet commits.\n  address public secretSigner;\n  \n  // Accumulated jackpot fund.\n  uint128 public jackpotSize;\n  \n  uint public todaysRewardSize;\n\n  // Funds that are locked in potentially winning bets. Prevents contract from\n  // committing to bets it cannot pay out.\n  uint128 public lockedInBets;\n  \n  // A structure representing a single bet.\n  struct Bet {\n    // Wager amount in wei.\n    uint amount;\n    // Modulo of a game.\n    // uint8 modulo;\n    // Number of winning outcomes, used to compute winning payment (* modulo/rollUnder),\n    // and used instead of mask for games with modulo > MAX_MASK_MODULO.\n    uint8 rollUnder;\n    // Block number of placeBet tx.\n    uint40 placeBlockNumber;\n    // Bit mask representing winning bet outcomes (see MAX_MASK_MODULO comment).\n    uint40 mask;\n    // Address of a gambler, used to pay out winning bets.\n    address gambler;\n    // Address of inviter\n    address inviter;\n  }\n\n  struct Profile{\n    // picture index of profile avatar\n    uint avatarIndex;\n    // nickname of user\n    string nickName;\n  }\n  \n  // Mapping from commits to all currently active & processed bets.\n  mapping (uint => Bet) bets;\n  // Mapping for accumuldated bet amount and users\n  mapping (address => uint) accuBetAmount;\n\n  mapping (address => Profile) profiles;\n  \n  // Croupier account.\n  address public croupier;\n  \n  // Events that are issued to make statistic recovery easier.\n  event FailedPayment(address indexed beneficiary, uint amount);\n  event Payment(address indexed beneficiary, uint amount, uint dice, uint rollUnder, uint betAmount);\n  event JackpotPayment(address indexed beneficiary, uint amount, uint dice, uint rollUnder, uint betAmount);\n  event VIPPayback(address indexed beneficiary, uint amount);\n  \n  // This event is emitted in placeBet to record commit in the logs.\n  event Commit(uint commit);\n\n  // \uc624\ub298\uc758 \ub7ad\ud0b9 \ubcf4\uc0c1 \uc9c0\uae09 \uc774\ubca4\ud2b8\n  event TodaysRankingPayment(address indexed beneficiary, uint amount);\n  \n  // Constructor. Deliberately does not take any parameters.\n  constructor () public {\n    owner = msg.sender;\n    secretSigner = DUMMY_ADDRESS;\n    croupier = DUMMY_ADDRESS;\n  }\n  \n  // Standard modifier on methods invokable only by contract owner.\n  modifier onlyOwner {\n    require (msg.sender == owner, \"OnlyOwner methods called by non-owner.\");\n    _;\n  }\n  \n  // Standard modifier on methods invokable only by contract owner.\n  modifier onlyCroupier {\n    require (msg.sender == croupier, \"OnlyCroupier methods called by non-croupier.\");\n    _;\n  }\n  \n  // Standard contract ownership transfer implementation,\n  function approveNextOwner(address _nextOwner) external onlyOwner {\n    require (_nextOwner != owner, \"Cannot approve current owner.\");\n    nextOwner = _nextOwner;\n  }\n  \n  function acceptNextOwner() external {\n    require (msg.sender == nextOwner, \"Can only accept preapproved new owner.\");\n    owner = nextOwner;\n  }\n  \n  // Fallback function deliberately left empty. It's primary use case\n  // is to top up the bank roll.\n  function () public payable {\n  }\n  \n  // See comment for \"secretSigner\" variable.\n  function setSecretSigner(address newSecretSigner) external onlyOwner {\n    secretSigner = newSecretSigner;\n  }\n  \n  function getSecretSigner() external onlyOwner view returns(address){\n    return secretSigner;\n  }\n  \n  // Change the croupier address.\n  function setCroupier(address newCroupier) external onlyOwner {\n    croupier = newCroupier;\n  }\n  \n  // Change max bet reward. Setting this to zero effectively disables betting.\n  function setMaxProfit(uint _maxProfit) public onlyOwner {\n    require (_maxProfit < MAX_AMOUNT, \"maxProfit should be a sane number.\");\n    maxProfit = _maxProfit;\n  }\n  \n  // This function is used to bump up the jackpot fund. Cannot be used to lower it.\n  function increaseJackpot(uint increaseAmount) external onlyOwner {\n    require (increaseAmount <= address(this).balance, \"Increase amount larger than balance.\");\n    require (jackpotSize + lockedInBets + increaseAmount <= address(this).balance, \"Not enough funds.\");\n    jackpotSize += uint128(increaseAmount);\n  }\n  \n  // Funds withdrawal to cover costs of AceDice operation.\n  function withdrawFunds(address beneficiary, uint withdrawAmount) external onlyOwner {\n    require (withdrawAmount <= address(this).balance, \"Increase amount larger than balance.\");\n    require (jackpotSize + lockedInBets + withdrawAmount <= address(this).balance, \"Not enough funds.\");\n    sendFunds(beneficiary, withdrawAmount, withdrawAmount, 0, 0, 0);\n  }\n  \n  // Contract may be destroyed only when there are no ongoing bets,\n  // either settled or refunded. All funds are transferred to contract owner.\n  function kill() external onlyOwner {\n    require (lockedInBets == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\n    selfdestruct(owner);\n  }\n  \n  function encodePacketCommit(uint commitLastBlock, uint commit) private pure returns(bytes memory){\n    return abi.encodePacked(uint40(commitLastBlock), commit);\n  }\n  \n  function verifyCommit(uint commitLastBlock, uint commit, uint8 v, bytes32 r, bytes32 s) private view {\n    // Check that commit is valid - it has not expired and its signature is valid.\n    require (block.number <= commitLastBlock, \"Commit has expired.\");\n    //bytes32 signatureHash = keccak256(abi.encodePacked(commitLastBlock, commit));\n    bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n    bytes memory message = encodePacketCommit(commitLastBlock, commit);\n    bytes32 messageHash = keccak256(abi.encodePacked(prefix, keccak256(message)));\n    require (secretSigner == ecrecover(messageHash, v, r, s), \"ECDSA signature is not valid.\");\n  }\n  \n  /// *** Betting logic\n  \n  // Bet states:\n  // amount == 0 && gambler == 0 - 'clean' (can place a bet)\n  // amount != 0 && gambler != 0 - 'active' (can be settled or refunded)\n  // amount == 0 && gambler != 0 - 'processed' (can clean storage)\n  //\n  // NOTE: Storage cleaning is not implemented in this contract version; it will be added\n  // with the next upgrade to prevent polluting Ethereum state with expired bets.\n  \n  // Bet placing transaction - issued by the player.\n  // betMask - bet outcomes bit mask for modulo <= MAX_MASK_MODULO,\n  // [0, betMask) for larger modulos.\n  // modulo - game modulo.\n  // commitLastBlock - number of the maximum block where \"commit\" is still considered valid.\n  // commit - Keccak256 hash of some secret \"reveal\" random number, to be supplied\n  // by the AceDice croupier bot in the settleBet transaction. Supplying\n  // \"commit\" ensures that \"reveal\" cannot be changed behind the scenes\n  // after placeBet have been mined.\n  // r, s - components of ECDSA signature of (commitLastBlock, commit). v is\n  // guaranteed to always equal 27.\n  //\n  // Commit, being essentially random 256-bit number, is used as a unique bet identifier in\n  // the 'bets' mapping.\n  //\n  // Commits are signed with a block limit to ensure that they are used at most once - otherwise\n  // it would be possible for a miner to place a bet with a known commit/reveal pair and tamper\n  // with the blockhash. Croupier guarantees that commitLastBlock will always be not greater than\n  // placeBet block number plus BET_EXPIRATION_BLOCKS. See whitepaper for details.\n  function placeBet(uint betMask, uint commitLastBlock, uint commit, uint8 v, bytes32 r, bytes32 s) external payable {\n    // Check that the bet is in 'clean' state.\n    Bet storage bet = bets[commit];\n    require (bet.gambler == address(0), \"Bet should be in a 'clean' state.\");\n    \n    // Validate input data ranges.\n    uint amount = msg.value;\n    //require (modulo > 1 && modulo <= MAX_MODULO, \"Modulo should be within range.\");\n    require (amount >= MIN_BET && amount <= MAX_AMOUNT, \"Amount should be within range.\");\n    require (betMask > 0 && betMask < MAX_BET_MASK, \"Mask should be within range.\");\n    \n    verifyCommit(commitLastBlock, commit, v, r, s);\n    \n    // uint rollUnder;\n    uint mask;\n    \n    // if (modulo <= MAX_MASK_MODULO) {\n    //   // Small modulo games specify bet outcomes via bit mask.\n    //   // rollUnder is a number of 1 bits in this mask (population count).\n    //   // This magic looking formula is an efficient way to compute population\n    //   // count on EVM for numbers below 2**40. For detailed proof consult\n    //   // the AceDice whitepaper.\n    //   rollUnder = ((betMask * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO;\n    //   mask = betMask;\n    //   } else {\n        // Larger modulos specify the right edge of half-open interval of\n        // winning bet outcomes.\n        require (betMask > 0 && betMask <= 100, \"High modulo range, betMask larger than modulo.\");\n        // rollUnder = betMask;\n      // }\n      \n      // Winning amount and jackpot increase.\n      uint possibleWinAmount;\n      uint jackpotFee;\n      \n      (possibleWinAmount, jackpotFee) = getDiceWinAmount(amount, betMask);\n      \n      // Enforce max profit limit.\n      require (possibleWinAmount <= amount + maxProfit, \"maxProfit limit violation. \");\n      \n      // Lock funds.\n      lockedInBets += uint128(possibleWinAmount);\n      jackpotSize += uint128(jackpotFee);\n      \n      // Check whether contract has enough funds to process this bet.\n      require (jackpotSize + lockedInBets <= address(this).balance, \"Cannot afford to lose this bet.\");\n      \n      // Record commit in logs.\n      emit Commit(commit);\n\n      // Store bet parameters on blockchain.\n      bet.amount = amount;\n      // bet.modulo = uint8(modulo);\n      bet.rollUnder = uint8(betMask);\n      bet.placeBlockNumber = uint40(block.number);\n      bet.mask = uint40(mask);\n      bet.gambler = msg.sender;\n      \n      uint accuAmount = accuBetAmount[msg.sender];\n      accuAmount = accuAmount + amount;\n      accuBetAmount[msg.sender] = accuAmount;\n    }\n\n    function applyVIPLevel(address gambler, uint amount) private {\n      uint accuAmount = accuBetAmount[gambler];\n      uint rate;\n      if(accuAmount >= 30 ether && accuAmount < 150 ether){\n        rate = 1;\n      } else if(accuAmount >= 150 ether && accuAmount < 300 ether){\n        rate = 2;\n      } else if(accuAmount >= 300 ether && accuAmount < 1500 ether){\n        rate = 4;\n      } else if(accuAmount >= 1500 ether && accuAmount < 3000 ether){\n        rate = 6;\n      } else if(accuAmount >= 3000 ether && accuAmount < 15000 ether){\n        rate = 8;\n      } else if(accuAmount >= 15000 ether && accuAmount < 30000 ether){\n        rate = 10;\n      } else if(accuAmount >= 30000 ether && accuAmount < 150000 ether){\n        rate = 12;\n      } else if(accuAmount >= 150000 ether){\n        rate = 15;\n      } else{\n        return;\n      }\n\n      uint vipPayback = amount * rate / 10000;\n      if(gambler.send(vipPayback)){\n        emit VIPPayback(gambler, vipPayback);\n      }\n    }\n\n    function placeBetWithInviter(uint betMask, uint commitLastBlock, uint commit, uint8 v, bytes32 r, bytes32 s, address inviter) external payable {\n      // Check that the bet is in 'clean' state.\n      Bet storage bet = bets[commit];\n      require (bet.gambler == address(0), \"Bet should be in a 'clean' state.\");\n      \n      // Validate input data ranges.\n      uint amount = msg.value;\n      // require (modulo > 1 && modulo <= MAX_MODULO, \"Modulo should be within range.\");\n      require (amount >= MIN_BET && amount <= MAX_AMOUNT, \"Amount should be within range.\");\n      require (betMask > 0 && betMask < MAX_BET_MASK, \"Mask should be within range.\");\n      require (address(this) != inviter && inviter != address(0), \"cannot invite mysql\");\n      \n      verifyCommit(commitLastBlock, commit, v, r, s);\n      \n      // uint rollUnder;\n      uint mask;\n      \n      // if (modulo <= MAX_MASK_MODULO) {\n      //   // Small modulo games specify bet outcomes via bit mask.\n      //   // rollUnder is a number of 1 bits in this mask (population count).\n      //   // This magic looking formula is an efficient way to compute population\n      //   // count on EVM for numbers below 2**40. For detailed proof consult\n      //   // the AceDice whitepaper.\n      //   rollUnder = ((betMask * POPCNT_MULT) & POPCNT_MASK) % POPCNT_MODULO;\n      //   mask = betMask;\n      // } else {\n        // Larger modulos specify the right edge of half-open interval of\n        // winning bet outcomes.\n        require (betMask > 0 && betMask <= 100, \"High modulo range, betMask larger than modulo.\");\n        // rollUnder = betMask;\n      // }\n      \n      // Winning amount and jackpot increase.\n      uint possibleWinAmount;\n      uint jackpotFee;\n      \n      (possibleWinAmount, jackpotFee) = getDiceWinAmount(amount, betMask);\n      \n      // Enforce max profit limit.\n      require (possibleWinAmount <= amount + maxProfit, \"maxProfit limit violation. \");\n      \n      // Lock funds.\n      lockedInBets += uint128(possibleWinAmount);\n      jackpotSize += uint128(jackpotFee);\n      \n      // Check whether contract has enough funds to process this bet.\n      require (jackpotSize + lockedInBets <= address(this).balance, \"Cannot afford to lose this bet.\");\n      \n      // Record commit in logs.\n      emit Commit(commit);\n\n      // Store bet parameters on blockchain.\n      bet.amount = amount;\n      // bet.modulo = uint8(modulo);\n      bet.rollUnder = uint8(betMask);\n      bet.placeBlockNumber = uint40(block.number);\n      bet.mask = uint40(mask);\n      bet.gambler = msg.sender;\n      bet.inviter = inviter;\n\n      uint accuAmount = accuBetAmount[msg.sender];\n      accuAmount = accuAmount + amount;\n      accuBetAmount[msg.sender] = accuAmount;\n    }\n\n    function getMyAccuAmount() external view returns (uint){\n      return accuBetAmount[msg.sender];\n    }\n    \n    // This is the method used to settle 99% of bets. To process a bet with a specific\n    // \"commit\", settleBet should supply a \"reveal\" number that would Keccak256-hash to\n    // \"commit\". \"blockHash\" is the block hash of placeBet block as seen by croupier; it\n    // is additionally asserted to prevent changing the bet outcomes on Ethereum reorgs.\n    function settleBet(uint reveal, bytes32 blockHash) external onlyCroupier {\n      uint commit = uint(keccak256(abi.encodePacked(reveal)));\n      \n      Bet storage bet = bets[commit];\n      uint placeBlockNumber = bet.placeBlockNumber;\n      \n      // Check that bet has not expired yet (see comment to BET_EXPIRATION_BLOCKS).\n      require (block.number > placeBlockNumber, \"settleBet in the same block as placeBet, or before.\");\n      require (block.number <= placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Blockhash can't be queried by EVM.\");\n      require (blockhash(placeBlockNumber) == blockHash);\n      \n      // Settle bet using reveal and blockHash as entropy sources.\n      settleBetCommon(bet, reveal, blockHash);\n    }\n    \n    // This method is used to settle a bet that was mined into an uncle block. At this\n    // point the player was shown some bet outcome, but the blockhash at placeBet height\n    // is different because of Ethereum chain reorg. We supply a full merkle proof of the\n    // placeBet transaction receipt to provide untamperable evidence that uncle block hash\n    // indeed was present on-chain at some point.\n    function settleBetUncleMerkleProof(uint reveal, uint40 canonicalBlockNumber) external onlyCroupier {\n      // \"commit\" for bet settlement can only be obtained by hashing a \"reveal\".\n      uint commit = uint(keccak256(abi.encodePacked(reveal)));\n      \n      Bet storage bet = bets[commit];\n      \n      // Check that canonical block hash can still be verified.\n      require (block.number <= canonicalBlockNumber + BET_EXPIRATION_BLOCKS, \"Blockhash can't be queried by EVM.\");\n      \n      // Verify placeBet receipt.\n      requireCorrectReceipt(4 + 32 + 32 + 4);\n      \n      // Reconstruct canonical & uncle block hashes from a receipt merkle proof, verify them.\n      bytes32 canonicalHash;\n      bytes32 uncleHash;\n      (canonicalHash, uncleHash) = verifyMerkleProof(commit, 4 + 32 + 32);\n      require (blockhash(canonicalBlockNumber) == canonicalHash);\n      \n      // Settle bet using reveal and uncleHash as entropy sources.\n      settleBetCommon(bet, reveal, uncleHash);\n    }\n    \n    // Common settlement code for settleBet & settleBetUncleMerkleProof.\n    function settleBetCommon(Bet storage bet, uint reveal, bytes32 entropyBlockHash) private {\n      // Fetch bet parameters into local variables (to save gas).\n      uint amount = bet.amount;\n      // uint modulo = bet.modulo;\n      uint rollUnder = bet.rollUnder;\n      address gambler = bet.gambler;\n      \n      // Check that bet is in 'active' state.\n      require (amount != 0, \"Bet should be in an 'active' state\");\n\n      applyVIPLevel(gambler, amount);\n      \n      // Move bet into 'processed' state already.\n      bet.amount = 0;\n      \n      // The RNG - combine \"reveal\" and blockhash of placeBet using Keccak256. Miners\n      // are not aware of \"reveal\" and cannot deduce it from \"commit\" (as Keccak256\n      // preimage is intractable), and house is unable to alter the \"reveal\" after\n      // placeBet have been mined (as Keccak256 collision finding is also intractable).\n      bytes32 entropy = keccak256(abi.encodePacked(reveal, entropyBlockHash));\n      \n      // Do a roll by taking a modulo of entropy. Compute winning amount.\n      uint modulo = 100;\n      uint dice = uint(entropy) % modulo;\n      \n      uint diceWinAmount;\n      uint _jackpotFee;\n      (diceWinAmount, _jackpotFee) = getDiceWinAmount(amount, rollUnder);\n      \n      uint diceWin = 0;\n      uint jackpotWin = 0;\n      \n      // Determine dice outcome.\n      if (modulo <= MAX_MASK_MODULO) {\n        // For small modulo games, check the outcome against a bit mask.\n        if ((2 ** dice) & bet.mask != 0) {\n          diceWin = diceWinAmount;\n        }\n        \n        } else {\n          // For larger modulos, check inclusion into half-open interval.\n          if (dice < rollUnder) {\n            diceWin = diceWinAmount;\n          }\n          \n        }\n        \n        // Unlock the bet amount, regardless of the outcome.\n        lockedInBets -= uint128(diceWinAmount);\n        \n        // Roll for a jackpot (if eligible).\n        if (amount >= MIN_JACKPOT_BET) {\n          // The second modulo, statistically independent from the \"main\" dice roll.\n          // Effectively you are playing two games at once!\n          // uint jackpotRng = (uint(entropy) / modulo) % JACKPOT_MODULO;\n          \n          // Bingo!\n          if ((uint(entropy) / modulo) % JACKPOT_MODULO == 0) {\n            jackpotWin = jackpotSize;\n            jackpotSize = 0;\n          }\n        }\n        \n        // Log jackpot win.\n        if (jackpotWin > 0) {\n          emit JackpotPayment(gambler, jackpotWin, dice, rollUnder, amount);\n        }\n        \n        if(bet.inviter != address(0)){\n          // \uce5c\uad6c \ucd08\ub300\ud558\uba74 \uce5c\uad6c\ud55c\ub300 15% \ub54c\uc5b4\uc90c\n          // uint inviterFee = amount * HOUSE_EDGE_PERCENT / 100 * 15 /100;\n          bet.inviter.transfer(amount * HOUSE_EDGE_PERCENT / 100 * 15 /100);\n        }\n        todaysRewardSize += amount * HOUSE_EDGE_PERCENT / 100 * 9 /100;\n        // Send the funds to gambler.\n        sendFunds(gambler, diceWin + jackpotWin == 0 ? 1 wei : diceWin + jackpotWin, diceWin, dice, rollUnder, amount);\n      }\n      \n      // Refund transaction - return the bet amount of a roll that was not processed in a\n      // due timeframe. Processing such blocks is not possible due to EVM limitations (see\n      // BET_EXPIRATION_BLOCKS comment above for details). In case you ever find yourself\n      // in a situation like this, just contact the AceDice support, however nothing\n      // precludes you from invoking this method yourself.\n      function refundBet(uint commit) external {\n        // Check that bet is in 'active' state.\n        Bet storage bet = bets[commit];\n        uint amount = bet.amount;\n        \n        require (amount != 0, \"Bet should be in an 'active' state\");\n        \n        // Check that bet has already expired.\n        require (block.number > bet.placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Blockhash can't be queried by EVM.\");\n        \n        // Move bet into 'processed' state, release funds.\n        bet.amount = 0;\n        \n        uint diceWinAmount;\n        uint jackpotFee;\n        (diceWinAmount, jackpotFee) = getDiceWinAmount(amount, bet.rollUnder);\n        \n        lockedInBets -= uint128(diceWinAmount);\n        jackpotSize -= uint128(jackpotFee);\n        \n        // Send the refund.\n        sendFunds(bet.gambler, amount, amount, 0, 0, 0);\n      }\n      \n      // Get the expected win amount after house edge is subtracted.\n      function getDiceWinAmount(uint amount, uint rollUnder) private pure returns (uint winAmount, uint jackpotFee) {\n        require (0 < rollUnder && rollUnder <= 100, \"Win probability out of range.\");\n        \n        jackpotFee = amount >= MIN_JACKPOT_BET ? JACKPOT_FEE : 0;\n        \n        uint houseEdge = amount * HOUSE_EDGE_PERCENT / 100;\n        \n        if (houseEdge < HOUSE_EDGE_MINIMUM_AMOUNT) {\n          houseEdge = HOUSE_EDGE_MINIMUM_AMOUNT;\n        }\n        \n        require (houseEdge + jackpotFee <= amount, \"Bet doesn't even cover house edge.\");\n        winAmount = (amount - houseEdge - jackpotFee) * 100 / rollUnder;\n      }\n      \n      // Helper routine to process the payment.\n      function sendFunds(address beneficiary, uint amount, uint successLogAmount, uint dice, uint rollUnder, uint betAmount) private {\n        if (beneficiary.send(amount)) {\n          emit Payment(beneficiary, successLogAmount, dice, rollUnder, betAmount);\n          } else {\n            emit FailedPayment(beneficiary, amount);\n          }\n        }\n        \n        // This are some constants making O(1) population count in placeBet possible.\n        // See whitepaper for intuition and proofs behind it.\n        uint constant POPCNT_MULT = 0x0000000000002000000000100000000008000000000400000000020000000001;\n        uint constant POPCNT_MASK = 0x0001041041041041041041041041041041041041041041041041041041041041;\n        uint constant POPCNT_MODULO = 0x3F;\n        \n        // *** Merkle proofs.\n        \n        // This helpers are used to verify cryptographic proofs of placeBet inclusion into\n        // uncle blocks. They are used to prevent bet outcome changing on Ethereum reorgs without\n        // compromising the security of the smart contract. Proof data is appended to the input data\n        // in a simple prefix length format and does not adhere to the ABI.\n        // Invariants checked:\n        // - receipt trie entry contains a (1) successful transaction (2) directed at this smart\n        // contract (3) containing commit as a payload.\n        // - receipt trie entry is a part of a valid merkle proof of a block header\n        // - the block header is a part of uncle list of some block on canonical chain\n        // The implementation is optimized for gas cost and relies on the specifics of Ethereum internal data structures.\n        // Read the whitepaper for details.\n        \n        // Helper to verify a full merkle proof starting from some seedHash (usually commit). \"offset\" is the location of the proof\n        // beginning in the calldata.\n        function verifyMerkleProof(uint seedHash, uint offset) pure private returns (bytes32 blockHash, bytes32 uncleHash) {\n          // (Safe) assumption - nobody will write into RAM during this method invocation.\n        uint scratchBuf1; assembly { scratchBuf1 := mload(0x40) }\n        \n        uint uncleHeaderLength; uint blobLength; uint shift; uint hashSlot;\n        \n        // Verify merkle proofs up to uncle block header. Calldata layout is:\n        // - 2 byte big-endian slice length\n        // - 2 byte big-endian offset to the beginning of previous slice hash within the current slice (should be zeroed)\n        // - followed by the current slice verbatim\n        for (;; offset += blobLength) {\n        assembly { blobLength := and(calldataload(sub(offset, 30)), 0xffff) }\n        if (blobLength == 0) {\n          // Zero slice length marks the end of uncle proof.\n          break;\n        }\n        \n      assembly { shift := and(calldataload(sub(offset, 28)), 0xffff) }\n      require (shift + 32 <= blobLength, \"Shift bounds check.\");\n      \n      offset += 4;\n    assembly { hashSlot := calldataload(add(offset, shift)) }\n    require (hashSlot == 0, \"Non-empty hash slot.\");\n    \n    assembly {\n      calldatacopy(scratchBuf1, offset, blobLength)\n      mstore(add(scratchBuf1, shift), seedHash)\n      seedHash := sha3(scratchBuf1, blobLength)\n      uncleHeaderLength := blobLength\n    }\n  }\n  \n  // At this moment the uncle hash is known.\n  uncleHash = bytes32(seedHash);\n  \n  // Construct the uncle list of a canonical block.\n  uint scratchBuf2 = scratchBuf1 + uncleHeaderLength;\nuint unclesLength; assembly { unclesLength := and(calldataload(sub(offset, 28)), 0xffff) }\n        uint unclesShift;  assembly { unclesShift := and(calldataload(sub(offset, 26)), 0xffff) }\n        require (unclesShift + uncleHeaderLength <= unclesLength, \"Shift bounds check.\");\n\n        offset += 6;\n        assembly { calldatacopy(scratchBuf2, offset, unclesLength) }\n        memcpy(scratchBuf2 + unclesShift, scratchBuf1, uncleHeaderLength);\n\n        assembly { seedHash := sha3(scratchBuf2, unclesLength) }\n\n        offset += unclesLength;\n\n        // Verify the canonical block header using the computed sha3Uncles.\n        assembly {\n            blobLength := and(calldataload(sub(offset, 30)), 0xffff)\n            shift := and(calldataload(sub(offset, 28)), 0xffff)\n        }\n        require (shift + 32 <= blobLength, \"Shift bounds check.\");\n\n        offset += 4;\n        assembly { hashSlot := calldataload(add(offset, shift)) }\n        require (hashSlot == 0, \"Non-empty hash slot.\");\n\n        assembly {\n            calldatacopy(scratchBuf1, offset, blobLength)\n            mstore(add(scratchBuf1, shift), seedHash)\n\n            // At this moment the canonical block hash is known.\n            blockHash := sha3(scratchBuf1, blobLength)\n        }\n    }\n\n    // Helper to check the placeBet receipt. \"offset\" is the location of the proof beginning in the calldata.\n    // RLP layout: [triePath, str([status, cumGasUsed, bloomFilter, [[address, [topics], data]])]\n    function requireCorrectReceipt(uint offset) view private {\n        uint leafHeaderByte; assembly { leafHeaderByte := byte(0, calldataload(offset)) }\n\n        require (leafHeaderByte >= 0xf7, \"Receipt leaf longer than 55 bytes.\");\n        offset += leafHeaderByte - 0xf6;\n\n        uint pathHeaderByte; assembly { pathHeaderByte := byte(0, calldataload(offset)) }\n\n        if (pathHeaderByte <= 0x7f) {\n            offset += 1;\n\n        } else {\n            require (pathHeaderByte >= 0x80 && pathHeaderByte <= 0xb7, \"Path is an RLP string.\");\n            offset += pathHeaderByte - 0x7f;\n        }\n\n        uint receiptStringHeaderByte; assembly { receiptStringHeaderByte := byte(0, calldataload(offset)) }\n        require (receiptStringHeaderByte == 0xb9, \"Receipt string is always at least 256 bytes long, but less than 64k.\");\n        offset += 3;\n\n        uint receiptHeaderByte; assembly { receiptHeaderByte := byte(0, calldataload(offset)) }\n        require (receiptHeaderByte == 0xf9, \"Receipt is always at least 256 bytes long, but less than 64k.\");\n        offset += 3;\n\n        uint statusByte; assembly { statusByte := byte(0, calldataload(offset)) }\n        require (statusByte == 0x1, \"Status should be success.\");\n        offset += 1;\n\n        uint cumGasHeaderByte; assembly { cumGasHeaderByte := byte(0, calldataload(offset)) }\n        if (cumGasHeaderByte <= 0x7f) {\n            offset += 1;\n\n        } else {\n            require (cumGasHeaderByte >= 0x80 && cumGasHeaderByte <= 0xb7, \"Cumulative gas is an RLP string.\");\n            offset += cumGasHeaderByte - 0x7f;\n        }\n\n        uint bloomHeaderByte; assembly { bloomHeaderByte := byte(0, calldataload(offset)) }\n        require (bloomHeaderByte == 0xb9, \"Bloom filter is always 256 bytes long.\");\n        offset += 256 + 3;\n\n        uint logsListHeaderByte; assembly { logsListHeaderByte := byte(0, calldataload(offset)) }\n        require (logsListHeaderByte == 0xf8, \"Logs list is less than 256 bytes long.\");\n        offset += 2;\n\n        uint logEntryHeaderByte; assembly { logEntryHeaderByte := byte(0, calldataload(offset)) }\n        require (logEntryHeaderByte == 0xf8, \"Log entry is less than 256 bytes long.\");\n        offset += 2;\n\n        uint addressHeaderByte; assembly { addressHeaderByte := byte(0, calldataload(offset)) }\n        require (addressHeaderByte == 0x94, \"Address is 20 bytes long.\");\n\n        uint logAddress; assembly { logAddress := and(calldataload(sub(offset, 11)), 0xffffffffffffffffffffffffffffffffffffffff) }\n        require (logAddress == uint(address(this)));\n    }\n\n    // Memory copy.\n    function memcpy(uint dest, uint src, uint len) pure private {\n        // Full 32 byte words\n        for(; len >= 32; len -= 32) {\n            assembly { mstore(dest, mload(src)) }\n            dest += 32; src += 32;\n        }\n\n        // Remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    function thisBalance() public view returns(uint) {\n        return address(this).balance;\n    }\n\n    function setAvatarIndex(uint index) external{\n      require (index >=0 && index <= 100, \"avatar index should be in range\");\n      Profile storage profile = profiles[msg.sender];\n      profile.avatarIndex = index;\n    }\n\n    function setNickName(string nickName) external{\n      Profile storage profile = profiles[msg.sender];\n      profile.nickName = nickName;\n    }\n\n    function getProfile() external view returns(uint, string){\n      Profile storage profile = profiles[msg.sender];\n      return (profile.avatarIndex, profile.nickName);\n    }\n\n    function payTodayReward(address to, uint rate) external onlyOwner {\n      uint prize = todaysRewardSize * rate / 10000;\n      todaysRewardSize = todaysRewardSize - prize;\n      if(to.send(prize)){\n        emit TodaysRankingPayment(to, prize);\n      }\n    }\n}", "debug": "calldata_AceDice_4 + calldata_AceDice_4: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_AceDice_0: 0xc73ea36700000000000000000000000000000000000000000000000000000000\ncalldatasize_AceDice: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setNickName(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/ACEDICE-0.sol", "function": "setNickName(string)", "lineno": 4, "title": "Integer Overflow ", "type": "Warning"}], "success": true}
