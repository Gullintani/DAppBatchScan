{"error": null, "issues": [{"address": 2754, "code": " address ", "debug": "", "description": "Function approve(address,uint256) retrieves the transaction origin (tx.origin) using the ORIGIN opcode. Use msg.sender instead.\nSee also: https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin", "filename": "/temp/ZethrGame-4.sol", "function": "approve(address,uint256)", "lineno": 193, "title": "Use of tx.origin", "type": "Warning"}, {"address": 3066, "code": " address ", "debug": "", "description": "Function transferFrom(address,address,uint256) retrieves the transaction origin (tx.origin) using the ORIGIN opcode. Use msg.sender instead.\nSee also: https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin", "filename": "/temp/ZethrGame-4.sol", "function": "transferFrom(address,address,uint256)", "lineno": 193, "title": "Use of tx.origin", "type": "Warning"}, {"address": 3921, "code": "Id];\n    require(own", "debug": "The exception is triggered under the following conditions:\n\ncalldata_ZethrDividendCards_4: 0x0\nstorage_8: 0x0\ncalldata_ZethrDividendCards_0: 0x882a1fa000000000000000000000000000000000000000000000000000000000\ncalldatasize_ZethrDividendCards: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/ZethrGame-4.sol", "function": "getDivCard(uint256)", "lineno": 274, "title": "Exception state", "type": "Informational"}, {"address": 4337, "code": " address ", "debug": "", "description": "Function transfer(address,uint256) retrieves the transaction origin (tx.origin) using the ORIGIN opcode. Use msg.sender instead.\nSee also: https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin", "filename": "/temp/ZethrGame-4.sol", "function": "transfer(address,uint256)", "lineno": 193, "title": "Use of tx.origin", "type": "Warning"}, {"address": 4454, "code": " address ", "debug": "", "description": "Function takeOwnership(uint256) retrieves the transaction origin (tx.origin) using the ORIGIN opcode. Use msg.sender instead.\nSee also: https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin", "filename": "/temp/ZethrGame-4.sol", "function": "takeOwnership(uint256)", "lineno": 193, "title": "Use of tx.origin", "type": "Warning"}, {"address": 6303, "code": " Solidity automatically thro", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ZethrDividendCards_32_+_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_ZethrDividendCards_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_calldata_ZethrDividendCards_32_+_36: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_ZethrDividendCards_4: 0xffffffffffffffffffffffffffffffffffffffff\norigin: 0x0\ncaller: 0x0\ncalldata_ZethrDividendCards_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_ZethrDividendCards: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/ZethrGame-4.sol", "function": "transferFrom(address,address,uint256)", "lineno": 519, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6519, "code": "ow (i.e. if subtrahend is grea", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ZethrDividendCards_4: 0x0\ncalldata_ZethrDividendCards_32 + 4: 0x2000000000001\nstorage_keccac_calldata_ZethrDividendCards_32_+_36: 0x200000000000100\ncalldata_ZethrDividendCards_4: 0x2000000000001\norigin: 0x0\ncaller: 0x0\ncalldata_ZethrDividendCards_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_ZethrDividendCards: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `transferFrom(address,address,uint256)`.\nThe subtraction may result in a value < 0.", "filename": "/temp/ZethrGame-4.sol", "function": "transferFrom(address,address,uint256)", "lineno": 526, "title": "Integer Underflow", "type": "Warning"}, {"address": 6788, "code": ";\n\n/**\n\n          ", "debug": "storage_8: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_7: 0x0\ncaller: 0x0\ncalldata_ZethrDividendCards_0: 0x7894aafa00000000000000000000000000000000000000000000000000000000\ncalldatasize_ZethrDividendCards: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createDivCard(string,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/ZethrGame-4.sol", "function": "createDivCard(string,uint256,uint256)", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7415, "code": "sfer event as defined in current draft of ERC721.\n  ///  Ownership is assigned, including births.\n  event Transfer(address from, address to, uint tokenId);\n\n  /*** CONSTANTS ***/\n\n  /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n  string public constant NAME           = \"ZethrGameDividendCard\";\n  string public constant SYMBOL         = \"ZGDC\";\n  address public         BANKROLL;\n\n  /*** STORAGE ***/\n\n  /// @dev A mapping from dividend card indices to the address that owns them.\n  ///  All dividend cards have a valid owner address.\n\n  mapping (uint => address) public      divCardIndexToOwner;\n\n  // A mapping from a dividend rate to the card index.\n\n  mapping (uint => uint) public         divCardRateToIndex;\n\n  // @dev A mapping from owner address to the number of dividend cards that address owns.\n  //  Used internally inside balanceOf() to resolve ownership count.\n\n  mapping (address => uint) private     ownershipDivCardCount;\n\n  /// @dev A mapping from dividend card indices to an address that has been approved to call\n  ///  transferFrom(). Each dividend card can only have one approved address for transfer\n  ///  at any time. A zero value means no approval is outstanding.\n\n  mapping (uint => address) public      divCardIndexToApproved;\n\n  // @dev A mapping from dividend card indices to the price of the dividend card.\n\n  mapping (uint => uint) private        divCardIndexToPrice;\n\n  mapping (address => bool) internal    administrators;\n\n  address public                        creator;\n  bool    public                        onSale;\n\n  /*** DATATYPES ***/\n\n  struct Card {\n    string name;\n    uint percentIncrease;\n  }\n\n  Card[] private divCards;\n\n  modifier onlyCreator() {\n    require(msg.sender == creator);\n    _;\n  }\n\n  constructor (address _bankroll) public {\n    creator = msg.sender;\n    BANKROLL = _bankroll;\n\n    createDivCard(\"2%\", 3 ether, 2);\n    divCardRateToIndex[2] = 0;\n\n    createDivCard(\"5%\", 4 ether, 5);\n    divCardRateToIndex[5] = 1;\n\n    createDivCard(\"10%\", 5 ether, 10);\n    divCardRateToIndex[10] = 2;\n\n    createDivCard(\"15%\", 6 ether, 15);\n    divCardRateToIndex[15] = 3;\n\n    createDivCard(\"20%\", 7 ether, 20);\n    divCardRateToIndex[20] = 4;\n\n    createDivCard(\"25%\", 8 ether, 25);\n    divCardRateToIndex[25] = 5;\n\n    createDivCard(\"33%\", 10 ether, 33);\n    divCardRateToIndex[33] = 6;\n\n    createDivCard(\"MASTER\", 30 ether, 10);\n    divCardRateToIndex[999] = 7;\n\n\tonSale = false;\n\n    administrators[creator] = true;\n\n  }\n\n  /*** MODIFIERS ***/\n\n    // Modifier to prevent contracts from interacting with the flip cards\n    modifier isNotContract()\n    {\n        require (msg.sender == tx.origin);\n        _;\n    }\n\n\t// Modifier to prevent purchases before we open them up to everyone\n\tmodifier hasStarted()\n    {\n\t\trequire (onSale == true);\n\t\t_;\n\t}\n\n\tmodifier isAdmin()\n    {\n\t    require(administrators[msg.sender]);\n\t    _;\n    }\n\n  /*** PUBLIC FUNCTIONS ***/\n  // Administrative update of the bankroll contract address\n    function setBankroll(address where)\n        isAdmin\n     public {\n        BANKROLL = where;\n    }\n\n  /// @notice Grant another address the right to transfer token via takeOwnership() and transferFrom().\n  /// @param _to The address to be granted transfer approval. Pass address(0) to\n  ///  clear all approvals.\n  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\n  /// @dev Required for ERC-721 compliance.\n  function approve(address _to, uint _tokenId)\n    public\n    isNotContract\n  {\n    // Caller must own token.\n    require(_owns(msg.sender, _tokenId));\n\n    divCardIndexToApproved[_tokenId] = _to;\n\n    emit Approval(msg.sender, _to, _tokenId);\n  }\n\n  /// For querying balance of a particular account\n  /// @param _owner The address for balance query\n  /// @dev Required for ERC-721 compliance.\n  function balanceOf(address _owner)\n    public\n    view\n    returns (uint balance)\n  {\n    return ownershipDivCardCount[_owner];\n  }\n\n  // Creates a div card with bankroll as the owner\n  function createDivCard(string _name, uint _price, uint _percentIncrease)\n    public\n    onlyCreator\n  {\n    _createDivCard(_name, BANKROLL, _price, _percentIncrease);\n  }\n\n\t// Opens the dividend cards up for sale.\n\tfunction startCardSale()\n        public\n        onlyCreator\n    {\n\t\tonSale = true;\n\t}\n\n  /// @notice Returns all the relevant information about a specific div card\n  /// @param _divCardId The tokenId of the div card of interest.\n  function getDivCard(uint _divCardId)\n    public\n    view\n    returns (string divCardName, uint sellingPrice, address owner)\n  {\n    Card storage divCard = divCards[_divCardId];\n    divCardName = divCard.name;\n    sellingPrice = divCardIndexToPrice[_divCardId];\n    owner = divCardIndexToOwner[_divCardId];\n  }\n\n  function implementsERC721()\n    public\n    pure\n    returns (bool)\n  {\n    return true;\n  }\n\n  /// @dev Required for ERC-721 compliance.\n  function name()\n    public\n    pure\n    returns (string)\n  {\n    return NAME;\n  }\n\n  /// For querying owner of token\n  /// @param _divCardId The tokenID for owner inquiry\n  /// @dev Required for ERC-721 compliance.\n  function ownerOf(uint _divCardId)\n    public\n    view\n    returns (address owner)\n  {\n    owner = divCardIndexToOwner[_divCardId];\n    require(owner != address(0));\n\treturn owner;\n  }\n\n  // Allows someone to send Ether and obtain a card\n  function purchase(uint _divCardId)\n    public\n    payable\n    hasStarted\n    isNotContract\n  {\n    address oldOwner  = divCardIndexToOwner[_divCardId];\n    address newOwner  = msg.sender;\n\n    // Get the current price of the card\n    uint currentPrice = divCardIndexToPrice[_divCardId];\n\n    // Making sure token owner is not sending to self\n    require(oldOwner != newOwner);\n\n    // Safety check to prevent against an unexpected 0x0 default.\n    require(_addressNotNull(newOwner));\n\n    // Making sure sent amount is greater than or equal to the sellingPrice\n    require(msg.value >= currentPrice);\n\n    // To find the total profit, we need to know the previous price\n    // currentPrice      = previousPrice * (100 + percentIncrease);\n    // previousPrice     = currentPrice / (100 + percentIncrease);\n    uint percentIncrease = divCards[_divCardId].percentIncrease;\n    uint previousPrice   = SafeMath.mul(currentPrice, 100).div(100 + percentIncrease);\n\n    // Calculate total profit and allocate 50% to old owner, 50% to bankroll\n    uint totalProfit     = SafeMath.sub(currentPrice, previousPrice);\n    uint oldOwnerProfit  = SafeMath.div(totalProfit, 2);\n    uint bankrollProfit  = SafeMath.sub(totalProfit, oldOwnerProfit);\n    oldOwnerProfit       = SafeMath.add(oldOwnerProfit, previousPrice);\n\n    // Refund the sender the excess he sent\n    uint purchaseExcess  = SafeMath.sub(msg.value, currentPrice);\n\n    // Raise the price by the percentage specified by the card\n    divCardIndexToPrice[_divCardId] = SafeMath.div(SafeMath.mul(currentPrice, (100 + percentIncrease)), 100);\n\n    // Transfer ownership\n    _transfer(oldOwner, newOwner, _divCardId);\n\n    // Using send rather than transfer to prevent contract exploitability.\n    BANKROLL.send(bankrollProfit);\n    oldOwner.send(oldOwnerProfit);\n\n    msg.sender.transfer(purchaseExcess);\n  }\n\n  function priceOf(uint _divCardId)\n    public\n    view\n    returns (uint price)\n  {\n    return divCardIndexToPrice[_divCardId];\n  }\n\n  function setCreator(address _creator)\n    public\n    onlyCreator\n  {\n    require(_creator != address(0));\n\n    creator = _creator;\n  }\n\n  /// @dev Required for ERC-721 compliance.\n  function symbol()\n    public\n    pure\n    returns (string)\n  {\n    return SYMBOL;\n  }\n\n  /// @notice Allow pre-approved user to take ownership of a dividend card.\n  /// @param _divCardId The ID of the card that can be transferred if this call succeeds.\n  /// @dev Required for ERC-721 compliance.\n  function takeOwnership(uint _divCardId)\n    public\n    isNotContract\n  {\n    address newOwner = msg.sender;\n    address oldOwner = divCardIndexToOwner[_divCardId];\n\n    // Safety check to prevent against an unexpected 0x0 default.\n    require(_addressNotNull(newOwner));\n\n    // Making sure transfer is approved\n    require(_approved(newOwner, _divCardId));\n\n    _transfer(oldOwner, newOwner, _divCardId);\n  }\n\n  /// For querying totalSupply of token\n  /// @dev Required for ERC-721 compliance.\n  function totalSupply()\n    public\n    view\n    returns (uint total)\n  {\n    return divCards.length;\n  }\n\n  /// Owner initates the transfer of the card to another account\n  /// @param _to The address for the card to be transferred to.\n  /// @param _divCardId The ID of the card that can be transferred if this call succeeds.\n  /// @dev Required for ERC-721 compliance.\n  function transfer(address _to, uint _divCardId)\n    public\n    isNotContract\n  {\n    require(_owns(msg.sender, _divCardId));\n    require(_addressNotNull(_to));\n\n    _transfer(msg.sender, _to, _divCardId);\n  }\n\n  /// Third-party initiates transfer of a card from address _from to address _to\n  /// @param _from The address for the card to be transferred from.\n  /// @param _to The address for the card to be transferred to.\n  /// @param _divCardId The ID of the card that can be transferred if this call succeeds.\n  /// @dev Required for ERC-721 compliance.\n  function transferFrom(address _from, address _to, uint _divCardId)\n    public\n    isNotContract\n  {\n    require(_owns(_from, _divCardId));\n    require(_approved(_to, _divCardId));\n    require(_addressNotNull(_to));\n\n    _transfer(_from, _to, _divCardId);\n  }\n\n  function receiveDividends(uint _divCardRate)\n    public\n    payable\n  {\n    uint _divCardId = divCardRateToIndex[_divCardRate];\n    address _regularAddress = divCardIndexToOwner[_divCardId];\n    address _masterAddress = divCardIndexToOwner[7];\n\n    uint toMaster = msg.value.div(2);\n    uint toRegular = msg.value.sub(toMaster);\n\n    _masterAddress.send(toMaster);\n    _regularAddress.send(toRegular);\n  }\n\n  /*** PRIVATE FUNCTIONS ***/\n  /// Safety check on _to address to prevent against an unexpected 0x0 default.\n  function _addressNotNull(address _to)\n    private\n    pure\n    returns (bool)\n  {\n    return _to != address(0);\n  }\n\n  /// For checking approval of transfer for address _to\n  function _approved(address _to, uint _divCardId)\n    private\n    view\n    returns (bool)\n  {\n    return divCardIndexToApproved[_divCardId] == _to;\n  }\n\n  /// For creating a dividend card\n  function _createDivCard(string _name, address _owner, uint _price, uint _percentIncrease)\n    private\n  {\n    Card memory _divcard = Card({\n      name: _name,\n      percentIncrease: _percentIncrease\n    });\n    uint newCardId = divCards.push(_divcard) - 1;\n\n    // It's probably never going to happen, 4 billion tokens are A LOT, but\n    // let's just be 100% sure we never let this happen.\n    require(newCardId == uint(uint32(newCardId)));\n\n    emit Birth(newCardId, _name, _owner);\n\n    divCardIndexToPrice[newCardId] = _price;\n\n    // This will assign ownership, and also emit the Transfer event as per ERC721 draft\n    _transfer(BANKROLL, _owner, newCardId);\n  }\n\n  /// Check for token ownership\n  function _owns(address claimant, uint _divCardId)\n    private\n    view\n    returns (bool)\n  {\n    return claimant == divCardIndexToOwner[_divCardId];\n  }\n\n  /// @dev Assigns ownership of a specific Card to an address.\n  function _transfer(address _from, address _to, uint _divCardId)\n    private\n  {\n    // Since the number of cards is capped to 2^32 we can't overflow this\n    ownershipDivCardCount[_to]++;\n    //transfer ownership\n    divCardIndexToOwner[_divCardId] = _to;\n\n    // When creating new div cards _from is 0x0, but we can't account that address.\n    if (_from != address(0)) {\n      ownershipDivCardCount[_from]--;\n      // clear any previously approved ownership exchange\n      delete divCardIndexToApproved[_divCardId];\n    }\n\n    // Emit the transfer event.\n    emit Transfer(_from, _to, _divCardId);\n  }\n}\n\n// SafeMath library\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint a, uint b) internal pure returns (uint) {\n    if (a == 0) {\n      return 0;\n    }\n    uint c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint a, uint b) internal pure returns (uint) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint a, uint b) internal pure returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(ui", "debug": "mem_mem_224 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_ZethrDividendCards_4 + calldata_ZethrDividendCards_4)) +\n0: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_7: 0x0\ncaller: 0x0\ncalldata_ZethrDividendCards_0: 0x7894aafa00000000000000000000000000000000000000000000000000000000\ncalldatasize_ZethrDividendCards: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createDivCard(string,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/ZethrGame-4.sol", "function": "createDivCard(string,uint256,uint256)", "lineno": 72, "title": "Integer Overflow ", "type": "Warning"}], "success": true}
