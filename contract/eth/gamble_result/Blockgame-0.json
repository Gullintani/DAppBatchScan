{"error": null, "issues": [{"address": 595, "code": "\n    for(uint i = 0; i < _topPlayersIndices.length; i++){\n      address player = gameRecords[_date].entries[_topPlayersIndices[i]].player;\n      gameRecords[_date].topPlayersAddresses.push(player);\n    }\n    gameRecords[_date].topPlayersScores = _topScores;\n  }\n\n  // Allocate winnings to top 5 (or 5+ if ties) players\n  function generateWinners(uint _date) onlyOwner {\n    require(gameRecords[_date].closedTime < currentTime())", "debug": "calldata_Blockgame_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Blockgame_0: 0x657a9c500000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x0657a9c5`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "_function_0x0657a9c5", "lineno": 162, "title": "Integer Overflow ", "type": "Warning"}, {"address": 607, "code": "\n    for(uint i = 0; i < _topPlayersIndices.length; i++){\n      address player = gameRecords[_date].entries[_topPlayersIndices[i]].player;\n      gameRecords[_date].topPlayersAddresses.push(player);\n    }\n    gameRecords[_date].topPlayersScores = _topScores;\n  }\n\n  // Allocate winnings to top 5 (or 5+ if ties) players\n  function generateWinners(uint _date) onlyOwner {\n    require(gameRecords[_date].closedTime < currentTime())", "debug": "calldata_Blockgame_4 + calldata_Blockgame_32 + 4: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_Blockgame_0: 0x657a9c500000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x0657a9c5`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "_function_0x0657a9c5", "lineno": 162, "title": "Integer Overflow ", "type": "Warning"}, {"address": 610, "code": "\n    for(uint i = 0; i < _topPlayersIndices.length; i++){\n      address player = gameRecords[_date].entries[_topPlayersIndices[i]].player;\n      gameRecords[_date].topPlayersAddresses.push(player);\n    }\n    gameRecords[_date].topPlayersScores = _topScores;\n  }\n\n  // Allocate winnings to top 5 (or 5+ if ties) players\n  function generateWinners(uint _date) onlyOwner {\n    require(gameRecords[_date].closedTime < currentTime())", "debug": "calldata_Blockgame_4 + calldata_Blockgame_32 + 4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Blockgame_0: 0x657a9c500000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x0657a9c5`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "_function_0x0657a9c5", "lineno": 162, "title": "Integer Overflow ", "type": "Warning"}, {"address": 616, "code": "\n    for(uint i = 0; i < _topPlayersIndices.length; i++){\n      address player = gameRecords[_date].entries[_topPlayersIndices[i]].player;\n      gameRecords[_date].topPlayersAddresses.push(player);\n    }\n    gameRecords[_date].topPlayersScores = _topScores;\n  }\n\n  // Allocate winnings to top 5 (or 5+ if ties) players\n  function generateWinners(uint _date) onlyOwner {\n    require(gameRecords[_date].closedTime < currentTime())", "debug": "calldata_Blockgame_4 + calldata_Blockgame_32 + 4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_Blockgame_0: 0x657a9c500000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x0657a9c5`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "_function_0x0657a9c5", "lineno": 162, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1231, "code": "         allTimeGames[_gameIndex].topPlayersScores,\n            allTimeGames[_gameIndex].winnerAmounts\n    );\n  }\n\n  function getPastGamesLength() view returns(uint _length){\n    return allTimeGames.length;\n  }\n\n  function getEntry(uint _date, uint _index) view returns(\n    address playerAddress,\n    uint[] teamsSelected,\n    uint entryIndex\n  ){\n    return (gameRecords[_date].entries[_index].player,\n            gameReco", "debug": "storage_9 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\nstorage_5 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncalldata_Blockgame_4: 0x0\nstorage_14: 0x1\ncalldata_Blockgame_0: 0x3efb537e00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\nstorage_6 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getPastGameResults(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getPastGameResults(uint256)", "lineno": 309, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1297, "code": "         allTimeGames[_gameIndex].topPlayersScores,\n            allTimeGames[_gameIndex].winnerAmounts\n    );\n  }\n\n  function getPastGamesLength() view returns(uint _length){\n    return allTimeGames.length;\n  }\n\n  function getEntry(uint _date, uint _index) view returns(\n    address playerAddress,\n    uint[] teamsSelected,\n    uint entryIndex\n  ){\n    return (gameRecords[_date].entries[_index].player,\n            gameReco", "debug": "storage_9 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nmem_128 +\n32 +\n32*\nstorage_9 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_Blockgame_4: 0x0\nstorage_14: 0x1\ncalldata_Blockgame_0: 0x3efb537e00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\nstorage_6 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x0\nstorage_5 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getPastGameResults(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getPastGameResults(uint256)", "lineno": 309, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1363, "code": "         allTimeGames[_gameIndex].topPlayersScores,\n            allTimeGames[_gameIndex].winnerAmounts\n    );\n  }\n\n  function getPastGamesLength() view returns(uint _length){\n    return allTimeGames.length;\n  }\n\n  function getEntry(uint _date, uint _index) view returns(\n    address playerAddress,\n    uint[] teamsSelected,\n    uint entryIndex\n  ){\n    return (gameRecords[_date].entries[_index].player,\n            gameReco", "debug": "mem_160 +\n32*\nstorage_9 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4 +\n32 +\n32*\nstorage_5 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x800000000000000000000000000000000000000000000000000000000000000\nmem_128 +\n32 +\n32*\nstorage_9 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x0\ncalldata_Blockgame_4: 0x0\nstorage_14: 0x1\ncalldata_Blockgame_0: 0x3efb537e00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\nstorage_6 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x0\nstorage_5 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x0\nstorage_9 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getPastGameResults(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getPastGameResults(uint256)", "lineno": 309, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1674, "code": "sts;\n  }\n\n  function changeAvailableSpend(uint _value) onlyOwner {\n    POINTS_TO_SPEN", "debug": "calldata_Blockgame_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Blockgame_0: 0x5c77582f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x5c77582f`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "_function_0x5c77582f", "lineno": 77, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4372, "code": "= _topScores;\n  }\n\n  // Allocate winnings to top ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_Blockgame_4 + calldata_Blockgame_32 + 4: 0x3\ncalldata_Blockgame_cpy: 0x0\nkeccac_8_+_keccac_calldata_Blockgame_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd\nstorage_11 + keccac_calldata_Blockgame_4: 0x0\nstorage_8 + keccac_calldata_Blockgame_4: 0x3\nstorage_4: 0x0\ncaller: 0x0\ncalldata_Blockgame_0: 0x657a9c500000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/Blockgame-0.sol", "function": "_function_0x0657a9c5", "lineno": 167, "title": "Exception state", "type": "Informational"}, {"address": 4455, "code": ";\n\ncontract Blockg", "debug": "storage_9 + keccac_calldata_Blockgame_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Blockgame_4 + calldata_Blockgame_32 + 4: 0x3\ncalldata_Blockgame_cpy: 0x0\nkeccac_8_+_keccac_calldata_Blockgame_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd\nstorage_11 + keccac_calldata_Blockgame_4: 0x1\nstorage_8 + keccac_calldata_Blockgame_4: 0x3\nstorage_4: 0x0\ncaller: 0x0\ncalldata_Blockgame_0: 0x657a9c500000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x0657a9c5`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "_function_0x0657a9c5", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4865, "code": "\n        amount = 0;\n\n        if(placeCount >", "debug": "The exception is triggered under the following conditions:\n\nstorage_3 + keccac_calldata_Blockgame_4: 0x0\ntimestamp: 0x1\nstorage_4: 0x0\ncaller: 0x0\ncalldata_Blockgame_0: 0x213f9ad400000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\nstorage_5 + keccac_calldata_Blockgame_4: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/Blockgame-0.sol", "function": "generateWinners(uint256)", "lineno": 185, "title": "Exception state", "type": "Informational"}, {"address": 4917, "code": "   percentage = 0;\n          for(uint n = place; ", "debug": "The exception is triggered under the following conditions:\n\nstorage_5 + keccac_calldata_Blockgame_4: 0x1\nstorage_3 + keccac_calldata_Blockgame_4: 0x0\ntimestamp: 0x1\nstorage_4: 0x0\ncaller: 0x0\ncalldata_Blockgame_0: 0x213f9ad400000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/Blockgame-0.sol", "function": "generateWinners(uint256)", "lineno": 189, "title": "Exception state", "type": "Informational"}, {"address": 5220, "code": ";\n        place += placeCount;\n        ", "debug": "The exception is triggered under the following conditions:\n\nstorage_5 + keccac_calldata_Blockgame_4: 0xfffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3 + keccac_calldata_Blockgame_4: 0x0\nstorage_keccac_5_+_keccac_calldata_Blockgame_4 + 0: 0x0\nstorage_keccac_5_+_keccac_calldata_Blockgame_4 + 1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ntimestamp: 0x1\nstorage_4: 0x0\ncaller: 0x0\ncalldata_Blockgame_0: 0x213f9ad400000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\nstorage_8 + keccac_calldata_Blockgame_4: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/Blockgame-0.sol", "function": "generateWinners(uint256)", "lineno": 207, "title": "Exception state", "type": "Informational"}, {"address": 5243, "code": "      }\n\n        iterator++;\n        place += placeCount;\n        p", "debug": "The exception is triggered under the following conditions:\n\nstorage_5 + keccac_calldata_Blockgame_4: 0xfffffffffffbfffffffffffffff7ffffffffffffffffffffffffffffffffffff\nstorage_3 + keccac_calldata_Blockgame_4: 0x0\nstorage_keccac_8_+_keccac_calldata_Blockgame_4 + 0: 0x0\nstorage_11 + keccac_calldata_Blockgame_4: 0x0\nstorage_8 + keccac_calldata_Blockgame_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_5_+_keccac_calldata_Blockgame_4 + 0: 0x0\nstorage_keccac_5_+_keccac_calldata_Blockgame_4 + 1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ntimestamp: 0x1\nstorage_4: 0x0\ncaller: 0x0\ncalldata_Blockgame_0: 0x213f9ad400000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/Blockgame-0.sol", "function": "generateWinners(uint256)", "lineno": 205, "title": "Exception state", "type": "Informational"}, {"address": 5326, "code": ";\n\ncontract Blockg", "debug": "storage_5 + keccac_calldata_Blockgame_4: 0x1000000000000000000000000000000000000000000000\nstorage_10 + keccac_calldata_Blockgame_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_8_+_keccac_calldata_Blockgame_4 + 0: 0x0\nstorage_3 + keccac_calldata_Blockgame_4: 0x0\nstorage_11 + keccac_calldata_Blockgame_4: 0x1\nstorage_8 + keccac_calldata_Blockgame_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_5_+_keccac_calldata_Blockgame_4 + 0: 0x0\nstorage_keccac_5_+_keccac_calldata_Blockgame_4 + 1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ntimestamp: 0x1\nstorage_4: 0x0\ncaller: 0x0\ncalldata_Blockgame_0: 0x213f9ad400000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `generateWinners(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "generateWinners(uint256)", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5448, "code": ";\n\ncontract Blockg", "debug": "storage_5 + keccac_calldata_Blockgame_4: 0x1000000000000000000000000000000000000000000000\nstorage_6 + keccac_calldata_Blockgame_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_8_+_keccac_calldata_Blockgame_4 + 0: 0x0\nstorage_3 + keccac_calldata_Blockgame_4: 0x0\nstorage_11 + keccac_calldata_Blockgame_4: 0x1\nstorage_8 + keccac_calldata_Blockgame_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_5_+_keccac_calldata_Blockgame_4 + 0: 0x0\nstorage_keccac_5_+_keccac_calldata_Blockgame_4 + 1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ntimestamp: 0x1\nstorage_4: 0x0\ncaller: 0x0\ncalldata_Blockgame_0: 0x213f9ad400000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `generateWinners(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "generateWinners(uint256)", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6149, "code": "ic allTimeGames;\n  mapping(uint", "debug": "The exception is triggered under the following conditions:\n\ncalldata_Blockgame_4: 0x0\nstorage_14: 0x0\ncalldata_Blockgame_0: 0x3d679e9600000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/Blockgame-0.sol", "function": "_function_0x3d679e96", "lineno": 17, "title": "Exception state", "type": "Informational"}, {"address": 6217, "code": "iew returns(\n    address", "debug": "The exception is triggered under the following conditions:\n\ncalldata_Blockgame_4: 0x0\nstorage_14: 0x0\ncalldata_Blockgame_0: 0x3efb537e00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/Blockgame-0.sol", "function": "getPastGameResults(uint256)", "lineno": 318, "title": "Exception state", "type": "Informational"}, {"address": 6306, "code": "index) view returns(\n    address playerAddress,\n    uint[] teamsSelected,\n    uint entryIndex\n  ){\n    return (gameRecords[_date].entries[_index].player,\n            ga", "debug": "storage_9 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_Blockgame_4: 0x0\nstorage_14: 0x1\ncalldata_Blockgame_0: 0x3efb537e00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getPastGameResults(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getPastGameResults(uint256)", "lineno": 318, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6309, "code": "index) view returns(\n    address playerAddress,\n    uint[] teamsSelected,\n    uint entryIndex\n  ){\n    return (gameRecords[_date].entries[_index].player,\n            ga", "debug": "storage_9 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Blockgame_4: 0x0\nstorage_14: 0x1\ncalldata_Blockgame_0: 0x3efb537e00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getPastGameResults(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getPastGameResults(uint256)", "lineno": 318, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6315, "code": "index) view returns(\n    address playerAddress,\n    uint[] teamsSelected,\n    uint entryIndex\n  ){\n    return (gameRecords[_date].entries[_index].player,\n            ga", "debug": "storage_9 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_Blockgame_4: 0x0\nstorage_14: 0x1\ncalldata_Blockgame_0: 0x3efb537e00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getPastGameResults(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getPastGameResults(uint256)", "lineno": 318, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6340, "code": "index) view returns(\n    address playerAddress,\n    uint[] teamsSelected,\n    uint entryIndex\n  ){\n    return (gameRecords[_date].entries[_index].player,\n            ga", "debug": "storage_9 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\ncalldata_Blockgame_4: 0x0\nstorage_14: 0x1\ncalldata_Blockgame_0: 0x3efb537e00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getPastGameResults(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getPastGameResults(uint256)", "lineno": 318, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6342, "code": "index) view returns(\n    address playerAddress,\n    uint[] teamsSelected,\n    uint entryIndex\n  ){\n    return (gameRecords[_date].entries[_index].player,\n            ga", "debug": "storage_9 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_Blockgame_4: 0x0\nstorage_14: 0x1\ncalldata_Blockgame_0: 0x3efb537e00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getPastGameResults(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getPastGameResults(uint256)", "lineno": 318, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6442, "code": "index) view returns(\n    address playerAddress,\n    uint[] teamsSelected,\n    uint entryIndex\n  ){\n    return (gameRecords[_date].entries[_index].player,\n            ga", "debug": "storage_9 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x1\nstorage_5 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_Blockgame_4: 0x0\nstorage_14: 0x1\ncalldata_Blockgame_0: 0x3efb537e00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getPastGameResults(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getPastGameResults(uint256)", "lineno": 318, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6445, "code": "index) view returns(\n    address playerAddress,\n    uint[] teamsSelected,\n    uint entryIndex\n  ){\n    return (gameRecords[_date].entries[_index].player,\n            ga", "debug": "storage_9 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x1000000000000000000000000000000000000000000000000000000000000000\nstorage_5 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Blockgame_4: 0x0\nstorage_14: 0x1\ncalldata_Blockgame_0: 0x3efb537e00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getPastGameResults(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getPastGameResults(uint256)", "lineno": 318, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6451, "code": "index) view returns(\n    address playerAddress,\n    uint[] teamsSelected,\n    uint entryIndex\n  ){\n    return (gameRecords[_date].entries[_index].player,\n            ga", "debug": "storage_9 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x8000000000000000000000000000000000000000000000000000000000000001\nstorage_5 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9\ncalldata_Blockgame_4: 0x0\nstorage_14: 0x1\ncalldata_Blockgame_0: 0x3efb537e00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getPastGameResults(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getPastGameResults(uint256)", "lineno": 318, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6476, "code": "index) view returns(\n    address playerAddress,\n    uint[] teamsSelected,\n    uint entryIndex\n  ){\n    return (gameRecords[_date].entries[_index].player,\n            ga", "debug": "storage_9 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x1\nstorage_5 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x84210842108001f024e0e8c64e51842000000000000001f21084210607c001d\ncalldata_Blockgame_4: 0x0\nstorage_14: 0x1\ncalldata_Blockgame_0: 0x3efb537e00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getPastGameResults(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getPastGameResults(uint256)", "lineno": 318, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6478, "code": "index) view returns(\n    address playerAddress,\n    uint[] teamsSelected,\n    uint entryIndex\n  ){\n    return (gameRecords[_date].entries[_index].player,\n            ga", "debug": "storage_9 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x1\nstorage_5 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Blockgame_4: 0x0\nstorage_14: 0x1\ncalldata_Blockgame_0: 0x3efb537e00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getPastGameResults(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getPastGameResults(uint256)", "lineno": 318, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6558, "code": "index) view returns(\n    address playerAddress,\n    uint[] teamsSelected,\n    uint entryIndex\n  ){\n    return (gameRecords[_date].entries[_index].player,\n            ga", "debug": "storage_9 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x800000000000000000000000000000000000000000000000000000000000000\nstorage_5 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_6 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x82aaaaa2c00001f000000aaaaaaa00000000001f043c1b6011d0002082c3df0\ncalldata_Blockgame_4: 0x0\nstorage_14: 0x1\ncalldata_Blockgame_0: 0x3efb537e00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getPastGameResults(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getPastGameResults(uint256)", "lineno": 318, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6560, "code": "index) view returns(\n    address playerAddress,\n    uint[] teamsSelected,\n    uint entryIndex\n  ){\n    return (gameRecords[_date].entries[_index].player,\n            ga", "debug": "storage_9 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_5 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x1\nstorage_6 +\n84800337471693920904250232874319843718400766719524250287777680170677855896573 +\n12*calldata_Blockgame_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9\ncalldata_Blockgame_4: 0x0\nstorage_14: 0x1\ncalldata_Blockgame_0: 0x3efb537e00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getPastGameResults(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getPastGameResults(uint256)", "lineno": 318, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6626, "code": "blic payoutPercentages;\n  uint p", "debug": "The exception is triggered under the following conditions:\n\ncalldata_Blockgame_4: 0x6\ncalldata_Blockgame_0: 0x49a046c100000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/Blockgame-0.sol", "function": "_function_0x49a046c1", "lineno": 11, "title": "Exception state", "type": "Informational"}, {"address": 7017, "code": "allTeamsScores;\n\n  DailyGame", "debug": "The exception is triggered under the following conditions:\n\ncalldata_Blockgame_4: 0x0\nstorage_13: 0x0\ncalldata_Blockgame_0: 0x61a9915a00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/Blockgame-0.sol", "function": "_function_0x61a9915a", "lineno": 15, "title": "Exception state", "type": "Informational"}, {"address": 7092, "code": "ate].pool;\n  }\n\n  function getBalance() view returns(uint _amount) {\n    retu", "debug": "storage_6 + keccac_calldata_Blockgame_4: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_Blockgame_0: 0x6b1426a400000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getWinners(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getWinners(uint256)", "lineno": 290, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7095, "code": "ate].pool;\n  }\n\n  function getBalance() view returns(uint _amount) {\n    retu", "debug": "storage_6 + keccac_calldata_Blockgame_4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Blockgame_0: 0x6b1426a400000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getWinners(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getWinners(uint256)", "lineno": 290, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7101, "code": "ate].pool;\n  }\n\n  function getBalance() view returns(uint _amount) {\n    retu", "debug": "storage_6 + keccac_calldata_Blockgame_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_Blockgame_0: 0x6b1426a400000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getWinners(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getWinners(uint256)", "lineno": 290, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7126, "code": "ate].pool;\n  }\n\n  function getBalance() view returns(uint _amount) {\n    retu", "debug": "storage_6 + keccac_calldata_Blockgame_4: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\ncalldata_Blockgame_0: 0x6b1426a400000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getWinners(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getWinners(uint256)", "lineno": 290, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7128, "code": "ate].pool;\n  }\n\n  function getBalance() view returns(uint _amount) {\n    retu", "debug": "storage_6 + keccac_calldata_Blockgame_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_Blockgame_0: 0x6b1426a400000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getWinners(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getWinners(uint256)", "lineno": 290, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7208, "code": "ate].pool;\n  }\n\n  function getBalance() view returns(uint _amount) {\n    retu", "debug": "storage_10 + keccac_calldata_Blockgame_4: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\ncalldata_Blockgame_0: 0x6b1426a400000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\nstorage_6 + keccac_calldata_Blockgame_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getWinners(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getWinners(uint256)", "lineno": 290, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7210, "code": "ate].pool;\n  }\n\n  function getBalance() view returns(uint _amount) {\n    retu", "debug": "storage_10 + keccac_calldata_Blockgame_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa\ncalldata_Blockgame_0: 0x6b1426a400000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\nstorage_6 + keccac_calldata_Blockgame_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getWinners(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "getWinners(uint256)", "lineno": 290, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7328, "code": "rScores(uint _date) view r", "debug": "The exception is triggered under the following conditions:\n\ncalldata_Blockgame_4: 0x0\nstorage_13: 0x0\ncalldata_Blockgame_0: 0x75aa39bd00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/Blockgame-0.sol", "function": "getTeamScore(uint256)", "lineno": 273, "title": "Exception state", "type": "Informational"}, {"address": 10963, "code": "ntract Blockgame {\n\n  uint public ENTRY_FEE = 0.075 ether;\n  uint public POINTS_TO_SPEND = 150;\n  uint public TEAMS_PER_ENTRY = 6;\n  uint public MAX_ENTRIES = 200;\n\n  address public owner;\n  uint[6] public payoutPercentages;\n  uint public debt;\n\n  uint[] public allTeamsCosts;\n  uint[] public allTeamsScores;\n\n  DailyGame[] public allTimeGames;\n  mapping(uint => bool) public gamesList;\n  mapping(uint => DailyGame) public gameRecords; // uint == dateOfGame\n  mapping(address => uint) public availableWinnings;\n\n  event NewEntry(address indexed player, uint[] selectedTeams);\n\n  struct Entry {\n    uint timestamp;\n    uint[] teamsSelected;\n    address player;\n    uint entryIndex;\n  }\n\n  // Pre and post summary\n  struct DailyGame {\n    uint numPlayers;\n    uint pool;\n    uint date;\n    uint closedTime;\n    uint[] playerScores; // A\n    uint[] topPlayersScores; // B\n    uint[] winnerAmounts; // C\n    address[] players; // A\n    uint[] topPlayersIndices; // B\n    address[] topPlayersAddresses; // B\n    address[] winnerAddresses; // C\n    Entry[] entries;\n  }\n\n  constructor(){\n    owner = msg.sender;\n\n    payoutPercentages[0] = 0;\n    payoutPercentages[1] = 50;\n    payoutPercentages[2] = 16;\n    payoutPercentages[3] = 12;\n    payoutPercentages[4] = 8;\n    payoutPercentages[5] = 4;\n  }\n\n\n  //UTILITIES\n  function() external payable { }\n\n  modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function changeEntryFee(uint _value) onlyOwner {\n    ENTRY_FEE = _value;\n  }\n\n  function changeMaxEntries(uint _value) onlyOwner {\n    MAX_ENTRIES = _value;\n  }\n\n  //submit alphabetically\n  function changeTeamCosts(uint[] _costs) onlyOwner {\n    allTeamsCosts = _costs;\n  }\n\n  function changeAvailableSpend(uint _value) onlyOwner {\n    POINTS_TO_SPEND = _value;\n  }\n\n  // _closedTime == Unix timestamp\n  function createGame(uint _gameDate, uint _closedTime) onlyOwner {\n    gamesList[_gameDate] = true;\n    gameRecords[_gameDate].closedTime = _closedTime;\n  }\n\n  function withdraw(uint amount) onlyOwner returns(bool) {\n    require(amount <= (address(this).balance - debt));\n    owner.transfer(amount);\n    return true;\n  }\n\n  function selfDestruct() onlyOwner {\n    selfdestruct(owner);\n  }\n\n\n  // SUBMITTING AN ENTRY\n\n  // Verify that game exists\n  modifier gameOpen(uint _gameDate) {\n    require(gamesList[_gameDate] == true);\n    _;\n  }\n\n  // Verify that teams selection is within cost\n  modifier withinCost(uint[] teamIndices) {\n      require(teamIndices.length == 6);\n      uint sum = 0;\n\n      for(uint i = 0;i < 6; i++){\n        uint cost = allTeamsCosts[teamIndices[i]];\n        sum += cost;\n      }\n\n      require(sum <= POINTS_TO_SPEND);\n      _;\n  }\n\n  // Verify that constest hasn't closed\n  modifier beforeCutoff(uint _date) {\n    require(gameRecords[_date].closedTime > currentTime());\n    _;\n  }\n\n  function createEntry(uint date, uint[] teamIndices) payable\n                       withinCost(teamIndices)\n                       gameOpen(date)\n                       beforeCutoff(date)\n                       external {\n\n    require(msg.value == ENTRY_FEE);\n    require(gameRecords[date].numPlayers < MAX_ENTRIES);\n\n    Entry memory entry;\n    entry.timestamp = currentTime();\n    entry.player = msg.sender;\n    entry.teamsSelected = teamIndices;\n\n    gameRecords[date].entries.push(entry);\n    gameRecords[date].numPlayers++;\n    gameRecords[date].pool += ENTRY_FEE;\n\n    uint entryIndex = gameRecords[date].players.push(msg.sender) - 1;\n    gameRecords[date].entries[entryIndex].entryIndex = entryIndex;\n\n    emit NewEntry(msg.sender, teamIndices);\n  }\n\n\n  // ANALYZING SCORES\n\n  // Register teams (alphabetically) points total for each game\n  function registerTeamScores(uint[] _scores) onlyOwner {\n    allTeamsScores = _scores;\n  }\n\n  function registerTopPlayers(uint _date, uint[] _topPlayersIndices, uint[] _topScores) onlyOwner {\n    gameRecords[_date].topPlayersIndices = _topPlayersIndices;\n    for(uint i = 0; i < _topPlayersIndices.length; i++){\n      address player = gameRecords[_date].entries[_topPlayersIndices[i]].player;\n      gameRecords[_date].topPlayersAddresses.push(player);\n    }\n    gameRecords[_date].topPlayersScores = _topScores;\n  }\n\n  // Allocate winnings to top 5 (or 5+ if ties) players\n  function generateWinners(uint _date) onlyOwner {\n    require(gameRecords[_date].closedTime < currentTime());\n    uint place = 1;\n    uint iterator = 0;\n    uint placeCount = 1;\n    uint currentScore = 1;\n    uint percentage = 0;\n    uint amount = 0;\n\n    while(place <= 5){\n      currentScore = gameRecords[_date].topPlayersScores[iterator];\n      if(gameRecords[_date].topPlayersScores[iterator + 1] == currentScore){\n        placeCount++;\n        iterator++;\n      } else {\n        amount = 0;\n\n        if(placeCount > 1){\n          percentage = 0;\n          for(uint n = place; n <= (place + placeCount);n++){\n            if(n <= 5){\n              percentage += payoutPercentages[n];\n            }\n          }\n          amount = gameRecords[_date].pool / placeCount * percentage / 100;\n        } else {\n          amount = gameRecords[_date].pool * payoutPercentages[place] / 100;\n        }\n\n\n        for(uint i = place - 1; i < (place + placeCount - 1); i++){\n          address winnerAddress = gameRecords[_date].entries[gameRecords[_date].topPlayersIndices[i]].player;\n          gameRecords[_date].winnerAddresses.push(winnerAddress);\n          gameRecords[_date].winnerAmounts.push(amount);\n        }\n\n        iterator++;\n        place += placeCount;\n        placeCount = 1;\n      }\n\n    }\n    allTimeGames.push(gameRecords[_date]);\n  }\n\n  function assignWinnings(uint _date) onlyOwner {\n    address[] storage winners = gameRecords[_date].winnerAddresses;\n    uint[] storage winnerAmounts = gameRecords[_date].winnerAmounts;\n\n    for(uint z = 0; z < winners.length; z++){\n      address currentWinner = winners[z];\n      uint currentRedeemable = availableWinnings[currentWinner];\n      uint newRedeemable = currentRedeemable + winnerAmounts[z];\n      availableWinnings[currentWinner] = newRedeemable;\n      debt += winnerAmounts[z];\n    }\n  }\n\n  function redeem() external returns(bool success) {\n    require(availableWinnings[msg.sender] > 0);\n    uint amount = availableWinnings[msg.sender];\n    availableWinnings[msg.sender] = 0;\n    debt -= amount;\n    msg.sender.transfer(amount);\n    return true;\n  }\n\n  function getAvailableWinnings(address _address) view returns(uint amount){\n    return availableWinnings[_address];\n  }\n\n\n  // OTHER USEFUL FUNCTIONS / TESTING\n\n  function currentTime() view returns (uint _currentTime) {\n    return now;\n  }\n\n  function getPointsToSpend() view returns(uint _POINTS_TO_SPEND) {\n    return POINTS_TO_SPEND;\n  }\n\n  function getGameNumberOfEntries(uint _date) view returns(uint _length){\n    return gameRecords[_date].entries.length;\n  }\n\n  function getCutoffTime(uint _date) view returns(uint cutoff){\n    return gameRecords[_date].closedTime;\n  }\n\n  function getTeamScore(uint _teamIndex) view returns(uint score){\n    return allTeamsScores[_teamIndex];\n  }\n\n  function getAllTeamScores() view returns(uint[] scores){\n    return allTeamsScores;\n  }\n\n  function getAllPlayers(uint _date) view returns(address[] _players){\n    return gameRecords[_date].players;\n  }\n\n  function getTopPlayerScores(uint _date) view returns(uint[] scores){\n    return gameRecords[_date].topPlayersScores;\n  }\n\n  function getTopPlayers(uint _date) view returns(address[] _players){\n    return gameRecords[_date].topPlayersAddresses;\n  }\n\n  function getWinners(uint _date) view returns(uint[] _amounts, address[] _players){\n    return (gameRecords[_date].winnerAmounts, gameRecords[_date].winnerAddresses);\n  }\n\n  function getNumEntries(uint _date) view returns(uint _num){\n    return gameRecords[_date].numPlayers;\n  }\n\n  function getPoolValue(uint _date) view returns(uint amount){\n    return gameRecords[_date].pool;\n  }\n\n  function getBalance() view returns(uint _amount) {\n    return address(this).balance;\n  }\n\n  function getTeamCost(uint _index) constant returns(uint cost){\n    return allTeamsCosts[_index];\n  }\n\n  function getAllTeamCosts() view returns(uint[] costs){\n    return allTeamsCosts;\n  }\n\n  function getPastGameResults(uint _gameIndex) view returns(address[] topPlayers,\n                                                            uint[] topPlayersScores,\n                                                            uint[] winnings){\n    return (allTimeGames[_gameIndex].topPlayersAddresses,\n            allTimeGames[_gameIndex].topPlayersScores,\n            allTimeGames[_gameIndex].winnerAmounts\n    );\n  }\n\n  function getPastGamesLength() view returns(uint _length){\n    return allTimeGames.length;\n  }\n\n  function getEntry(uint _date, uint _index) view returns(\n    address playerAddress,\n    uint[] teamsSelected,\n    uint entryIndex\n  ){\n    return (gameRecords[_date].entries[_index].player,\n            gameRecords[_date].entries[_index].teamsSelected,\n            gameRecords[_date].entries[_index].entryIndex);\n  }\n\n}", "debug": "storage_12: 0x2103ca3087fcf3fa7408c3eadeffcf77fe3d73ffaffeffe052ffe520c585abb8\nstorage_4: 0x0\ncaller: 0x0\ncalldata_Blockgame_0: 0x5c77582f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x5c77582f`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "_function_0x5c77582f", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 10974, "code": "ntract Blockgame {\n\n  uint public ENTRY_FEE = 0.075 ether;\n  uint public POINTS_TO_SPEND = 150;\n  uint public TEAMS_PER_ENTRY = 6;\n  uint public MAX_ENTRIES = 200;\n\n  address public owner;\n  uint[6] public payoutPercentages;\n  uint public debt;\n\n  uint[] public allTeamsCosts;\n  uint[] public allTeamsScores;\n\n  DailyGame[] public allTimeGames;\n  mapping(uint => bool) public gamesList;\n  mapping(uint => DailyGame) public gameRecords; // uint == dateOfGame\n  mapping(address => uint) public availableWinnings;\n\n  event NewEntry(address indexed player, uint[] selectedTeams);\n\n  struct Entry {\n    uint timestamp;\n    uint[] teamsSelected;\n    address player;\n    uint entryIndex;\n  }\n\n  // Pre and post summary\n  struct DailyGame {\n    uint numPlayers;\n    uint pool;\n    uint date;\n    uint closedTime;\n    uint[] playerScores; // A\n    uint[] topPlayersScores; // B\n    uint[] winnerAmounts; // C\n    address[] players; // A\n    uint[] topPlayersIndices; // B\n    address[] topPlayersAddresses; // B\n    address[] winnerAddresses; // C\n    Entry[] entries;\n  }\n\n  constructor(){\n    owner = msg.sender;\n\n    payoutPercentages[0] = 0;\n    payoutPercentages[1] = 50;\n    payoutPercentages[2] = 16;\n    payoutPercentages[3] = 12;\n    payoutPercentages[4] = 8;\n    payoutPercentages[5] = 4;\n  }\n\n\n  //UTILITIES\n  function() external payable { }\n\n  modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function changeEntryFee(uint _value) onlyOwner {\n    ENTRY_FEE = _value;\n  }\n\n  function changeMaxEntries(uint _value) onlyOwner {\n    MAX_ENTRIES = _value;\n  }\n\n  //submit alphabetically\n  function changeTeamCosts(uint[] _costs) onlyOwner {\n    allTeamsCosts = _costs;\n  }\n\n  function changeAvailableSpend(uint _value) onlyOwner {\n    POINTS_TO_SPEND = _value;\n  }\n\n  // _closedTime == Unix timestamp\n  function createGame(uint _gameDate, uint _closedTime) onlyOwner {\n    gamesList[_gameDate] = true;\n    gameRecords[_gameDate].closedTime = _closedTime;\n  }\n\n  function withdraw(uint amount) onlyOwner returns(bool) {\n    require(amount <= (address(this).balance - debt));\n    owner.transfer(amount);\n    return true;\n  }\n\n  function selfDestruct() onlyOwner {\n    selfdestruct(owner);\n  }\n\n\n  // SUBMITTING AN ENTRY\n\n  // Verify that game exists\n  modifier gameOpen(uint _gameDate) {\n    require(gamesList[_gameDate] == true);\n    _;\n  }\n\n  // Verify that teams selection is within cost\n  modifier withinCost(uint[] teamIndices) {\n      require(teamIndices.length == 6);\n      uint sum = 0;\n\n      for(uint i = 0;i < 6; i++){\n        uint cost = allTeamsCosts[teamIndices[i]];\n        sum += cost;\n      }\n\n      require(sum <= POINTS_TO_SPEND);\n      _;\n  }\n\n  // Verify that constest hasn't closed\n  modifier beforeCutoff(uint _date) {\n    require(gameRecords[_date].closedTime > currentTime());\n    _;\n  }\n\n  function createEntry(uint date, uint[] teamIndices) payable\n                       withinCost(teamIndices)\n                       gameOpen(date)\n                       beforeCutoff(date)\n                       external {\n\n    require(msg.value == ENTRY_FEE);\n    require(gameRecords[date].numPlayers < MAX_ENTRIES);\n\n    Entry memory entry;\n    entry.timestamp = currentTime();\n    entry.player = msg.sender;\n    entry.teamsSelected = teamIndices;\n\n    gameRecords[date].entries.push(entry);\n    gameRecords[date].numPlayers++;\n    gameRecords[date].pool += ENTRY_FEE;\n\n    uint entryIndex = gameRecords[date].players.push(msg.sender) - 1;\n    gameRecords[date].entries[entryIndex].entryIndex = entryIndex;\n\n    emit NewEntry(msg.sender, teamIndices);\n  }\n\n\n  // ANALYZING SCORES\n\n  // Register teams (alphabetically) points total for each game\n  function registerTeamScores(uint[] _scores) onlyOwner {\n    allTeamsScores = _scores;\n  }\n\n  function registerTopPlayers(uint _date, uint[] _topPlayersIndices, uint[] _topScores) onlyOwner {\n    gameRecords[_date].topPlayersIndices = _topPlayersIndices;\n    for(uint i = 0; i < _topPlayersIndices.length; i++){\n      address player = gameRecords[_date].entries[_topPlayersIndices[i]].player;\n      gameRecords[_date].topPlayersAddresses.push(player);\n    }\n    gameRecords[_date].topPlayersScores = _topScores;\n  }\n\n  // Allocate winnings to top 5 (or 5+ if ties) players\n  function generateWinners(uint _date) onlyOwner {\n    require(gameRecords[_date].closedTime < currentTime());\n    uint place = 1;\n    uint iterator = 0;\n    uint placeCount = 1;\n    uint currentScore = 1;\n    uint percentage = 0;\n    uint amount = 0;\n\n    while(place <= 5){\n      currentScore = gameRecords[_date].topPlayersScores[iterator];\n      if(gameRecords[_date].topPlayersScores[iterator + 1] == currentScore){\n        placeCount++;\n        iterator++;\n      } else {\n        amount = 0;\n\n        if(placeCount > 1){\n          percentage = 0;\n          for(uint n = place; n <= (place + placeCount);n++){\n            if(n <= 5){\n              percentage += payoutPercentages[n];\n            }\n          }\n          amount = gameRecords[_date].pool / placeCount * percentage / 100;\n        } else {\n          amount = gameRecords[_date].pool * payoutPercentages[place] / 100;\n        }\n\n\n        for(uint i = place - 1; i < (place + placeCount - 1); i++){\n          address winnerAddress = gameRecords[_date].entries[gameRecords[_date].topPlayersIndices[i]].player;\n          gameRecords[_date].winnerAddresses.push(winnerAddress);\n          gameRecords[_date].winnerAmounts.push(amount);\n        }\n\n        iterator++;\n        place += placeCount;\n        placeCount = 1;\n      }\n\n    }\n    allTimeGames.push(gameRecords[_date]);\n  }\n\n  function assignWinnings(uint _date) onlyOwner {\n    address[] storage winners = gameRecords[_date].winnerAddresses;\n    uint[] storage winnerAmounts = gameRecords[_date].winnerAmounts;\n\n    for(uint z = 0; z < winners.length; z++){\n      address currentWinner = winners[z];\n      uint currentRedeemable = availableWinnings[currentWinner];\n      uint newRedeemable = currentRedeemable + winnerAmounts[z];\n      availableWinnings[currentWinner] = newRedeemable;\n      debt += winnerAmounts[z];\n    }\n  }\n\n  function redeem() external returns(bool success) {\n    require(availableWinnings[msg.sender] > 0);\n    uint amount = availableWinnings[msg.sender];\n    availableWinnings[msg.sender] = 0;\n    debt -= amount;\n    msg.sender.transfer(amount);\n    return true;\n  }\n\n  function getAvailableWinnings(address _address) view returns(uint amount){\n    return availableWinnings[_address];\n  }\n\n\n  // OTHER USEFUL FUNCTIONS / TESTING\n\n  function currentTime() view returns (uint _currentTime) {\n    return now;\n  }\n\n  function getPointsToSpend() view returns(uint _POINTS_TO_SPEND) {\n    return POINTS_TO_SPEND;\n  }\n\n  function getGameNumberOfEntries(uint _date) view returns(uint _length){\n    return gameRecords[_date].entries.length;\n  }\n\n  function getCutoffTime(uint _date) view returns(uint cutoff){\n    return gameRecords[_date].closedTime;\n  }\n\n  function getTeamScore(uint _teamIndex) view returns(uint score){\n    return allTeamsScores[_teamIndex];\n  }\n\n  function getAllTeamScores() view returns(uint[] scores){\n    return allTeamsScores;\n  }\n\n  function getAllPlayers(uint _date) view returns(address[] _players){\n    return gameRecords[_date].players;\n  }\n\n  function getTopPlayerScores(uint _date) view returns(uint[] scores){\n    return gameRecords[_date].topPlayersScores;\n  }\n\n  function getTopPlayers(uint _date) view returns(address[] _players){\n    return gameRecords[_date].topPlayersAddresses;\n  }\n\n  function getWinners(uint _date) view returns(uint[] _amounts, address[] _players){\n    return (gameRecords[_date].winnerAmounts, gameRecords[_date].winnerAddresses);\n  }\n\n  function getNumEntries(uint _date) view returns(uint _num){\n    return gameRecords[_date].numPlayers;\n  }\n\n  function getPoolValue(uint _date) view returns(uint amount){\n    return gameRecords[_date].pool;\n  }\n\n  function getBalance() view returns(uint _amount) {\n    return address(this).balance;\n  }\n\n  function getTeamCost(uint _index) constant returns(uint cost){\n    return allTeamsCosts[_index];\n  }\n\n  function getAllTeamCosts() view returns(uint[] costs){\n    return allTeamsCosts;\n  }\n\n  function getPastGameResults(uint _gameIndex) view returns(address[] topPlayers,\n                                                            uint[] topPlayersScores,\n                                                            uint[] winnings){\n    return (allTimeGames[_gameIndex].topPlayersAddresses,\n            allTimeGames[_gameIndex].topPlayersScores,\n            allTimeGames[_gameIndex].winnerAmounts\n    );\n  }\n\n  function getPastGamesLength() view returns(uint _length){\n    return allTimeGames.length;\n  }\n\n  function getEntry(uint _date, uint _index) view returns(\n    address playerAddress,\n    uint[] teamsSelected,\n    uint entryIndex\n  ){\n    return (gameRecords[_date].entries[_index].player,\n            gameRecords[_date].entries[_index].teamsSelected,\n            gameRecords[_date].entries[_index].entryIndex);\n  }\n\n}", "debug": "calldata_Blockgame_4 + calldata_Blockgame_4: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\nstorage_4: 0x0\ncaller: 0x0\ncalldata_Blockgame_0: 0x5c77582f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x5c77582f`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "_function_0x5c77582f", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 10976, "code": "ntract Blockgame {\n\n  uint public ENTRY_FEE = 0.075 ether;\n  uint public POINTS_TO_SPEND = 150;\n  uint public TEAMS_PER_ENTRY = 6;\n  uint public MAX_ENTRIES = 200;\n\n  address public owner;\n  uint[6] public payoutPercentages;\n  uint public debt;\n\n  uint[] public allTeamsCosts;\n  uint[] public allTeamsScores;\n\n  DailyGame[] public allTimeGames;\n  mapping(uint => bool) public gamesList;\n  mapping(uint => DailyGame) public gameRecords; // uint == dateOfGame\n  mapping(address => uint) public availableWinnings;\n\n  event NewEntry(address indexed player, uint[] selectedTeams);\n\n  struct Entry {\n    uint timestamp;\n    uint[] teamsSelected;\n    address player;\n    uint entryIndex;\n  }\n\n  // Pre and post summary\n  struct DailyGame {\n    uint numPlayers;\n    uint pool;\n    uint date;\n    uint closedTime;\n    uint[] playerScores; // A\n    uint[] topPlayersScores; // B\n    uint[] winnerAmounts; // C\n    address[] players; // A\n    uint[] topPlayersIndices; // B\n    address[] topPlayersAddresses; // B\n    address[] winnerAddresses; // C\n    Entry[] entries;\n  }\n\n  constructor(){\n    owner = msg.sender;\n\n    payoutPercentages[0] = 0;\n    payoutPercentages[1] = 50;\n    payoutPercentages[2] = 16;\n    payoutPercentages[3] = 12;\n    payoutPercentages[4] = 8;\n    payoutPercentages[5] = 4;\n  }\n\n\n  //UTILITIES\n  function() external payable { }\n\n  modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function changeEntryFee(uint _value) onlyOwner {\n    ENTRY_FEE = _value;\n  }\n\n  function changeMaxEntries(uint _value) onlyOwner {\n    MAX_ENTRIES = _value;\n  }\n\n  //submit alphabetically\n  function changeTeamCosts(uint[] _costs) onlyOwner {\n    allTeamsCosts = _costs;\n  }\n\n  function changeAvailableSpend(uint _value) onlyOwner {\n    POINTS_TO_SPEND = _value;\n  }\n\n  // _closedTime == Unix timestamp\n  function createGame(uint _gameDate, uint _closedTime) onlyOwner {\n    gamesList[_gameDate] = true;\n    gameRecords[_gameDate].closedTime = _closedTime;\n  }\n\n  function withdraw(uint amount) onlyOwner returns(bool) {\n    require(amount <= (address(this).balance - debt));\n    owner.transfer(amount);\n    return true;\n  }\n\n  function selfDestruct() onlyOwner {\n    selfdestruct(owner);\n  }\n\n\n  // SUBMITTING AN ENTRY\n\n  // Verify that game exists\n  modifier gameOpen(uint _gameDate) {\n    require(gamesList[_gameDate] == true);\n    _;\n  }\n\n  // Verify that teams selection is within cost\n  modifier withinCost(uint[] teamIndices) {\n      require(teamIndices.length == 6);\n      uint sum = 0;\n\n      for(uint i = 0;i < 6; i++){\n        uint cost = allTeamsCosts[teamIndices[i]];\n        sum += cost;\n      }\n\n      require(sum <= POINTS_TO_SPEND);\n      _;\n  }\n\n  // Verify that constest hasn't closed\n  modifier beforeCutoff(uint _date) {\n    require(gameRecords[_date].closedTime > currentTime());\n    _;\n  }\n\n  function createEntry(uint date, uint[] teamIndices) payable\n                       withinCost(teamIndices)\n                       gameOpen(date)\n                       beforeCutoff(date)\n                       external {\n\n    require(msg.value == ENTRY_FEE);\n    require(gameRecords[date].numPlayers < MAX_ENTRIES);\n\n    Entry memory entry;\n    entry.timestamp = currentTime();\n    entry.player = msg.sender;\n    entry.teamsSelected = teamIndices;\n\n    gameRecords[date].entries.push(entry);\n    gameRecords[date].numPlayers++;\n    gameRecords[date].pool += ENTRY_FEE;\n\n    uint entryIndex = gameRecords[date].players.push(msg.sender) - 1;\n    gameRecords[date].entries[entryIndex].entryIndex = entryIndex;\n\n    emit NewEntry(msg.sender, teamIndices);\n  }\n\n\n  // ANALYZING SCORES\n\n  // Register teams (alphabetically) points total for each game\n  function registerTeamScores(uint[] _scores) onlyOwner {\n    allTeamsScores = _scores;\n  }\n\n  function registerTopPlayers(uint _date, uint[] _topPlayersIndices, uint[] _topScores) onlyOwner {\n    gameRecords[_date].topPlayersIndices = _topPlayersIndices;\n    for(uint i = 0; i < _topPlayersIndices.length; i++){\n      address player = gameRecords[_date].entries[_topPlayersIndices[i]].player;\n      gameRecords[_date].topPlayersAddresses.push(player);\n    }\n    gameRecords[_date].topPlayersScores = _topScores;\n  }\n\n  // Allocate winnings to top 5 (or 5+ if ties) players\n  function generateWinners(uint _date) onlyOwner {\n    require(gameRecords[_date].closedTime < currentTime());\n    uint place = 1;\n    uint iterator = 0;\n    uint placeCount = 1;\n    uint currentScore = 1;\n    uint percentage = 0;\n    uint amount = 0;\n\n    while(place <= 5){\n      currentScore = gameRecords[_date].topPlayersScores[iterator];\n      if(gameRecords[_date].topPlayersScores[iterator + 1] == currentScore){\n        placeCount++;\n        iterator++;\n      } else {\n        amount = 0;\n\n        if(placeCount > 1){\n          percentage = 0;\n          for(uint n = place; n <= (place + placeCount);n++){\n            if(n <= 5){\n              percentage += payoutPercentages[n];\n            }\n          }\n          amount = gameRecords[_date].pool / placeCount * percentage / 100;\n        } else {\n          amount = gameRecords[_date].pool * payoutPercentages[place] / 100;\n        }\n\n\n        for(uint i = place - 1; i < (place + placeCount - 1); i++){\n          address winnerAddress = gameRecords[_date].entries[gameRecords[_date].topPlayersIndices[i]].player;\n          gameRecords[_date].winnerAddresses.push(winnerAddress);\n          gameRecords[_date].winnerAmounts.push(amount);\n        }\n\n        iterator++;\n        place += placeCount;\n        placeCount = 1;\n      }\n\n    }\n    allTimeGames.push(gameRecords[_date]);\n  }\n\n  function assignWinnings(uint _date) onlyOwner {\n    address[] storage winners = gameRecords[_date].winnerAddresses;\n    uint[] storage winnerAmounts = gameRecords[_date].winnerAmounts;\n\n    for(uint z = 0; z < winners.length; z++){\n      address currentWinner = winners[z];\n      uint currentRedeemable = availableWinnings[currentWinner];\n      uint newRedeemable = currentRedeemable + winnerAmounts[z];\n      availableWinnings[currentWinner] = newRedeemable;\n      debt += winnerAmounts[z];\n    }\n  }\n\n  function redeem() external returns(bool success) {\n    require(availableWinnings[msg.sender] > 0);\n    uint amount = availableWinnings[msg.sender];\n    availableWinnings[msg.sender] = 0;\n    debt -= amount;\n    msg.sender.transfer(amount);\n    return true;\n  }\n\n  function getAvailableWinnings(address _address) view returns(uint amount){\n    return availableWinnings[_address];\n  }\n\n\n  // OTHER USEFUL FUNCTIONS / TESTING\n\n  function currentTime() view returns (uint _currentTime) {\n    return now;\n  }\n\n  function getPointsToSpend() view returns(uint _POINTS_TO_SPEND) {\n    return POINTS_TO_SPEND;\n  }\n\n  function getGameNumberOfEntries(uint _date) view returns(uint _length){\n    return gameRecords[_date].entries.length;\n  }\n\n  function getCutoffTime(uint _date) view returns(uint cutoff){\n    return gameRecords[_date].closedTime;\n  }\n\n  function getTeamScore(uint _teamIndex) view returns(uint score){\n    return allTeamsScores[_teamIndex];\n  }\n\n  function getAllTeamScores() view returns(uint[] scores){\n    return allTeamsScores;\n  }\n\n  function getAllPlayers(uint _date) view returns(address[] _players){\n    return gameRecords[_date].players;\n  }\n\n  function getTopPlayerScores(uint _date) view returns(uint[] scores){\n    return gameRecords[_date].topPlayersScores;\n  }\n\n  function getTopPlayers(uint _date) view returns(address[] _players){\n    return gameRecords[_date].topPlayersAddresses;\n  }\n\n  function getWinners(uint _date) view returns(uint[] _amounts, address[] _players){\n    return (gameRecords[_date].winnerAmounts, gameRecords[_date].winnerAddresses);\n  }\n\n  function getNumEntries(uint _date) view returns(uint _num){\n    return gameRecords[_date].numPlayers;\n  }\n\n  function getPoolValue(uint _date) view returns(uint amount){\n    return gameRecords[_date].pool;\n  }\n\n  function getBalance() view returns(uint _amount) {\n    return address(this).balance;\n  }\n\n  function getTeamCost(uint _index) constant returns(uint cost){\n    return allTeamsCosts[_index];\n  }\n\n  function getAllTeamCosts() view returns(uint[] costs){\n    return allTeamsCosts;\n  }\n\n  function getPastGameResults(uint _gameIndex) view returns(address[] topPlayers,\n                                                            uint[] topPlayersScores,\n                                                            uint[] winnings){\n    return (allTimeGames[_gameIndex].topPlayersAddresses,\n            allTimeGames[_gameIndex].topPlayersScores,\n            allTimeGames[_gameIndex].winnerAmounts\n    );\n  }\n\n  function getPastGamesLength() view returns(uint _length){\n    return allTimeGames.length;\n  }\n\n  function getEntry(uint _date, uint _index) view returns(\n    address playerAddress,\n    uint[] teamsSelected,\n    uint entryIndex\n  ){\n    return (gameRecords[_date].entries[_index].player,\n            gameRecords[_date].entries[_index].teamsSelected,\n            gameRecords[_date].entries[_index].entryIndex);\n  }\n\n}", "debug": "calldata_Blockgame_4 + calldata_Blockgame_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\nstorage_4: 0x0\ncaller: 0x0\ncalldata_Blockgame_0: 0x5c77582f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x5c77582f`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "_function_0x5c77582f", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 10998, "code": "ntract Blockgame {\n\n  uint public ENTRY_FEE = 0.075 ether;\n  uint public POINTS_TO_SPEND = 150;\n  uint public TEAMS_PER_ENTRY = 6;\n  uint public MAX_ENTRIES = 200;\n\n  address public owner;\n  uint[6] public payoutPercentages;\n  uint public debt;\n\n  uint[] public allTeamsCosts;\n  uint[] public allTeamsScores;\n\n  DailyGame[] public allTimeGames;\n  mapping(uint => bool) public gamesList;\n  mapping(uint => DailyGame) public gameRecords; // uint == dateOfGame\n  mapping(address => uint) public availableWinnings;\n\n  event NewEntry(address indexed player, uint[] selectedTeams);\n\n  struct Entry {\n    uint timestamp;\n    uint[] teamsSelected;\n    address player;\n    uint entryIndex;\n  }\n\n  // Pre and post summary\n  struct DailyGame {\n    uint numPlayers;\n    uint pool;\n    uint date;\n    uint closedTime;\n    uint[] playerScores; // A\n    uint[] topPlayersScores; // B\n    uint[] winnerAmounts; // C\n    address[] players; // A\n    uint[] topPlayersIndices; // B\n    address[] topPlayersAddresses; // B\n    address[] winnerAddresses; // C\n    Entry[] entries;\n  }\n\n  constructor(){\n    owner = msg.sender;\n\n    payoutPercentages[0] = 0;\n    payoutPercentages[1] = 50;\n    payoutPercentages[2] = 16;\n    payoutPercentages[3] = 12;\n    payoutPercentages[4] = 8;\n    payoutPercentages[5] = 4;\n  }\n\n\n  //UTILITIES\n  function() external payable { }\n\n  modifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function changeEntryFee(uint _value) onlyOwner {\n    ENTRY_FEE = _value;\n  }\n\n  function changeMaxEntries(uint _value) onlyOwner {\n    MAX_ENTRIES = _value;\n  }\n\n  //submit alphabetically\n  function changeTeamCosts(uint[] _costs) onlyOwner {\n    allTeamsCosts = _costs;\n  }\n\n  function changeAvailableSpend(uint _value) onlyOwner {\n    POINTS_TO_SPEND = _value;\n  }\n\n  // _closedTime == Unix timestamp\n  function createGame(uint _gameDate, uint _closedTime) onlyOwner {\n    gamesList[_gameDate] = true;\n    gameRecords[_gameDate].closedTime = _closedTime;\n  }\n\n  function withdraw(uint amount) onlyOwner returns(bool) {\n    require(amount <= (address(this).balance - debt));\n    owner.transfer(amount);\n    return true;\n  }\n\n  function selfDestruct() onlyOwner {\n    selfdestruct(owner);\n  }\n\n\n  // SUBMITTING AN ENTRY\n\n  // Verify that game exists\n  modifier gameOpen(uint _gameDate) {\n    require(gamesList[_gameDate] == true);\n    _;\n  }\n\n  // Verify that teams selection is within cost\n  modifier withinCost(uint[] teamIndices) {\n      require(teamIndices.length == 6);\n      uint sum = 0;\n\n      for(uint i = 0;i < 6; i++){\n        uint cost = allTeamsCosts[teamIndices[i]];\n        sum += cost;\n      }\n\n      require(sum <= POINTS_TO_SPEND);\n      _;\n  }\n\n  // Verify that constest hasn't closed\n  modifier beforeCutoff(uint _date) {\n    require(gameRecords[_date].closedTime > currentTime());\n    _;\n  }\n\n  function createEntry(uint date, uint[] teamIndices) payable\n                       withinCost(teamIndices)\n                       gameOpen(date)\n                       beforeCutoff(date)\n                       external {\n\n    require(msg.value == ENTRY_FEE);\n    require(gameRecords[date].numPlayers < MAX_ENTRIES);\n\n    Entry memory entry;\n    entry.timestamp = currentTime();\n    entry.player = msg.sender;\n    entry.teamsSelected = teamIndices;\n\n    gameRecords[date].entries.push(entry);\n    gameRecords[date].numPlayers++;\n    gameRecords[date].pool += ENTRY_FEE;\n\n    uint entryIndex = gameRecords[date].players.push(msg.sender) - 1;\n    gameRecords[date].entries[entryIndex].entryIndex = entryIndex;\n\n    emit NewEntry(msg.sender, teamIndices);\n  }\n\n\n  // ANALYZING SCORES\n\n  // Register teams (alphabetically) points total for each game\n  function registerTeamScores(uint[] _scores) onlyOwner {\n    allTeamsScores = _scores;\n  }\n\n  function registerTopPlayers(uint _date, uint[] _topPlayersIndices, uint[] _topScores) onlyOwner {\n    gameRecords[_date].topPlayersIndices = _topPlayersIndices;\n    for(uint i = 0; i < _topPlayersIndices.length; i++){\n      address player = gameRecords[_date].entries[_topPlayersIndices[i]].player;\n      gameRecords[_date].topPlayersAddresses.push(player);\n    }\n    gameRecords[_date].topPlayersScores = _topScores;\n  }\n\n  // Allocate winnings to top 5 (or 5+ if ties) players\n  function generateWinners(uint _date) onlyOwner {\n    require(gameRecords[_date].closedTime < currentTime());\n    uint place = 1;\n    uint iterator = 0;\n    uint placeCount = 1;\n    uint currentScore = 1;\n    uint percentage = 0;\n    uint amount = 0;\n\n    while(place <= 5){\n      currentScore = gameRecords[_date].topPlayersScores[iterator];\n      if(gameRecords[_date].topPlayersScores[iterator + 1] == currentScore){\n        placeCount++;\n        iterator++;\n      } else {\n        amount = 0;\n\n        if(placeCount > 1){\n          percentage = 0;\n          for(uint n = place; n <= (place + placeCount);n++){\n            if(n <= 5){\n              percentage += payoutPercentages[n];\n            }\n          }\n          amount = gameRecords[_date].pool / placeCount * percentage / 100;\n        } else {\n          amount = gameRecords[_date].pool * payoutPercentages[place] / 100;\n        }\n\n\n        for(uint i = place - 1; i < (place + placeCount - 1); i++){\n          address winnerAddress = gameRecords[_date].entries[gameRecords[_date].topPlayersIndices[i]].player;\n          gameRecords[_date].winnerAddresses.push(winnerAddress);\n          gameRecords[_date].winnerAmounts.push(amount);\n        }\n\n        iterator++;\n        place += placeCount;\n        placeCount = 1;\n      }\n\n    }\n    allTimeGames.push(gameRecords[_date]);\n  }\n\n  function assignWinnings(uint _date) onlyOwner {\n    address[] storage winners = gameRecords[_date].winnerAddresses;\n    uint[] storage winnerAmounts = gameRecords[_date].winnerAmounts;\n\n    for(uint z = 0; z < winners.length; z++){\n      address currentWinner = winners[z];\n      uint currentRedeemable = availableWinnings[currentWinner];\n      uint newRedeemable = currentRedeemable + winnerAmounts[z];\n      availableWinnings[currentWinner] = newRedeemable;\n      debt += winnerAmounts[z];\n    }\n  }\n\n  function redeem() external returns(bool success) {\n    require(availableWinnings[msg.sender] > 0);\n    uint amount = availableWinnings[msg.sender];\n    availableWinnings[msg.sender] = 0;\n    debt -= amount;\n    msg.sender.transfer(amount);\n    return true;\n  }\n\n  function getAvailableWinnings(address _address) view returns(uint amount){\n    return availableWinnings[_address];\n  }\n\n\n  // OTHER USEFUL FUNCTIONS / TESTING\n\n  function currentTime() view returns (uint _currentTime) {\n    return now;\n  }\n\n  function getPointsToSpend() view returns(uint _POINTS_TO_SPEND) {\n    return POINTS_TO_SPEND;\n  }\n\n  function getGameNumberOfEntries(uint _date) view returns(uint _length){\n    return gameRecords[_date].entries.length;\n  }\n\n  function getCutoffTime(uint _date) view returns(uint cutoff){\n    return gameRecords[_date].closedTime;\n  }\n\n  function getTeamScore(uint _teamIndex) view returns(uint score){\n    return allTeamsScores[_teamIndex];\n  }\n\n  function getAllTeamScores() view returns(uint[] scores){\n    return allTeamsScores;\n  }\n\n  function getAllPlayers(uint _date) view returns(address[] _players){\n    return gameRecords[_date].players;\n  }\n\n  function getTopPlayerScores(uint _date) view returns(uint[] scores){\n    return gameRecords[_date].topPlayersScores;\n  }\n\n  function getTopPlayers(uint _date) view returns(address[] _players){\n    return gameRecords[_date].topPlayersAddresses;\n  }\n\n  function getWinners(uint _date) view returns(uint[] _amounts, address[] _players){\n    return (gameRecords[_date].winnerAmounts, gameRecords[_date].winnerAddresses);\n  }\n\n  function getNumEntries(uint _date) view returns(uint _num){\n    return gameRecords[_date].numPlayers;\n  }\n\n  function getPoolValue(uint _date) view returns(uint amount){\n    return gameRecords[_date].pool;\n  }\n\n  function getBalance() view returns(uint _amount) {\n    return address(this).balance;\n  }\n\n  function getTeamCost(uint _index) constant returns(uint cost){\n    return allTeamsCosts[_index];\n  }\n\n  function getAllTeamCosts() view returns(uint[] costs){\n    return allTeamsCosts;\n  }\n\n  function getPastGameResults(uint _gameIndex) view returns(address[] topPlayers,\n                                                            uint[] topPlayersScores,\n                                                            uint[] winnings){\n    return (allTimeGames[_gameIndex].topPlayersAddresses,\n            allTimeGames[_gameIndex].topPlayersScores,\n            allTimeGames[_gameIndex].winnerAmounts\n    );\n  }\n\n  function getPastGamesLength() view returns(uint _length){\n    return allTimeGames.length;\n  }\n\n  function getEntry(uint _date, uint _index) view returns(\n    address playerAddress,\n    uint[] teamsSelected,\n    uint entryIndex\n  ){\n    return (gameRecords[_date].entries[_index].player,\n            gameRecords[_date].entries[_index].teamsSelected,\n            gameRecords[_date].entries[_index].entryIndex);\n  }\n\n}", "debug": "calldata_Blockgame_4 + calldata_Blockgame_32 + 4: 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\nkeccac_8_+_keccac_calldata_Blockgame_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_4: 0x0\ncaller: 0x0\ncalldata_Blockgame_0: 0x657a9c500000000000000000000000000000000000000000000000000000000\ncalldatasize_Blockgame: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x0657a9c5`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Blockgame-0.sol", "function": "_function_0x0657a9c5", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}], "success": true}
