{"error": null, "issues": [{"address": 398, "code": ") {\n            if (_balance >= _amounts[i]) {\n                if (storeBet(_gameIds[i], _teams[i], _amounts[i])) {\n                    _balance -= _amounts[i];\n                }\n            } else {\n                revert(\"Not enough balance sent.\");\n            }\n        }\n\n        if (_balance > 0) {\n            msg.sender.transfer(_balance);\n        }\n\n        playerData[msg.sender].totalBetAmount += (msg.value - _balance);\n        totalBetPool += (msg.value - _balance);\n    }\n\n    function withdrawReward(uint _gameId)\n        public\n        onlyIfGameValid(_gameId)\n        onlyAfterEndTime(_gameId)\n        onlyIfWinnerIsSet(_gameId)\n    {\n        Game storage _game = game[_gameId];\n\n        uint betAmount = _game.book[_game.WINNER][msg.sender];\n        if (betAmount == 0) {\n            return;\n        }\n\n        uint reward = betAmount + (\n            betAmount *\n            (_ga", "debug": "calldata_OraclizeResolverI_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_OraclizeResolverI_0: 0xb3cd07000000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\n", "description": "A possible integer overflow exists in the function `_function_0x0b3cd070`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/0xgame-4.sol", "function": "_function_0x0b3cd070", "lineno": 397, "title": "Integer Overflow ", "type": "Warning"}, {"address": 793, "code": "bool[](_gameIds.length);\n        bool[] memory _hasDescription = new bool[](_gameIds.length);\n\n        for(uint i = 0; i < _gameIds.length; ++i) {\n            _category[i] = game[_gameIds[i]].category;\n            _subcategory[i] = game[_gameIds[i]].subcategory;\n            _hasOddsApi[i] = (bytes(game[_gameIds[i]].oddsApi).length != 0);\n            _hasDescription[i] = (bytes(game[_gameIds[i]].description).length != 0);\n        }\n\n        return (\n            _gameIds,\n            _category,\n            _subcategory,\n            _hasOddsApi,\n            _hasDescription\n        );\n    }\n\n    function getGamesPool(uint[] _gameIds) public view returns(\n        uint[], uint[], uint[], uint[]\n    ) {\n        uint[] memory _oddsOne = new uint[](_gameIds.length);\n        uint[] memory _oddsTwo = new uint[](_gameIds.length);\n        uint[] memory _oddsDraw = new uint[](_gameIds.length);\n\n        for(uint i = 0;", "debug": "calldata_OraclizeResolverI_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_OraclizeResolverI_0: 0x2b96a0a100000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x2b96a0a1`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/0xgame-4.sol", "function": "_function_0x2b96a0a1", "lineno": 308, "title": "Integer Overflow ", "type": "Warning"}, {"address": 975, "code": "bool[](_gameIds.length);\n        bool[] memory _hasDescription = new bool[](_gameIds.length);\n\n        for(uint i = 0; i < _gameIds.length; ++i) {\n            _category[i] = game[_gameIds[i]].category;\n            _subcategory[i] = game[_gameIds[i]].subcategory;\n            _hasOddsApi[i] = (bytes(game[_gameIds[i]].oddsApi).length != 0);\n            _hasDescription[i] = (bytes(game[_gameIds[i]].description).length != 0);\n        }\n\n        return (\n            _gameIds,\n            _category,\n            _subcategory,\n            _hasOddsApi,\n            _hasDescription\n        );\n    }\n\n    function getGamesPool(uint[] _gameIds) public view returns(\n        uint[], uint[], uint[], uint[]\n    ) {\n        uint[] memory _oddsOne = new uint[](_gameIds.length);\n        uint[] memory _oddsTwo = new uint[](_gameIds.length);\n        uint[] memory _oddsDraw = new uint[](_gameIds.length);\n\n        for(uint i = 0;", "debug": "mem_128 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_OraclizeResolverI_0: 0x2b96a0a100000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x2b96a0a1`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/0xgame-4.sol", "function": "_function_0x2b96a0a1", "lineno": 308, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1041, "code": "bool[](_gameIds.length);\n        bool[] memory _hasDescription = new bool[](_gameIds.length);\n\n        for(uint i = 0; i < _gameIds.length; ++i) {\n            _category[i] = game[_gameIds[i]].category;\n            _subcategory[i] = game[_gameIds[i]].subcategory;\n            _hasOddsApi[i] = (bytes(game[_gameIds[i]].oddsApi).length != 0);\n            _hasDescription[i] = (bytes(game[_gameIds[i]].description).length != 0);\n        }\n\n        return (\n            _gameIds,\n            _category,\n            _subcategory,\n            _hasOddsApi,\n            _hasDescription\n        );\n    }\n\n    function getGamesPool(uint[] _gameIds) public view returns(\n        uint[], uint[], uint[], uint[]\n    ) {\n        uint[] memory _oddsOne = new uint[](_gameIds.length);\n        uint[] memory _oddsTwo = new uint[](_gameIds.length);\n        uint[] memory _oddsDraw = new uint[](_gameIds.length);\n\n        for(uint i = 0;", "debug": "mem_160 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x800000000000000000000000000000000000000000000000000000000000000\nmem_128 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x2\ncalldata_OraclizeResolverI_0: 0x2b96a0a100000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x2b96a0a1`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/0xgame-4.sol", "function": "_function_0x2b96a0a1", "lineno": 308, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1107, "code": "bool[](_gameIds.length);\n        bool[] memory _hasDescription = new bool[](_gameIds.length);\n\n        for(uint i = 0; i < _gameIds.length; ++i) {\n            _category[i] = game[_gameIds[i]].category;\n            _subcategory[i] = game[_gameIds[i]].subcategory;\n            _hasOddsApi[i] = (bytes(game[_gameIds[i]].oddsApi).length != 0);\n            _hasDescription[i] = (bytes(game[_gameIds[i]].description).length != 0);\n        }\n\n        return (\n            _gameIds,\n            _category,\n            _subcategory,\n            _hasOddsApi,\n            _hasDescription\n        );\n    }\n\n    function getGamesPool(uint[] _gameIds) public view returns(\n        uint[], uint[], uint[], uint[]\n    ) {\n        uint[] memory _oddsOne = new uint[](_gameIds.length);\n        uint[] memory _oddsTwo = new uint[](_gameIds.length);\n        uint[] memory _oddsDraw = new uint[](_gameIds.length);\n\n        for(uint i = 0;", "debug": "mem_192 +\n64*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x800000000000000000000000000000000000000000000000000000000000000\nmem_160 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x0\nmem_128 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x2\ncalldata_OraclizeResolverI_0: 0x2b96a0a100000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x2b96a0a1`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/0xgame-4.sol", "function": "_function_0x2b96a0a1", "lineno": 308, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1173, "code": "bool[](_gameIds.length);\n        bool[] memory _hasDescription = new bool[](_gameIds.length);\n\n        for(uint i = 0; i < _gameIds.length; ++i) {\n            _category[i] = game[_gameIds[i]].category;\n            _subcategory[i] = game[_gameIds[i]].subcategory;\n            _hasOddsApi[i] = (bytes(game[_gameIds[i]].oddsApi).length != 0);\n            _hasDescription[i] = (bytes(game[_gameIds[i]].description).length != 0);\n        }\n\n        return (\n            _gameIds,\n            _category,\n            _subcategory,\n            _hasOddsApi,\n            _hasDescription\n        );\n    }\n\n    function getGamesPool(uint[] _gameIds) public view returns(\n        uint[], uint[], uint[], uint[]\n    ) {\n        uint[] memory _oddsOne = new uint[](_gameIds.length);\n        uint[] memory _oddsTwo = new uint[](_gameIds.length);\n        uint[] memory _oddsDraw = new uint[](_gameIds.length);\n\n        for(uint i = 0;", "debug": "mem_224 +\n96*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x800000000000000000000000000000000000000000000000000000000000000\nmem_192 +\n64*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x0\nmem_160 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x0\nmem_128 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x1\ncalldata_OraclizeResolverI_0: 0x2b96a0a100000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x2b96a0a1`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/0xgame-4.sol", "function": "_function_0x2b96a0a1", "lineno": 308, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1333, "code": "meIds.length; ++i) {\n            _oddsOne[i] = game[_gameIds[i]].oddsMapping[1];\n            _oddsTwo[i] = game[_gameIds[i]].oddsMapping[2];\n            _oddsDraw[i] = game[_gameIds[i]].oddsMapping[3];\n        }\n\n        return (\n            _gameIds,\n            _oddsOne,\n            _oddsTwo,\n            _oddsDraw\n        );\n    }\n\n    function getGameResolverData(uint _gameId) public view returns(string, address, uint) {\n        Game storage _game = game[_gameId];\n\n        return(\n            _game.oraclizeSource,\n            _game.verityAddress,\n            _game.verityResultIndex\n        );\n    }\n\n    function invalidateGame(uint _gameId)\n        public\n        only", "debug": "calldata_OraclizeResolverI_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_OraclizeResolverI_0: 0x3595819600000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x35958196`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/0xgame-4.sol", "function": "_function_0x35958196", "lineno": 334, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1511, "code": "meIds.length; ++i) {\n            _oddsOne[i] = game[_gameIds[i]].oddsMapping[1];\n            _oddsTwo[i] = game[_gameIds[i]].oddsMapping[2];\n            _oddsDraw[i] = game[_gameIds[i]].oddsMapping[3];\n        }\n\n        return (\n            _gameIds,\n            _oddsOne,\n            _oddsTwo,\n            _oddsDraw\n        );\n    }\n\n    function getGameResolverData(uint _gameId) public view returns(string, address, uint) {\n        Game storage _game = game[_gameId];\n\n        return(\n            _game.oraclizeSource,\n            _game.verityAddress,\n            _game.verityResultIndex\n        );\n    }\n\n    function invalidateGame(uint _gameId)\n        public\n        only", "debug": "mem_128 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_OraclizeResolverI_0: 0x3595819600000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x35958196`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/0xgame-4.sol", "function": "_function_0x35958196", "lineno": 334, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1577, "code": "meIds.length; ++i) {\n            _oddsOne[i] = game[_gameIds[i]].oddsMapping[1];\n            _oddsTwo[i] = game[_gameIds[i]].oddsMapping[2];\n            _oddsDraw[i] = game[_gameIds[i]].oddsMapping[3];\n        }\n\n        return (\n            _gameIds,\n            _oddsOne,\n            _oddsTwo,\n            _oddsDraw\n        );\n    }\n\n    function getGameResolverData(uint _gameId) public view returns(string, address, uint) {\n        Game storage _game = game[_gameId];\n\n        return(\n            _game.oraclizeSource,\n            _game.verityAddress,\n            _game.verityResultIndex\n        );\n    }\n\n    function invalidateGame(uint _gameId)\n        public\n        only", "debug": "mem_160 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x800000000000000000000000000000000000000000000000000000000000000\nmem_128 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x2\ncalldata_OraclizeResolverI_0: 0x3595819600000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x35958196`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/0xgame-4.sol", "function": "_function_0x35958196", "lineno": 334, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1643, "code": "meIds.length; ++i) {\n            _oddsOne[i] = game[_gameIds[i]].oddsMapping[1];\n            _oddsTwo[i] = game[_gameIds[i]].oddsMapping[2];\n            _oddsDraw[i] = game[_gameIds[i]].oddsMapping[3];\n        }\n\n        return (\n            _gameIds,\n            _oddsOne,\n            _oddsTwo,\n            _oddsDraw\n        );\n    }\n\n    function getGameResolverData(uint _gameId) public view returns(string, address, uint) {\n        Game storage _game = game[_gameId];\n\n        return(\n            _game.oraclizeSource,\n            _game.verityAddress,\n            _game.verityResultIndex\n        );\n    }\n\n    function invalidateGame(uint _gameId)\n        public\n        only", "debug": "mem_192 +\n64*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x800000000000000000000000000000000000000000000000000000000000000\nmem_160 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x0\nmem_128 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x1\ncalldata_OraclizeResolverI_0: 0x3595819600000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x35958196`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/0xgame-4.sol", "function": "_function_0x35958196", "lineno": 334, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2230, "code": "eId].teamMapping[draw] = 3;\n    }\n\n    function setLosers(uint _gameId) private returns(string) {\n        Game storage _game = game[_gameId];\n\n        if (_game.WINNER == 1) {\n            _game.loserOne = 2;\n            _game.loserTwo = 3;\n        }", "debug": "calldata_OraclizeResolverI_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_OraclizeResolverI_0: 0x6bbbec8500000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `updateGameMeta(uint256,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/0xgame-4.sol", "function": "updateGameMeta(uint256,string,string)", "lineno": 597, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2405, "code": "[] memory _WINNER = new uint[](_gameIds.length);\n        uint[] memory _betsCloseAt = new uint[](_gameIds.length);\n\n        bool[] memory _drawPossible = new bool[](_gameIds.length);\n\n        for(uint i = 0; i < _gameIds.length; ++i) {\n            _teamOne[i] = strToBytes32(game[_gameIds[i]].teamOne);\n            _teamTwo[i] = strToBytes32(game[_gameIds[i]].teamTwo);\n            _WINNER[i] = game[_gameIds[i]].WINNER;\n            _betsCloseAt[i] = game[_gameIds[i]].betsCloseAt;\n            _drawPossible[i] = game[_gameIds[i]].drawPossible;\n\n        }\n\n        return (\n            _gameIds,\n            _teamOne,\n            _teamTwo,\n            _drawPossible,\n            _WINNER,\n            _betsCloseAt\n        );\n    }\n\n    function getGamesMeta(uint[] _gameIds) public view returns(\n        uint[], bytes32[], bytes32[], bool[], bool[]\n    ) {\n        bytes32[] memory _category = new bytes32[](_gameIds.length);\n        bytes32[] memory _subcategory = new bytes32[](_gameIds.length);\n        bool[] memory _hasOddsAp", "debug": "calldata_OraclizeResolverI_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_OraclizeResolverI_0: 0x6cc5f3ad00000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x6cc5f3ad`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/0xgame-4.sol", "function": "_function_0x6cc5f3ad", "lineno": 279, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5484, "code": "Api = _oddsAp", "debug": "The exception is triggered under the following conditions:\n\ncalldata_OraclizeResolverI_4: 0x0\nstorage_5: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_OraclizeResolverI_0: 0x1200798400000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/0xgame-4.sol", "function": "addBalanceToGame(uint256)", "lineno": 584, "title": "Exception state", "type": "Informational"}, {"address": 5508, "code": "Api = _oddsApi;\n        _game.desc", "debug": "storage_15 +\n1546678032441257452667456735582814959992782782816731922691272282333561699760 +\n23*calldata_OraclizeResolverI_4: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncallvalue: 0x57f25cd000000000000000000000000000000000000000000000000000000000\ncalldata_OraclizeResolverI_4: 0x0\nstorage_5: 0x1\nstorage_0: 0x0\ncaller: 0x0\ncalldata_OraclizeResolverI_0: 0x1200798400000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\n", "description": "A possible integer overflow exists in the function `addBalanceToGame(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/0xgame-4.sol", "function": "addBalanceToGame(uint256)", "lineno": 584, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5957, "code": "  _category,\n    ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_OraclizeResolverI_cpy: 0x0\nstorage_5: 0x0\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_OraclizeResolverI_0: 0x2b96a0a100000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/0xgame-4.sol", "function": "_function_0x2b96a0a1", "lineno": 320, "title": "Exception state", "type": "Informational"}, {"address": 5989, "code": "Ids,\n       ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_OraclizeResolverI_cpy: 0x0\nstorage_5: 0x1\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_OraclizeResolverI_0: 0x2b96a0a100000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\nmem_128 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/0xgame-4.sol", "function": "_function_0x2b96a0a1", "lineno": 319, "title": "Exception state", "type": "Informational"}, {"address": 6083, "code": "          _hasO", "debug": "The exception is triggered under the following conditions:\n\ncalldata_OraclizeResolverI_cpy: 0x0\nmem_128 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0x1\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_OraclizeResolverI_0: 0x2b96a0a100000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\nmem_160 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/0xgame-4.sol", "function": "_function_0x2b96a0a1", "lineno": 322, "title": "Exception state", "type": "Informational"}, {"address": 6201, "code": "    }\n\n    fun", "debug": "The exception is triggered under the following conditions:\n\ncalldata_OraclizeResolverI_cpy: 0x0\nmem_160 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_128 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0x1\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_OraclizeResolverI_0: 0x2b96a0a100000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\nmem_192 +\n64*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/0xgame-4.sol", "function": "_function_0x2b96a0a1", "lineno": 325, "title": "Exception state", "type": "Informational"}, {"address": 6391, "code": "{\n        req", "debug": "The exception is triggered under the following conditions:\n\ncalldata_OraclizeResolverI_4: 0x0\nstorage_5: 0x0\ncalldata_OraclizeResolverI_0: 0x2da5b88e00000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/0xgame-4.sol", "function": "remoteSetWinner(uint256,uint256,uint256)", "lineno": 141, "title": "Exception state", "type": "Informational"}, {"address": 7110, "code": "Name(_gameId, _result)\n    {\n        game[_gameId].WINNER = game[_gameId].teamMapping[_result];\n        emit WinningTeamSet(_gameId, _result);\n        setLosers(_gameId);\n    }\n\n    //  see private method bui", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/temp/0xgame-4.sol", "function": "remoteSetWinner(uint256,uint256,uint256)", "lineno": 499, "title": "Message call to external contract", "type": "Informational"}, {"address": 7110, "code": "Name(_gameId, _result)\n    {\n        game[_gameId].WINNER = game[_gameId].teamMapping[_result];\n        emit WinningTeamSet(_gameId, _result);\n        setLosers(_gameId);\n    }\n\n    //  see private method bui", "debug": "", "description": "A possible transaction order independence vulnerability exists in function remoteSetWinner(uint256,uint256,uint256). The value or direction of the call statement is determined from a tainted storage location", "filename": "/temp/0xgame-4.sol", "function": "remoteSetWinner(uint256,uint256,uint256)", "lineno": 499, "title": "Transaction order dependence", "type": "Warning"}, {"address": 7440, "code": "   //  first element in the nested array represents the team user betted on:\n    //    (teamOne -> 1, teamTwo -> 2, draw", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/temp/0xgame-4.sol", "function": "remoteSetWinner(uint256,uint256,uint256)", "lineno": 507, "title": "Message call to external contract", "type": "Informational"}, {"address": 7440, "code": "   //  first element in the nested array represents the team user betted on:\n    //    (teamOne -> 1, teamTwo -> 2, draw", "debug": "", "description": "A possible transaction order independence vulnerability exists in function remoteSetWinner(uint256,uint256,uint256). The value or direction of the call statement is determined from a tainted storage location", "filename": "/temp/0xgame-4.sol", "function": "remoteSetWinner(uint256,uint256,uint256)", "lineno": 507, "title": "Transaction order dependence", "type": "Warning"}, {"address": 7686, "code": ") public view ret", "debug": "The exception is triggered under the following conditions:\n\ncalldata_OraclizeResolverI_cpy: 0x0\nstorage_5: 0x0\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_OraclizeResolverI_0: 0x3595819600000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/0xgame-4.sol", "function": "_function_0x35958196", "lineno": 348, "title": "Exception state", "type": "Informational"}, {"address": 7736, "code": "a(uint _gam", "debug": "The exception is triggered under the following conditions:\n\ncalldata_OraclizeResolverI_cpy: 0x0\nstorage_5: 0x1\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_OraclizeResolverI_0: 0x3595819600000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\nmem_128 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/0xgame-4.sol", "function": "_function_0x35958196", "lineno": 348, "title": "Exception state", "type": "Informational"}, {"address": 7838, "code": "        Gam", "debug": "The exception is triggered under the following conditions:\n\ncalldata_OraclizeResolverI_cpy: 0x0\nmem_128 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0x1\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_OraclizeResolverI_0: 0x3595819600000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\nmem_160 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/0xgame-4.sol", "function": "_function_0x35958196", "lineno": 349, "title": "Exception state", "type": "Informational"}, {"address": 8288, "code": "quire(\n      ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_OraclizeResolverI_4: 0x0\nstorage_5: 0x0\ncalldata_OraclizeResolverI_0: 0x523a3f0800000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/0xgame-4.sol", "function": "withdrawReward(uint256)", "lineno": 158, "title": "Exception state", "type": "Informational"}, {"address": 8954, "code": "ts[msg.sender][_game.WINNER].withdrawn = true;\n        _game.book[_game.WINNER][msg.sender] = 0;\n\n        emit RewardWithdrawn(_gameId, msg.sen", "debug": "The exception is triggered under the following conditions:\n\ncalldata_OraclizeResolverI_4: 0x0\ntimestamp: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\n1546678032441257452667456735582814959992782782816731922691272282333561699760 +\n23*calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_13 +\n1546678032441257452667456735582814959992782782816731922691272282333561699760 +\n23*calldata_OraclizeResolverI_4: 0x0\nstorage_12 +\n1546678032441257452667456735582814959992782782816731922691272282333561699760 +\n23*calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0x1\ncalldata_OraclizeResolverI_0: 0x523a3f0800000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\nstorage_keccac_storage_0_+\n1546678032441257452667456735582814959992782782816731922691272282333561699760_+\n23*calldata_OraclizeResolverI_4: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/0xgame-4.sol", "function": "withdrawReward(uint256)", "lineno": 441, "title": "Exception state", "type": "Informational"}, {"address": 9605, "code": "\n        _gam", "debug": "The exception is triggered under the following conditions:\n\ncalldata_OraclizeResolverI_4: 0x0\nstorage_5: 0x0\ncalldata_OraclizeResolverI_0: 0x531c267e00000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/0xgame-4.sol", "function": "getGameResolverData(uint256)", "lineno": 365, "title": "Exception state", "type": "Informational"}, {"address": 9862, "code": "\n        publ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_OraclizeResolverI_4: 0x0\nstorage_5: 0x0\ncalldata_OraclizeResolverI_0: 0x5556603600000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/0xgame-4.sol", "function": "getGamePool(uint256)", "lineno": 571, "title": "Exception state", "type": "Informational"}, {"address": 10193, "code": "   if (_game.", "debug": "The exception is triggered under the following conditions:\n\ncalldata_OraclizeResolverI_4: 0x0\nstorage_5: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_OraclizeResolverI_0: 0x6bbbec8500000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/0xgame-4.sol", "function": "updateGameMeta(uint256,string,string)", "lineno": 603, "title": "Exception state", "type": "Informational"}, {"address": 11637, "code": "\n            ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_OraclizeResolverI_4: 0x0\nstorage_5: 0x0\ncalldata_OraclizeResolverI_0: 0xa2f77bcc00000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/0xgame-4.sol", "function": "getGame(uint256)", "lineno": 268, "title": "Exception state", "type": "Informational"}, {"address": 17686, "code": "quire(\n      ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_OraclizeResolverI_4: 0x0\nstorage_5: 0x0\ncalldata_OraclizeResolverI_0: 0x6ffcc71900000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/0xgame-4.sol", "function": "bet(uint256,uint256)", "lineno": 158, "title": "Exception state", "type": "Informational"}, {"address": 18184, "code": "tes = bytes(_team);\n        assembly {\n ", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfffffffffffffffffffffffffffffffffffbdefffffbfffffffeffffdffffffe\nmem_0 +\n224 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_32 + 4: 0x7fff0000000000000000000040000000018318c00002c000000001000010042e\nmem_0 +\n192 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x1\nstorage_12 +\n1546678032441257452667456735582814959992782782816731922691272282333561699760 +\n23*calldata_OraclizeResolverI_cpy: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_OraclizeResolverI_cpy: 0x0\ntimestamp: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0x1\ncallvalue: 0x7fff0000000000000000000040000000018318c00002c000000001000010042e\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_OraclizeResolverI_0: 0xb3cd07000000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\nmem_160 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_128 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n", "description": "A possible integer overflow exists in the function `_function_0x0b3cd070`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/0xgame-4.sol", "function": "_function_0x0b3cd070", "lineno": 646, "title": "Integer Overflow ", "type": "Warning"}, {"address": 18219, "code": "result := mload(add(_teamBytes, 32)", "debug": "storage_keccac_mem_0_+\n192_+\n32*\ncalldata_OraclizeResolverI_4_+_calldata_OraclizeResolverI_4: 0xfffffffffffffffffffffffffffffffffffbdefffffbfffffffeffffdffffffe\nmem_0 +\n224 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_32 + 4: 0x7fff0000000000000000000040000000018318c00002c000000001000010042e\nmem_0 +\n192 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x1\nstorage_12 +\n1546678032441257452667456735582814959992782782816731922691272282333561699760 +\n23*calldata_OraclizeResolverI_cpy: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_OraclizeResolverI_cpy: 0x0\ntimestamp: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0x1\ncallvalue: 0x7fff0000000000000000000040000000018318c00002c000000001000010042e\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_OraclizeResolverI_0: 0xb3cd07000000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\nmem_160 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_128 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n", "description": "A possible integer overflow exists in the function `_function_0x0b3cd070`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/0xgame-4.sol", "function": "_function_0x0b3cd070", "lineno": 648, "title": "Integer Overflow ", "type": "Warning"}, {"address": 18237, "code": "\n    }\n}", "debug": "storage_15 +\n1546678032441257452667456735582814959992782782816731922691272282333561699760 +\n23*calldata_OraclizeResolverI_cpy: 0xfffffffffffffffffffffffffffffffffffbdefffffbfffffffeffffdffffffe\nmem_0 +\n224 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_32 + 4: 0x7fff0000000000000000000040000000018318c00002c000000001000010042e\nmem_0 +\n192 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x1\nstorage_12 +\n1546678032441257452667456735582814959992782782816731922691272282333561699760 +\n23*calldata_OraclizeResolverI_cpy: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_OraclizeResolverI_cpy: 0x0\ntimestamp: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0x1\ncallvalue: 0x7fff0000000000000000000040000000018318c00002c000000001000010042e\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_OraclizeResolverI_0: 0xb3cd07000000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\nmem_160 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_128 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n", "description": "A possible integer overflow exists in the function `_function_0x0b3cd070`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/0xgame-4.sol", "function": "_function_0x0b3cd070", "lineno": 649, "title": "Integer Overflow ", "type": "Warning"}, {"address": 18255, "debug": "mem_0 +\n224 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_32 + 4: 0x7fff0000000000000000000040000000018318c00002c000000001000010042e\nmem_0 +\n192 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x1\nstorage_12 +\n1546678032441257452667456735582814959992782782816731922691272282333561699760 +\n23*calldata_OraclizeResolverI_cpy: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_16 +\n1546678032441257452667456735582814959992782782816731922691272282333561699760 +\n23*calldata_OraclizeResolverI_cpy: 0xfffffffffffffffffffffffffffffffffffbdefffffbfffffffeffffdffffffe\ncalldata_OraclizeResolverI_cpy: 0x0\ntimestamp: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0x1\ncallvalue: 0x7fff0000000000000000000040000000018318c00002c000000001000010042e\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_OraclizeResolverI_0: 0xb3cd07000000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\nmem_160 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_128 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n", "description": "A possible integer overflow exists in the function `_function_0x0b3cd070`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/0xgame-4.sol", "function": "_function_0x0b3cd070", "lineno": 651, "title": "Integer Overflow ", "type": "Warning"}, {"address": 18621, "debug": "storage_0 +\nkeccac_mem_0_+\n192_+\n32*\ncalldata_OraclizeResolverI_4_+_calldata_OraclizeResolverI_4: 0xa463fbff460e9f784558816255f3f7b6c75daabcfa99fc5fb3bfcb3ff2b2fec1\nmem_0 +\n224 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_32 + 4: 0xc5e3fefc57b81fff965cfd7d9405e720c669aaa0c201005bca2c33bffcbafcfd\nmem_0 +\n192 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0x1\nstorage_12 +\n1546678032441257452667456735582814959992782782816731922691272282333561699760 +\n23*calldata_OraclizeResolverI_cpy: 0x9fd7dffffffffafffffefffcfabfd6ffefc67fcf63fffdbfddfdf7dffdbff7df\ncalldata_OraclizeResolverI_cpy: 0x0\ntimestamp: 0x9fd7dffffffffafffffefffcfabfd6ffefc67fcf63fffdbfddfdf7dffdbff7df\nstorage_5: 0x1\ncallvalue: 0xc5e3fefc57b81fff965cfd7d9405e720c669aaa0c201005bca2c33bffcbafcfd\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_OraclizeResolverI_0: 0xb3cd07000000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\nmem_160 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_128 +\n32 +\n32*\ncalldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n", "description": "A possible integer overflow exists in the function `_function_0x0b3cd070`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/0xgame-4.sol", "function": "_function_0x0b3cd070", "lineno": 651, "title": "Integer Overflow ", "type": "Warning"}, {"address": 19600, "code": "Bet0xgameMaster {\n    address public owner;\n    address public resolverAddress;\n\n    mapping(bool => uint) boolMapping;\n\n    string constant draw = \"draw\";\n\n    uint public totalBetPool;\n\n    struct PlayerBet {\n        uint betAmount;\n        uint team;\n        bool withdrawn;\n    }\n\n    struct PlayerData {\n        uint totalBetAmount;\n        uint totalWithdrawn;\n    }\n    mapping(address => PlayerData) playerData;\n\n    struct Game {\n        uint WINNER;\n        uint loserOne;\n        uint loserTwo;\n        string teamOne;\n        string teamTwo;\n\n        string description;\n        string oddsApi;\n\n        string oraclizeSource;\n\n        address verityAddress;\n        uint verityResultIndex;\n\n        bytes32 category;\n        bytes32 subcategory;\n\n        uint betsCloseAt;\n        uint endsAt;\n\n        uint gameId;\n        uint balance;\n        uint totalPool;\n\n        bool drawPossible;\n\n        uint withdrawAfter;\n\n        mapping(uint => mapping(address => uint)) book;\n        mapping(uint => uint) oddsMapping;\n        mapping(string => uint) teamMapping;\n        mapping(address => mapping(uint => PlayerBet)) playerBets;\n    }\n    Game[] game;\n\n    /// Events\n    event PlayerJoined(\n        uint indexed gameId,\n        address indexed playerAddress,\n        uint betAmount,\n        uint team\n    );\n\n    event RewardWithdrawn(\n        uint indexed gameId,\n        address indexed withdrawer,\n        uint withdrawnAmount\n    );\n\n    event WinningTeamSet(\n        uint indexed gameId,\n        string team\n    );\n\n    event NewGame(\n        uint indexed gameId,\n        string teamOne,\n        string teamTwo,\n        uint betsCloseAt\n    );\n\n    event BetFailed(\n        uint indexed gameId,\n        address indexed playerAddress,\n        uint betAmount,\n        uint team\n    );\n\n    event GameInvalidated(\n        uint gameId\n    );\n\n    /// Modifiers\n    modifier onlyOwner {\n        require(\n            msg.sender == owner,\n            \"Only owner can do this\"\n        );\n        _;\n    }\n\n    modifier onlyValidTeamName(uint _gameId, string _team) {\n        require(\n            keccak256(bytes(_team)) == keccak256(bytes(game[_gameId].teamOne)) ||\n            keccak256(bytes(_team)) == keccak256(bytes(game[_gameId].teamTwo)) ||\n            keccak256(bytes(_team)) == keccak256(bytes(draw)),\n            \"Not a valid team name for game.\"\n        );\n        _;\n    }\n\n    modifier onlyValidTeam(uint _team) {\n        require(\n            _team > 0 &&\n            _team <= 3,\n            \"Not a valid team identifier.\"\n        );\n        _;\n    }\n\n    modifier onlyAfterEndTime(uint _gameId) {\n        require(\n            now >= game[_gameId].endsAt,\n            \"Game not ended yet.\"\n        );\n        _;\n    }\n\n    modifier onlyAfterWithdrawTime(uint _gameId) {\n        require(\n            now >= game[_gameId].withdrawAfter,\n            \"Can't withdraw remaining rewards yet.\"\n        );\n        _;\n    }\n\n    modifier onlyIfGameValid(uint _gameId) {\n        require(\n            game[_gameId].betsCloseAt > 0,\n            \"Game not valid\"\n        );\n        _;\n    }\n\n    modifier onlyIfWinnerIsMissing(uint _gameId) {\n        require(\n            game[_gameId].WINNER == 0,\n            \"Winner already set.\"\n        );\n        _;\n    }\n\n    modifier onlyIfWinnerIsSet(uint _gameId) {\n        require(\n            game[_gameId].WINNER != 0,\n            \"Winner not set.\"\n        );\n        _;\n    }\n\n    modifier endsAtAfterBetsCloseAt(uint _betsCloseAt, uint _endsAt) {\n        require(\n            _betsCloseAt < _endsAt,\n            \"Bets can't close after game ends.\"\n        );\n        _;\n    }\n\n    modifier onlyBeforeBetsCloseAt(uint _gameId) {\n        require(\n            now < game[_gameId].betsCloseAt,\n            \"Bets already closed.\"\n        );\n        _;\n    }\n\n    modifier onlyResolver {\n        require(\n            msg.sender == resolverAddress || msg.sender == address(this),\n            \"Only resolver can do this\"\n        );\n        _;\n    }\n\n    /// Constructor\n    constructor(address _resolverAddress) public {\n        owner = msg.sender;\n        resolverAddress = _resolverAddress;\n\n        buildBoolMapping();\n    }\n\n    /// Public functions\n    function createGame(\n        string _teamOne,\n        string _teamTwo,\n        uint _endsAt,\n        uint _betsCloseAt,\n        string _oraclizeSource,\n        address _verityAddress,\n        uint _verityResultIndex,\n        string _oddsApi,\n        bytes32[2] _categories,\n        bool _drawPossible,\n        string _description\n    )\n        public\n        onlyOwner\n        endsAtAfterBetsCloseAt(_betsCloseAt, _endsAt)\n    {\n        Game memory _game;\n\n        _game.gameId = game.length;\n        _game.teamOne = _teamOne;\n        _game.teamTwo = _teamTwo;\n        _game.betsCloseAt = _betsCloseAt;\n        _game.endsAt = _endsAt;\n        _game.oddsApi = _oddsApi;\n        _game.category = _categories[0];\n        _game.subcategory = _categories[1];\n        _game.drawPossible = _drawPossible;\n        _game.description = _description;\n        _game.verityAddress = _verityAddress;\n        _game.verityResultIndex = _verityResultIndex;\n        _game.oraclizeSource = _oraclizeSource;\n\n        _game.withdrawAfter = _endsAt + 1 weeks;\n\n        game.push(_game);\n\n        buildTeamMapping(_game.gameId);\n\n        emit NewGame(\n            _game.gameId,\n            _teamOne,\n            _teamTwo,\n            _betsCloseAt\n        );\n    }\n\n    function getGameLength() public view returns(uint) {\n        return game.length;\n    }\n\n    function getGame(uint _gameId) public view returns(string, string, bool, uint, uint, uint, uint, string, string) {\n        Game storage _game = game[_gameId];\n\n        return (\n            _game.teamOne,\n            _game.teamTwo,\n            _game.drawPossible,\n            _game.WINNER,\n            _game.betsCloseAt,\n            _game.endsAt,\n            _game.totalPool,\n            _game.oddsApi,\n            _game.description\n        );\n    }\n\n    // Returns only first 32 characters of each team's name\n    function getGames(uint[] _gameIds) public view returns(\n        uint[], bytes32[], bytes32[], bool[], uint[], uint[]\n    ) {\n        bytes32[] memory _teamOne = new bytes32[](_gameIds.length);\n        bytes32[] memory _teamTwo = new bytes32[](_gameIds.length);\n        uint[] memory _WINNER = new uint[](_gameIds.length);\n        uint[] memory _betsCloseAt = new uint[](_gameIds.length);\n\n        bool[] memory _drawPossible = new bool[](_gameIds.length);\n\n        for(uint i = 0; i < _gameIds.length; ++i) {\n            _teamOne[i] = strToBytes32(game[_gameIds[i]].teamOne);\n            _teamTwo[i] = strToBytes32(game[_gameIds[i]].teamTwo);\n            _WINNER[i] = game[_gameIds[i]].WINNER;\n            _betsCloseAt[i] = game[_gameIds[i]].betsCloseAt;\n            _drawPossible[i] = game[_gameIds[i]].drawPossible;\n\n        }\n\n        return (\n            _gameIds,\n            _teamOne,\n            _teamTwo,\n            _drawPossible,\n            _WINNER,\n            _betsCloseAt\n        );\n    }\n\n    function getGamesMeta(uint[] _gameIds) public view returns(\n        uint[], bytes32[], bytes32[], bool[], bool[]\n    ) {\n        bytes32[] memory _category = new bytes32[](_gameIds.length);\n        bytes32[] memory _subcategory = new bytes32[](_gameIds.length);\n        bool[] memory _hasOddsApi = new bool[](_gameIds.length);\n        bool[] memory _hasDescription = new bool[](_gameIds.length);\n\n        for(uint i = 0; i < _gameIds.length; ++i) {\n            _category[i] = game[_gameIds[i]].category;\n            _subcategory[i] = game[_gameIds[i]].subcategory;\n            _hasOddsApi[i] = (bytes(game[_gameIds[i]].oddsApi).length != 0);\n            _hasDescription[i] = (bytes(game[_gameIds[i]].description).length != 0);\n        }\n\n        return (\n            _gameIds,\n            _category,\n            _subcategory,\n            _hasOddsApi,\n            _hasDescription\n        );\n    }\n\n    function getGamesPool(uint[] _gameIds) public view returns(\n        uint[], uint[], uint[], uint[]\n    ) {\n        uint[] memory _oddsOne = new uint[](_gameIds.length);\n        uint[] memory _oddsTwo = new uint[](_gameIds.length);\n        uint[] memory _oddsDraw = new uint[](_gameIds.length);\n\n        for(uint i = 0; i < _gameIds.length; ++i) {\n            _oddsOne[i] = game[_gameIds[i]].oddsMapping[1];\n            _oddsTwo[i] = game[_gameIds[i]].oddsMapping[2];\n            _oddsDraw[i] = game[_gameIds[i]].oddsMapping[3];\n        }\n\n        return (\n            _gameIds,\n            _oddsOne,\n            _oddsTwo,\n            _oddsDraw\n        );\n    }\n\n    function getGameResolverData(uint _gameId) public view returns(string, address, uint) {\n        Game storage _game = game[_gameId];\n\n        return(\n            _game.oraclizeSource,\n            _game.verityAddress,\n            _game.verityResultIndex\n        );\n    }\n\n    function invalidateGame(uint _gameId)\n        public\n        onlyOwner\n        onlyIfWinnerIsMissing(_gameId)\n    {\n        Game storage _game = game[_gameId];\n\n        _game.betsCloseAt = 0;\n        _game.endsAt = 0;\n        _game.withdrawAfter = now + 1 weeks;\n\n        emit GameInvalidated(_gameId);\n    }\n\n    function bet(uint _gameId, uint _team)\n        public\n        payable\n    {\n        if (storeBet(_gameId, _team, msg.value)) {\n            playerData[msg.sender].totalBetAmount += msg.value;\n            totalBetPool += msg.value;\n        } else {\n            address(msg.sender).transfer(msg.value);\n        }\n    }\n\n    function multiBet(uint[] _gameIds, uint[] _teams, uint[] _amounts)\n        public\n        payable\n    {\n        require(\n            _gameIds.length == _teams.length &&\n            _gameIds.length == _amounts.length,\n            \"Lengths do not match.\"\n        );\n\n        uint _betsNum = _gameIds.length;\n        uint _balance = msg.value;\n\n        for(uint i = 0; i < _betsNum; ++i) {\n            if (_balance >= _amounts[i]) {\n                if (storeBet(_gameIds[i], _teams[i], _amounts[i])) {\n                    _balance -= _amounts[i];\n                }\n            } else {\n                revert(\"Not enough balance sent.\");\n            }\n        }\n\n        if (_balance > 0) {\n            msg.sender.transfer(_balance);\n        }\n\n        playerData[msg.sender].totalBetAmount += (msg.value - _balance);\n        totalBetPool += (msg.value - _balance);\n    }\n\n    function withdrawReward(uint _gameId)\n        public\n        onlyIfGameValid(_gameId)\n        onlyAfterEndTime(_gameId)\n        onlyIfWinnerIsSet(_gameId)\n    {\n        Game storage _game = game[_gameId];\n\n        uint betAmount = _game.book[_game.WINNER][msg.sender];\n        if (betAmount == 0) {\n            return;\n        }\n\n        uint reward = betAmount + (\n            betAmount *\n            (_game.oddsMapping[_game.loserOne] + _game.oddsMapping[_game.loserTwo]) /\n            _game.oddsMapping[_game.WINNER]\n        );\n\n        if (_game.balance < reward) {\n            revert(\"Not enough balance on game. Contact 0xgame.\");\n        }\n        address(msg.sender).transfer(reward);\n        _game.balance -= reward;\n        playerData[msg.sender].totalWithdrawn += reward;\n\n        _game.playerBets[msg.sender][_game.WINNER].withdrawn = true;\n        _game.book[_game.WINNER][msg.sender] = 0;\n\n        emit RewardWithdrawn(_gameId, msg.sender, reward);\n    }\n\n    function multiWithdrawReward(uint[] _gameIds)\n        public\n    {\n        for (uint i = 0; i < _gameIds.length; ++i) {\n            withdrawReward(_gameIds[i]);\n        }\n    }\n\n    function withdrawInvalidated(uint _gameId)\n        public\n    {\n        Game storage _game = game[_gameId];\n\n        require(\n            _game.betsCloseAt == 0,\n            \"Game not invalidated.\"\n        );\n\n        uint[3][3] memory _playerData = getPlayerDataForGame(_gameId, msg.sender);\n\n        uint _totalBetAmount =\n            _playerData[0][1] +\n            _playerData[1][1] +\n            _playerData[2][1];\n\n        address(msg.sender).transfer(_totalBetAmount);\n\n        _game.playerBets[msg.sender][1].betAmount = 0;\n        _game.playerBets[msg.sender][2].betAmount = 0;\n        _game.playerBets[msg.sender][3].betAmount = 0;\n    }\n\n    function remoteSetWinner(uint _gameId, uint _callback_wei, uint _callback_gas_limit)\n        public\n        onlyAfterEndTime(_gameId)\n        onlyIfWinnerIsMissing(_gameId)\n    {\n        if (game[_gameId].verityAddress == 0x0) {\n            OraclizeResolverI(resolverAddress).remoteSetWinner(\n                _gameId,\n                game[_gameId].oraclizeSource,\n                _callback_wei,\n                _callback_gas_limit\n            );\n        } else {\n            OraclizeResolverI(resolverAddress).eventSetWinner(_gameId, game[_gameId].verityAddress, game[_gameId].verityResultIndex);\n        }\n    }\n\n    function callback(uint _gameId, string _result)\n        external\n        onlyResolver\n        onlyValidTeamName(_gameId, _result)\n    {\n        game[_gameId].WINNER = game[_gameId].teamMapping[_result];\n        emit WinningTeamSet(_gameId, _result);\n        setLosers(_gameId);\n    }\n\n    //  see private method buildTeamMapping, buildBoolMapping\n    //  first element in the nested array represents the team user betted on:\n    //    (teamOne -> 1, teamTwo -> 2, draw -> 3)\n    //  second element in nested array is the bet amount\n    //  third element in nested array represents withdrawal status:\n    //    (false -> 0, true -> 1)\n    //  additionally (applies to first level elements):\n    //    first array holds player data for teamOne\n    //    second array holds player data for teamTwo\n    //    third array holds pleyer data for draw\n    function getPlayerDataForGame(uint _gameId, address _playerAddress) public view returns(uint[3][3]) {\n        Game storage _game = game[_gameId];\n\n        return [\n            [\n                1,\n                _game.playerBets[_playerAddress][1].betAmount,\n                boolMapping[_game.playerBets[_playerAddress][1].withdrawn]\n            ],\n            [\n                2,\n                _game.playerBets[_playerAddress][2].betAmount,\n                boolMapping[_game.playerBets[_playerAddress][2].withdrawn]\n            ],\n            [\n                3,\n                _game.playerBets[_playerAddress][3].betAmount,\n                boolMapping[_game.playerBets[_playerAddress][3].withdrawn]\n            ]\n        ];\n    }\n\n    function getPlayerData(address _playerAddress) public view returns(uint[2]) {\n        return [\n            playerData[_playerAddress].totalBetAmount,\n            playerData[_playerAddress].totalWithdrawn\n        ];\n    }\n\n    function getGamePool(uint _gameId) public view returns(uint[3]) {\n        Game storage _game = game[_gameId];\n\n        return [\n            _game.oddsMapping[1],\n            _game.oddsMapping[2],\n            _game.oddsMapping[3]\n        ];\n    }\n\n    function addBalanceToGame(uint _gameId)\n        public\n        payable\n        onlyOwner\n    {\n        game[_gameId].balance += msg.value;\n    }\n\n    function withdrawRemainingRewards(uint _gameId)\n        public\n        onlyOwner\n        onlyAfterWithdrawTime(_gameId)\n    {\n        address(owner).transfer(game[_gameId].balance);\n    }\n\n    function setResolver(address _resolverAddress)\n        public\n        onlyOwner\n    {\n        resolverAddress = _resolverAddress;\n    }\n\n    function updateGameMeta(uint _gameId, string _oddsApi, string _description)\n        public\n        onlyOwner\n    {\n        Game storage _game = game[_gameId];\n\n        _game.oddsApi = _oddsApi;\n        _game.description = _description;\n    }\n\n    /// Private functions\n    function buildBoolMapping() private {\n        boolMapping[false] = 0;\n        boolMapping[true] = 1;\n    }\n\n    function buildTeamMapping(uint _gameId) internal {\n        game[_gameId].teamMapping[game[_gameId].teamOne] = 1;\n        game[_gameId].teamMapping[game[_gameId].teamTwo] = 2;\n        game[_gameId].teamMapping[draw] = 3;\n    }\n\n    function setLosers(uint _gameId) private returns(string) {\n        Game storage _game = game[_gameId];\n\n        if (_game.WINNER == 1) {\n            _game.loserOne = 2;\n            _game.loserTwo = 3;\n        } else if (_game.WINNER == 2) {\n            _game.loserOne = 1;\n            _game.loserTwo = 3;\n        } else if (_game.WINNER == 3) {\n            _game.loserOne = 1;\n            _game.loserTwo = 2;\n        }\n    }\n\n    function storeBet(uint _gameId, uint _team, uint _amount)\n        private\n        onlyIfGameValid(_gameId)\n        onlyValidTeam(_team)\n        returns(bool)\n    {\n        Game storage _game = game[_gameId];\n\n        if (now > _game.betsCloseAt) {\n            emit BetFailed(_gameId, msg.sender, _amount, _team);\n            return false;\n        }\n\n        _game.book[_team][msg.sender] += _amount;\n        _game.oddsMapping[_team] += _amount;\n        _game.balance += _amount;\n        _game.totalPool += _amount;\n\n        if (_game.playerBets[msg.sender][_team].betAmount == 0) {\n            _game.playerBets[msg.sender][_team] = PlayerBet(_amount, _team, false);\n        } else {\n            _game.playerBets[msg.sender][_team].betAmount += _amount;\n        }\n\n        emit PlayerJoined(_gameId, msg.sender, _amount, _team);\n        return true;\n    }\n\n    function strToBytes32(string _team) internal pure returns(bytes32 result) {\n        bytes memory _teamBytes;\n\n        _teamBytes = bytes(_team);\n        assembly {\n            result := mload(add(_teamBytes, 32))\n        }\n    }\n}", "debug": "calldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_32 + 4: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_OraclizeResolverI_4: 0x0\nstorage_5: 0x1\nstorage_0: 0x0\ncaller: 0x0\ncalldata_OraclizeResolverI_0: 0x6bbbec8500000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `updateGameMeta(uint256,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/0xgame-4.sol", "function": "updateGameMeta(uint256,string,string)", "lineno": 10, "title": "Integer Overflow ", "type": "Warning"}, {"address": 19614, "code": "Bet0xgameMaster {\n    address public owner;\n    address public resolverAddress;\n\n    mapping(bool => uint) boolMapping;\n\n    string constant draw = \"draw\";\n\n    uint public totalBetPool;\n\n    struct PlayerBet {\n        uint betAmount;\n        uint team;\n        bool withdrawn;\n    }\n\n    struct PlayerData {\n        uint totalBetAmount;\n        uint totalWithdrawn;\n    }\n    mapping(address => PlayerData) playerData;\n\n    struct Game {\n        uint WINNER;\n        uint loserOne;\n        uint loserTwo;\n        string teamOne;\n        string teamTwo;\n\n        string description;\n        string oddsApi;\n\n        string oraclizeSource;\n\n        address verityAddress;\n        uint verityResultIndex;\n\n        bytes32 category;\n        bytes32 subcategory;\n\n        uint betsCloseAt;\n        uint endsAt;\n\n        uint gameId;\n        uint balance;\n        uint totalPool;\n\n        bool drawPossible;\n\n        uint withdrawAfter;\n\n        mapping(uint => mapping(address => uint)) book;\n        mapping(uint => uint) oddsMapping;\n        mapping(string => uint) teamMapping;\n        mapping(address => mapping(uint => PlayerBet)) playerBets;\n    }\n    Game[] game;\n\n    /// Events\n    event PlayerJoined(\n        uint indexed gameId,\n        address indexed playerAddress,\n        uint betAmount,\n        uint team\n    );\n\n    event RewardWithdrawn(\n        uint indexed gameId,\n        address indexed withdrawer,\n        uint withdrawnAmount\n    );\n\n    event WinningTeamSet(\n        uint indexed gameId,\n        string team\n    );\n\n    event NewGame(\n        uint indexed gameId,\n        string teamOne,\n        string teamTwo,\n        uint betsCloseAt\n    );\n\n    event BetFailed(\n        uint indexed gameId,\n        address indexed playerAddress,\n        uint betAmount,\n        uint team\n    );\n\n    event GameInvalidated(\n        uint gameId\n    );\n\n    /// Modifiers\n    modifier onlyOwner {\n        require(\n            msg.sender == owner,\n            \"Only owner can do this\"\n        );\n        _;\n    }\n\n    modifier onlyValidTeamName(uint _gameId, string _team) {\n        require(\n            keccak256(bytes(_team)) == keccak256(bytes(game[_gameId].teamOne)) ||\n            keccak256(bytes(_team)) == keccak256(bytes(game[_gameId].teamTwo)) ||\n            keccak256(bytes(_team)) == keccak256(bytes(draw)),\n            \"Not a valid team name for game.\"\n        );\n        _;\n    }\n\n    modifier onlyValidTeam(uint _team) {\n        require(\n            _team > 0 &&\n            _team <= 3,\n            \"Not a valid team identifier.\"\n        );\n        _;\n    }\n\n    modifier onlyAfterEndTime(uint _gameId) {\n        require(\n            now >= game[_gameId].endsAt,\n            \"Game not ended yet.\"\n        );\n        _;\n    }\n\n    modifier onlyAfterWithdrawTime(uint _gameId) {\n        require(\n            now >= game[_gameId].withdrawAfter,\n            \"Can't withdraw remaining rewards yet.\"\n        );\n        _;\n    }\n\n    modifier onlyIfGameValid(uint _gameId) {\n        require(\n            game[_gameId].betsCloseAt > 0,\n            \"Game not valid\"\n        );\n        _;\n    }\n\n    modifier onlyIfWinnerIsMissing(uint _gameId) {\n        require(\n            game[_gameId].WINNER == 0,\n            \"Winner already set.\"\n        );\n        _;\n    }\n\n    modifier onlyIfWinnerIsSet(uint _gameId) {\n        require(\n            game[_gameId].WINNER != 0,\n            \"Winner not set.\"\n        );\n        _;\n    }\n\n    modifier endsAtAfterBetsCloseAt(uint _betsCloseAt, uint _endsAt) {\n        require(\n            _betsCloseAt < _endsAt,\n            \"Bets can't close after game ends.\"\n        );\n        _;\n    }\n\n    modifier onlyBeforeBetsCloseAt(uint _gameId) {\n        require(\n            now < game[_gameId].betsCloseAt,\n            \"Bets already closed.\"\n        );\n        _;\n    }\n\n    modifier onlyResolver {\n        require(\n            msg.sender == resolverAddress || msg.sender == address(this),\n            \"Only resolver can do this\"\n        );\n        _;\n    }\n\n    /// Constructor\n    constructor(address _resolverAddress) public {\n        owner = msg.sender;\n        resolverAddress = _resolverAddress;\n\n        buildBoolMapping();\n    }\n\n    /// Public functions\n    function createGame(\n        string _teamOne,\n        string _teamTwo,\n        uint _endsAt,\n        uint _betsCloseAt,\n        string _oraclizeSource,\n        address _verityAddress,\n        uint _verityResultIndex,\n        string _oddsApi,\n        bytes32[2] _categories,\n        bool _drawPossible,\n        string _description\n    )\n        public\n        onlyOwner\n        endsAtAfterBetsCloseAt(_betsCloseAt, _endsAt)\n    {\n        Game memory _game;\n\n        _game.gameId = game.length;\n        _game.teamOne = _teamOne;\n        _game.teamTwo = _teamTwo;\n        _game.betsCloseAt = _betsCloseAt;\n        _game.endsAt = _endsAt;\n        _game.oddsApi = _oddsApi;\n        _game.category = _categories[0];\n        _game.subcategory = _categories[1];\n        _game.drawPossible = _drawPossible;\n        _game.description = _description;\n        _game.verityAddress = _verityAddress;\n        _game.verityResultIndex = _verityResultIndex;\n        _game.oraclizeSource = _oraclizeSource;\n\n        _game.withdrawAfter = _endsAt + 1 weeks;\n\n        game.push(_game);\n\n        buildTeamMapping(_game.gameId);\n\n        emit NewGame(\n            _game.gameId,\n            _teamOne,\n            _teamTwo,\n            _betsCloseAt\n        );\n    }\n\n    function getGameLength() public view returns(uint) {\n        return game.length;\n    }\n\n    function getGame(uint _gameId) public view returns(string, string, bool, uint, uint, uint, uint, string, string) {\n        Game storage _game = game[_gameId];\n\n        return (\n            _game.teamOne,\n            _game.teamTwo,\n            _game.drawPossible,\n            _game.WINNER,\n            _game.betsCloseAt,\n            _game.endsAt,\n            _game.totalPool,\n            _game.oddsApi,\n            _game.description\n        );\n    }\n\n    // Returns only first 32 characters of each team's name\n    function getGames(uint[] _gameIds) public view returns(\n        uint[], bytes32[], bytes32[], bool[], uint[], uint[]\n    ) {\n        bytes32[] memory _teamOne = new bytes32[](_gameIds.length);\n        bytes32[] memory _teamTwo = new bytes32[](_gameIds.length);\n        uint[] memory _WINNER = new uint[](_gameIds.length);\n        uint[] memory _betsCloseAt = new uint[](_gameIds.length);\n\n        bool[] memory _drawPossible = new bool[](_gameIds.length);\n\n        for(uint i = 0; i < _gameIds.length; ++i) {\n            _teamOne[i] = strToBytes32(game[_gameIds[i]].teamOne);\n            _teamTwo[i] = strToBytes32(game[_gameIds[i]].teamTwo);\n            _WINNER[i] = game[_gameIds[i]].WINNER;\n            _betsCloseAt[i] = game[_gameIds[i]].betsCloseAt;\n            _drawPossible[i] = game[_gameIds[i]].drawPossible;\n\n        }\n\n        return (\n            _gameIds,\n            _teamOne,\n            _teamTwo,\n            _drawPossible,\n            _WINNER,\n            _betsCloseAt\n        );\n    }\n\n    function getGamesMeta(uint[] _gameIds) public view returns(\n        uint[], bytes32[], bytes32[], bool[], bool[]\n    ) {\n        bytes32[] memory _category = new bytes32[](_gameIds.length);\n        bytes32[] memory _subcategory = new bytes32[](_gameIds.length);\n        bool[] memory _hasOddsApi = new bool[](_gameIds.length);\n        bool[] memory _hasDescription = new bool[](_gameIds.length);\n\n        for(uint i = 0; i < _gameIds.length; ++i) {\n            _category[i] = game[_gameIds[i]].category;\n            _subcategory[i] = game[_gameIds[i]].subcategory;\n            _hasOddsApi[i] = (bytes(game[_gameIds[i]].oddsApi).length != 0);\n            _hasDescription[i] = (bytes(game[_gameIds[i]].description).length != 0);\n        }\n\n        return (\n            _gameIds,\n            _category,\n            _subcategory,\n            _hasOddsApi,\n            _hasDescription\n        );\n    }\n\n    function getGamesPool(uint[] _gameIds) public view returns(\n        uint[], uint[], uint[], uint[]\n    ) {\n        uint[] memory _oddsOne = new uint[](_gameIds.length);\n        uint[] memory _oddsTwo = new uint[](_gameIds.length);\n        uint[] memory _oddsDraw = new uint[](_gameIds.length);\n\n        for(uint i = 0; i < _gameIds.length; ++i) {\n            _oddsOne[i] = game[_gameIds[i]].oddsMapping[1];\n            _oddsTwo[i] = game[_gameIds[i]].oddsMapping[2];\n            _oddsDraw[i] = game[_gameIds[i]].oddsMapping[3];\n        }\n\n        return (\n            _gameIds,\n            _oddsOne,\n            _oddsTwo,\n            _oddsDraw\n        );\n    }\n\n    function getGameResolverData(uint _gameId) public view returns(string, address, uint) {\n        Game storage _game = game[_gameId];\n\n        return(\n            _game.oraclizeSource,\n            _game.verityAddress,\n            _game.verityResultIndex\n        );\n    }\n\n    function invalidateGame(uint _gameId)\n        public\n        onlyOwner\n        onlyIfWinnerIsMissing(_gameId)\n    {\n        Game storage _game = game[_gameId];\n\n        _game.betsCloseAt = 0;\n        _game.endsAt = 0;\n        _game.withdrawAfter = now + 1 weeks;\n\n        emit GameInvalidated(_gameId);\n    }\n\n    function bet(uint _gameId, uint _team)\n        public\n        payable\n    {\n        if (storeBet(_gameId, _team, msg.value)) {\n            playerData[msg.sender].totalBetAmount += msg.value;\n            totalBetPool += msg.value;\n        } else {\n            address(msg.sender).transfer(msg.value);\n        }\n    }\n\n    function multiBet(uint[] _gameIds, uint[] _teams, uint[] _amounts)\n        public\n        payable\n    {\n        require(\n            _gameIds.length == _teams.length &&\n            _gameIds.length == _amounts.length,\n            \"Lengths do not match.\"\n        );\n\n        uint _betsNum = _gameIds.length;\n        uint _balance = msg.value;\n\n        for(uint i = 0; i < _betsNum; ++i) {\n            if (_balance >= _amounts[i]) {\n                if (storeBet(_gameIds[i], _teams[i], _amounts[i])) {\n                    _balance -= _amounts[i];\n                }\n            } else {\n                revert(\"Not enough balance sent.\");\n            }\n        }\n\n        if (_balance > 0) {\n            msg.sender.transfer(_balance);\n        }\n\n        playerData[msg.sender].totalBetAmount += (msg.value - _balance);\n        totalBetPool += (msg.value - _balance);\n    }\n\n    function withdrawReward(uint _gameId)\n        public\n        onlyIfGameValid(_gameId)\n        onlyAfterEndTime(_gameId)\n        onlyIfWinnerIsSet(_gameId)\n    {\n        Game storage _game = game[_gameId];\n\n        uint betAmount = _game.book[_game.WINNER][msg.sender];\n        if (betAmount == 0) {\n            return;\n        }\n\n        uint reward = betAmount + (\n            betAmount *\n            (_game.oddsMapping[_game.loserOne] + _game.oddsMapping[_game.loserTwo]) /\n            _game.oddsMapping[_game.WINNER]\n        );\n\n        if (_game.balance < reward) {\n            revert(\"Not enough balance on game. Contact 0xgame.\");\n        }\n        address(msg.sender).transfer(reward);\n        _game.balance -= reward;\n        playerData[msg.sender].totalWithdrawn += reward;\n\n        _game.playerBets[msg.sender][_game.WINNER].withdrawn = true;\n        _game.book[_game.WINNER][msg.sender] = 0;\n\n        emit RewardWithdrawn(_gameId, msg.sender, reward);\n    }\n\n    function multiWithdrawReward(uint[] _gameIds)\n        public\n    {\n        for (uint i = 0; i < _gameIds.length; ++i) {\n            withdrawReward(_gameIds[i]);\n        }\n    }\n\n    function withdrawInvalidated(uint _gameId)\n        public\n    {\n        Game storage _game = game[_gameId];\n\n        require(\n            _game.betsCloseAt == 0,\n            \"Game not invalidated.\"\n        );\n\n        uint[3][3] memory _playerData = getPlayerDataForGame(_gameId, msg.sender);\n\n        uint _totalBetAmount =\n            _playerData[0][1] +\n            _playerData[1][1] +\n            _playerData[2][1];\n\n        address(msg.sender).transfer(_totalBetAmount);\n\n        _game.playerBets[msg.sender][1].betAmount = 0;\n        _game.playerBets[msg.sender][2].betAmount = 0;\n        _game.playerBets[msg.sender][3].betAmount = 0;\n    }\n\n    function remoteSetWinner(uint _gameId, uint _callback_wei, uint _callback_gas_limit)\n        public\n        onlyAfterEndTime(_gameId)\n        onlyIfWinnerIsMissing(_gameId)\n    {\n        if (game[_gameId].verityAddress == 0x0) {\n            OraclizeResolverI(resolverAddress).remoteSetWinner(\n                _gameId,\n                game[_gameId].oraclizeSource,\n                _callback_wei,\n                _callback_gas_limit\n            );\n        } else {\n            OraclizeResolverI(resolverAddress).eventSetWinner(_gameId, game[_gameId].verityAddress, game[_gameId].verityResultIndex);\n        }\n    }\n\n    function callback(uint _gameId, string _result)\n        external\n        onlyResolver\n        onlyValidTeamName(_gameId, _result)\n    {\n        game[_gameId].WINNER = game[_gameId].teamMapping[_result];\n        emit WinningTeamSet(_gameId, _result);\n        setLosers(_gameId);\n    }\n\n    //  see private method buildTeamMapping, buildBoolMapping\n    //  first element in the nested array represents the team user betted on:\n    //    (teamOne -> 1, teamTwo -> 2, draw -> 3)\n    //  second element in nested array is the bet amount\n    //  third element in nested array represents withdrawal status:\n    //    (false -> 0, true -> 1)\n    //  additionally (applies to first level elements):\n    //    first array holds player data for teamOne\n    //    second array holds player data for teamTwo\n    //    third array holds pleyer data for draw\n    function getPlayerDataForGame(uint _gameId, address _playerAddress) public view returns(uint[3][3]) {\n        Game storage _game = game[_gameId];\n\n        return [\n            [\n                1,\n                _game.playerBets[_playerAddress][1].betAmount,\n                boolMapping[_game.playerBets[_playerAddress][1].withdrawn]\n            ],\n            [\n                2,\n                _game.playerBets[_playerAddress][2].betAmount,\n                boolMapping[_game.playerBets[_playerAddress][2].withdrawn]\n            ],\n            [\n                3,\n                _game.playerBets[_playerAddress][3].betAmount,\n                boolMapping[_game.playerBets[_playerAddress][3].withdrawn]\n            ]\n        ];\n    }\n\n    function getPlayerData(address _playerAddress) public view returns(uint[2]) {\n        return [\n            playerData[_playerAddress].totalBetAmount,\n            playerData[_playerAddress].totalWithdrawn\n        ];\n    }\n\n    function getGamePool(uint _gameId) public view returns(uint[3]) {\n        Game storage _game = game[_gameId];\n\n        return [\n            _game.oddsMapping[1],\n            _game.oddsMapping[2],\n            _game.oddsMapping[3]\n        ];\n    }\n\n    function addBalanceToGame(uint _gameId)\n        public\n        payable\n        onlyOwner\n    {\n        game[_gameId].balance += msg.value;\n    }\n\n    function withdrawRemainingRewards(uint _gameId)\n        public\n        onlyOwner\n        onlyAfterWithdrawTime(_gameId)\n    {\n        address(owner).transfer(game[_gameId].balance);\n    }\n\n    function setResolver(address _resolverAddress)\n        public\n        onlyOwner\n    {\n        resolverAddress = _resolverAddress;\n    }\n\n    function updateGameMeta(uint _gameId, string _oddsApi, string _description)\n        public\n        onlyOwner\n    {\n        Game storage _game = game[_gameId];\n\n        _game.oddsApi = _oddsApi;\n        _game.description = _description;\n    }\n\n    /// Private functions\n    function buildBoolMapping() private {\n        boolMapping[false] = 0;\n        boolMapping[true] = 1;\n    }\n\n    function buildTeamMapping(uint _gameId) internal {\n        game[_gameId].teamMapping[game[_gameId].teamOne] = 1;\n        game[_gameId].teamMapping[game[_gameId].teamTwo] = 2;\n        game[_gameId].teamMapping[draw] = 3;\n    }\n\n    function setLosers(uint _gameId) private returns(string) {\n        Game storage _game = game[_gameId];\n\n        if (_game.WINNER == 1) {\n            _game.loserOne = 2;\n            _game.loserTwo = 3;\n        } else if (_game.WINNER == 2) {\n            _game.loserOne = 1;\n            _game.loserTwo = 3;\n        } else if (_game.WINNER == 3) {\n            _game.loserOne = 1;\n            _game.loserTwo = 2;\n        }\n    }\n\n    function storeBet(uint _gameId, uint _team, uint _amount)\n        private\n        onlyIfGameValid(_gameId)\n        onlyValidTeam(_team)\n        returns(bool)\n    {\n        Game storage _game = game[_gameId];\n\n        if (now > _game.betsCloseAt) {\n            emit BetFailed(_gameId, msg.sender, _amount, _team);\n            return false;\n        }\n\n        _game.book[_team][msg.sender] += _amount;\n        _game.oddsMapping[_team] += _amount;\n        _game.balance += _amount;\n        _game.totalPool += _amount;\n\n        if (_game.playerBets[msg.sender][_team].betAmount == 0) {\n            _game.playerBets[msg.sender][_team] = PlayerBet(_amount, _team, false);\n        } else {\n            _game.playerBets[msg.sender][_team].betAmount += _amount;\n        }\n\n        emit PlayerJoined(_gameId, msg.sender, _amount, _team);\n        return true;\n    }\n\n    function strToBytes32(string _team) internal pure returns(bytes32 result) {\n        bytes memory _teamBytes;\n\n        _teamBytes = bytes(_team);\n        assembly {\n            result := mload(add(_teamBytes, 32))\n        }\n    }\n}", "debug": "calldata_OraclizeResolverI_4 + calldata_OraclizeResolverI_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncalldata_OraclizeResolverI_4: 0x0\nstorage_5: 0x1\nstorage_0: 0x0\ncaller: 0x0\ncalldata_OraclizeResolverI_0: 0x6bbbec8500000000000000000000000000000000000000000000000000000000\ncalldatasize_OraclizeResolverI: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `updateGameMeta(uint256,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/0xgame-4.sol", "function": "updateGameMeta(uint256,string,string)", "lineno": 10, "title": "Integer Overflow ", "type": "Warning"}], "success": true}
