{"error": null, "issues": [{"address": 2948, "code": "  \n                address ref = oldSC.userList(re", "debug": "storage_4: 0x57f25cd000000000000000000000000000000000000000000000000000000000\nstorage_keccac_0: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldatasize_ETHRUN: 0x3\nstorage_9247535584797915451057180664748820695544591120644449140157971996739901653371: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Ethrun-0.sol", "function": "fallback", "lineno": 168, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3611, "code": "j <= 8; j++) {\n                        users[user].leve", "debug": "storage_4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_keccac_0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ntimestamp: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\nstorage_9247535584797915451057180664748820695544591120644449140157971996739901653371: 0x0\nstorage_62198580835250178065021801198189918775038380989085965706744441162150748123962: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldatasize_ETHRUN: 0x3\ncallvalue: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Ethrun-0.sol", "function": "fallback", "lineno": 179, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4672, "code": "t l =_level ", "debug": "storage_8: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_38357942052654430511805280289652572966474101887281969759642760585367641502969: 0xaa108000002bd3db7704854d60910b506d8900000000000000000000000051ac\nstorage_3 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_storage_38357942052654430511805280289652572966474101887281969759642760585367641502969,\n_____256): 0x0\nstorage_3: 0x1\nstorage_1: 0x0\nstorage_38357942052654430511805280289652572966474101887281969759642760585367641502968: 0xff00\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncalldatasize_ETHRUN: 0x3\nstorage_9247535584797915451057180664748820695544591120644449140157971996739901653371: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Ethrun-0.sol", "function": "fallback", "lineno": 147, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4897, "code": "w + PERIOD_LENGTH;\n           ", "debug": "mem_288 +\n32*Concat(0, Extract(255, 5, 31 + calldatasize_ETHRUN)) +\n96: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_3 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_storage_38357942052654430511805280289652572966474101887281969759642760585367641502969,\n_____256): 0x0\nstorage_38357942052654430511805280289652572966474101887281969759642760585367641502969: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x1\nstorage_8: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1: 0x0\nstorage_38357942052654430511805280289652572966474101887281969759642760585367641502968: 0xff00\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncalldatasize_ETHRUN: 0x3\nstorage_9247535584797915451057180664748820695544591120644449140157971996739901653371: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Ethrun-0.sol", "function": "fallback", "lineno": 149, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5693, "code": ":= mload(add(bys, 20))\n ", "debug": "The exception is triggered under the following conditions:\n\nstorage_38357942052654430511805280289652572966474101887281969759642760585367641502969: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_8: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1: 0x0\nstorage_38357942052654430511805280289652572966474101887281969759642760585367641502968: 0xff00\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncalldatasize_ETHRUN: 0x3\nstorage_3 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_storage_38357942052654430511805280289652572966474101887281969759642760585367641502969,\n_____256): 0x0\nstorage_3: 0x0\nstorage_9247535584797915451057180664748820695544591120644449140157971996739901653371: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/Ethrun-0.sol", "function": "fallback", "lineno": 286, "title": "Exception state", "type": "Informational"}, {"address": 5749, "code": "          ad", "debug": "The exception is triggered under the following conditions:\n\nstorage_3 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_storage_38357942052654430511805280289652572966474101887281969759642760585367641502969,\n_____256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_38357942052654430511805280289652572966474101887281969759642760585367641502969: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_8: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1: 0x0\nstorage_38357942052654430511805280289652572966474101887281969759642760585367641502968: 0xff00\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncalldatasize_ETHRUN: 0x3\nmem_128 +\n32 +\n32*Concat(0, Extract(255, 5, 31 + calldatasize_ETHRUN)): 0x0\nstorage_9247535584797915451057180664748820695544591120644449140157971996739901653371: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/Ethrun-0.sol", "function": "fallback", "lineno": 286, "title": "Exception state", "type": "Informational"}, {"address": 5885, "debug": "The exception is triggered under the following conditions:\n\nstorage_3 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_storage_38357942052654430511805280289652572966474101887281969759642760585367641502969,\n_____256): 0x1\nstorage_38357942052654430511805280289652572966474101887281969759642760585367641502969: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_128 +\n32 +\n32*Concat(0, Extract(255, 5, 31 + calldatasize_ETHRUN)): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x1\nstorage_8: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1: 0x0\nstorage_38357942052654430511805280289652572966474101887281969759642760585367641502968: 0xff00\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncalldatasize_ETHRUN: 0x3\nstorage_9247535584797915451057180664748820695544591120644449140157971996739901653371: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/Ethrun-0.sol", "function": "fallback", "lineno": 289, "title": "Exception state", "type": "Informational"}, {"address": 12198, "code": " false;\n                freeReferrer = referrals[i]", "debug": "", "description": "In the function `fallback` the following predictable state variables are used to determine Ether recipient:\n- block.timestamp\n", "filename": "/temp/Ethrun-0.sol", "function": "fallback", "lineno": 265, "title": "Dependence on predictable environment variable", "type": "Warning"}, {"address": 12528, "code": "d _referral, uint _level, uint _time);\n    event lostMoneyForLevelEvent(address indexed _user, address indexed _referral, uint _level, uint _time);\n\n    constructor() public {\n        ownerWallet = 0x174b16CC1af3A9E9b0AA89E3d50598b1593c2084;\n\n        LEVEL_PRICE[1] = 0.10 ether;\n        LEVEL_PRICE[2] = 0.20 ether;\n        LEVEL_PRICE[3] = 0.40 ether;\n        LEVEL_PRICE[4] = 0.80 ether;\n        LEVEL_PRICE[5] = 1.60 ether;\n        LEVEL_PRICE[6] = 3.20 ether;\n        LEVEL_PRICE[7] = 6.40 ether;\n        LEVEL_PRICE[8] = 12.80 ether;\n        LEVEL_PRICE[9] = 25.60 ether;\n        LEVEL_PRICE[10] = 51.20 ether;\n\n        UserStruct memory userStruct;\n        currUserID++;\n\n        userStruct = UserStruct({\n            isExist: true,\n            id: currUserID,\n            referrerID: 0,\n            referral: new address[](0)\n        });\n        users[ownerWallet] = userStruct;\n        userList[currUserID] = ownerWallet;\n\n        for(uint i = 1; i <= 10; i++) {\n            users[ownerWallet].levelExpired[i] = 55555555555;\n        }\n    }\n\n    function () external payable {\n        uint level;\n\n        if(msg.value == LEVEL_PRICE[1]) level = 1;\n        else if(msg.value == LEVEL_PRICE[2]) level = 2;\n        else if(msg.value == LEVEL_PRICE[3]) level = 3;\n        else if(msg.value == LEVEL_PRICE[4]) level = 4;\n        else if(msg.value == LEVEL_PRICE[5]) level = 5;\n        else if(msg.value == LEVEL_PRICE[6]) level = 6;\n        else if(msg.value == LEVEL_PRICE[7]) level = 7;\n        else if(msg.value == LEVEL_PRICE[8]) level = 8;\n        else if(msg.value == LEVEL_PRICE[9]) level = 9;\n        else if(msg.value == LEVEL_PRICE[10]) level = 10;\n        else revert('Incorrect Value send');\n\n        if(users[msg.sender].isExist) buyLevel(level);\n        else if(level == 1) {\n            uint refId = 0;\n            address referrer = bytesToAddress(msg.data);\n\n            if(users[referrer].isExist) refId = users[referrer].id;\n            else revert('Incorrect referrer');\n\n            regUser(refId);\n        }\n        else revert('Please buy first level for 0.03 ETH');\n    }\n\n    function regUser(uint _referrerID) public payable {\n        require(address(oldSC) == address(0), 'Initialize not finished');\n        require(!users[msg.sender].isExist, 'User exist');\n        require(_referrerID > 0 && _referrerID <= currUserID, 'Incorrect referrer Id');\n        require(msg.value == LEVEL_PRICE[1], 'Incorrect Value');\n\n        if(users[userList[_referrerID]].referral.length >= REFERRER_1_LEVEL_LIMIT) _referrerID = users[findFreeReferrer(userList[_referrerID])].id;\n\n        UserStruct memory userStruct;\n        currUserID++;\n\n        userStruct = UserStruct({\n            isExist: true,\n            id: currUserID,\n            referrerID: _referrerID,\n            referral: new address[](0)\n        });\n\n        users[msg.sender] = userStruct;\n        userList[currUserID] = msg.sender;\n\n        users[msg.sender].levelExpired[1] = now + PERIOD_LENGTH;\n\n        users[userList[_referrerID]].referral.push(msg.sender);\n\n        payForLevel(1, msg.sender);\n\n        emit regLevelEvent(msg.sender, userList[_referrerID], now);\n    }\n\n    function buyLevel(uint _level) public payable {\n        require(users[msg.sender].isExist, 'User not exist'); \n        require(_level > 0 && _level <= 10, 'Incorrect level');\n\n        if(_level == 1) {\n            require(msg.value == LEVEL_PRICE[1], 'Incorrect Value');\n            users[msg.sender].levelExpired[1] += PERIOD_LENGTH;\n        }\n        else {\n            require(msg.value == LEVEL_PRICE[_level], 'Incorrect Value');\n\n            for(uint l =_level - 1; l > 0; l--) require(users[msg.sender].levelExpired[l] >= now, 'Buy the previous level');\n\n            if(users[msg.sender].levelExpired[_level] == 0) users[msg.sender].levelExpired[_level] = now + PERIOD_LENGTH;\n            else users[msg.sender].levelExpired[_level] += PERIOD_LENGTH;\n        }\n\n        payForLevel(_level, msg.sender);\n\n        emit buyLevelEvent(msg.sender, _level, now);\n    }\n    \n    function syncWithOldSC(uint limit) public {\n        require(address(oldSC) != address(0), 'Initialize closed');\n        require(msg.sender == ownerWallet, 'Access denied');\n\n        for(uint i = 0; i < limit; i++) {\n            address user = oldSC.userList(oldSCUserId);\n            (bool isExist,, uint referrerID) = oldSC.users(user);\n\n            if(isExist) {\n                oldSCUserId++;\n                \n                address ref = oldSC.userList(referrerID);\n\n                if(!users[user].isExist && users[ref].isExist) {\n                    users[user].isExist = true;\n                    users[user].id = ++currUserID;\n                    users[user].referrerID = users[ref].id;\n\n                    userList[currUserID] = user;\n                    users[ref].referral.push(user);\n\n                    for(uint j = 1; j <= 8; j++) {\n                        users[user].levelExpired[j] = oldSC.viewUserLevelExpired(user, j);\n                    }\n\n                    emit regLevelEvent(user, ref, block.timestamp);\n                }\n            }\n            else break;\n        }\n    }\n\n    function syncClose() external {\n        require(address(oldSC) != address(0), 'Initialize already closed');\n        require(msg.sender == ownerWallet, 'Access denied');\n\n        oldSC = ETHRUN(0);\n    }\n\n    function payForLevel(uint _level, address _user) internal {\n        address referer;\n        address referer1;\n        address referer2;\n        address referer3;\n        address referer4;\n\n        if(_level == 1 || _level == 6) {\n            referer = userList[users[_user].referrerID];\n        }\n        else if(_level == 2 || _level == 7) {\n            referer1 = userList[users[_user].referrerID];\n            referer = userList[users[referer1].referrerID];\n        }\n        else if(_level == 3 || _level == 8) {\n            referer1 = userList[users[_user].referrerID];\n            referer2 = userList[users[referer1].referrerID];\n            referer = userList[users[referer2].referrerID];\n        }\n        else if(_level == 4 || _level == 9) {\n            referer1 = userList[users[_user].referrerID];\n            referer2 = userList[users[referer1].referrerID];\n            referer3 = userList[users[referer2].referrerID];\n            referer = userList[users[referer3].referrerID];\n        }\n        else if(_level == 5 || _level == 10) {\n            referer1 = userList[users[_user].referrerID];\n            referer2 = userList[users[referer1].referrerID];\n            referer3 = userList[users[referer2].referrerID];\n            referer4 = userList[users[referer3].referrerID];\n            referer = userList[users[referer4].referrerID];\n        }\n\n        if(!users[referer].isExist) referer = userList[1];\n\n        bool sent = false;\n        if(users[referer].levelExpired[_level] >= now) {\n            sent = address(uint160(referer)).send(LEVEL_PRICE[_level]);\n\n            if (sent) {\n                emit getMoneyForLevelEvent(referer, msg.sender, _level, now);\n            }\n        }\n        if(!sent) {\n            emit lostMoneyForLevelEvent(referer, msg.sender, _level, now);\n\n            payForLevel(_level, referer);\n        }\n    }\n\n    function findFreeReferrer(address _user) public view returns(address) {\n        if(users[_user].referral.length < REFERRER_1_LEVEL_LIMIT) return _user;\n\n        address[] memory referrals = new address[](126);\n        referrals[0] = users[_user].referral[0];\n        referrals[1] = users[_user].referral[1];\n\n        address freeReferrer;\n        bool noFreeReferrer = true;\n\n        for(uint i = 0; i < 126; i++) {\n            if(users[referrals[i]].referral.length == REFERRER_1_LEVEL_LIMIT) {\n                if(i < 62) {\n                    referrals[(i+1)*2] = users[referrals[i]].referral[0];\n                    referrals[(i+1)*2+1] = users[referrals[i]].referral[1];\n                }\n            }\n            else {\n                noFreeReferrer = false;\n                freeReferrer = referrals[i];\n                break;\n            }\n        }\n\n        require(!noFreeReferrer, 'No Free Referrer');\n\n        return freeReferrer;\n    }\n\n    function viewUserReferral(address _user) public view returns(address[] memory) {\n        return users[_user].referral;\n    }\n\n    function viewUserLevelExpired(address _user, uint _level) public view returns(uint) {\n        return users[_user].levelExpired[_level];\n    }\n\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\n        assembly {\n            addr := mload(add(bys, 20))\n        }\n    }\n}", "debug": "mem_mem_288 +\n32*Concat(0, Extract(255, 5, 31 + calldatasize_ETHRUN)) +\n96: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\nstorage_3 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_storage_38357942052654430511805280289652572966474101887281969759642760585367641502969,\n_____256): 0x0\nstorage_38357942052654430511805280289652572966474101887281969759642760585367641502969: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x1\nstorage_8: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1: 0x0\nstorage_38357942052654430511805280289652572966474101887281969759642760585367641502968: 0xff00\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncalldatasize_ETHRUN: 0x3\nstorage_9247535584797915451057180664748820695544591120644449140157971996739901653371: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Ethrun-0.sol", "function": "fallback", "lineno": 44, "title": "Integer Overflow ", "type": "Warning"}, {"address": 12530, "code": "d _referral, uint _level, uint _time);\n    event lostMoneyForLevelEvent(address indexed _user, address indexed _referral, uint _level, uint _time);\n\n    constructor() public {\n        ownerWallet = 0x174b16CC1af3A9E9b0AA89E3d50598b1593c2084;\n\n        LEVEL_PRICE[1] = 0.10 ether;\n        LEVEL_PRICE[2] = 0.20 ether;\n        LEVEL_PRICE[3] = 0.40 ether;\n        LEVEL_PRICE[4] = 0.80 ether;\n        LEVEL_PRICE[5] = 1.60 ether;\n        LEVEL_PRICE[6] = 3.20 ether;\n        LEVEL_PRICE[7] = 6.40 ether;\n        LEVEL_PRICE[8] = 12.80 ether;\n        LEVEL_PRICE[9] = 25.60 ether;\n        LEVEL_PRICE[10] = 51.20 ether;\n\n        UserStruct memory userStruct;\n        currUserID++;\n\n        userStruct = UserStruct({\n            isExist: true,\n            id: currUserID,\n            referrerID: 0,\n            referral: new address[](0)\n        });\n        users[ownerWallet] = userStruct;\n        userList[currUserID] = ownerWallet;\n\n        for(uint i = 1; i <= 10; i++) {\n            users[ownerWallet].levelExpired[i] = 55555555555;\n        }\n    }\n\n    function () external payable {\n        uint level;\n\n        if(msg.value == LEVEL_PRICE[1]) level = 1;\n        else if(msg.value == LEVEL_PRICE[2]) level = 2;\n        else if(msg.value == LEVEL_PRICE[3]) level = 3;\n        else if(msg.value == LEVEL_PRICE[4]) level = 4;\n        else if(msg.value == LEVEL_PRICE[5]) level = 5;\n        else if(msg.value == LEVEL_PRICE[6]) level = 6;\n        else if(msg.value == LEVEL_PRICE[7]) level = 7;\n        else if(msg.value == LEVEL_PRICE[8]) level = 8;\n        else if(msg.value == LEVEL_PRICE[9]) level = 9;\n        else if(msg.value == LEVEL_PRICE[10]) level = 10;\n        else revert('Incorrect Value send');\n\n        if(users[msg.sender].isExist) buyLevel(level);\n        else if(level == 1) {\n            uint refId = 0;\n            address referrer = bytesToAddress(msg.data);\n\n            if(users[referrer].isExist) refId = users[referrer].id;\n            else revert('Incorrect referrer');\n\n            regUser(refId);\n        }\n        else revert('Please buy first level for 0.03 ETH');\n    }\n\n    function regUser(uint _referrerID) public payable {\n        require(address(oldSC) == address(0), 'Initialize not finished');\n        require(!users[msg.sender].isExist, 'User exist');\n        require(_referrerID > 0 && _referrerID <= currUserID, 'Incorrect referrer Id');\n        require(msg.value == LEVEL_PRICE[1], 'Incorrect Value');\n\n        if(users[userList[_referrerID]].referral.length >= REFERRER_1_LEVEL_LIMIT) _referrerID = users[findFreeReferrer(userList[_referrerID])].id;\n\n        UserStruct memory userStruct;\n        currUserID++;\n\n        userStruct = UserStruct({\n            isExist: true,\n            id: currUserID,\n            referrerID: _referrerID,\n            referral: new address[](0)\n        });\n\n        users[msg.sender] = userStruct;\n        userList[currUserID] = msg.sender;\n\n        users[msg.sender].levelExpired[1] = now + PERIOD_LENGTH;\n\n        users[userList[_referrerID]].referral.push(msg.sender);\n\n        payForLevel(1, msg.sender);\n\n        emit regLevelEvent(msg.sender, userList[_referrerID], now);\n    }\n\n    function buyLevel(uint _level) public payable {\n        require(users[msg.sender].isExist, 'User not exist'); \n        require(_level > 0 && _level <= 10, 'Incorrect level');\n\n        if(_level == 1) {\n            require(msg.value == LEVEL_PRICE[1], 'Incorrect Value');\n            users[msg.sender].levelExpired[1] += PERIOD_LENGTH;\n        }\n        else {\n            require(msg.value == LEVEL_PRICE[_level], 'Incorrect Value');\n\n            for(uint l =_level - 1; l > 0; l--) require(users[msg.sender].levelExpired[l] >= now, 'Buy the previous level');\n\n            if(users[msg.sender].levelExpired[_level] == 0) users[msg.sender].levelExpired[_level] = now + PERIOD_LENGTH;\n            else users[msg.sender].levelExpired[_level] += PERIOD_LENGTH;\n        }\n\n        payForLevel(_level, msg.sender);\n\n        emit buyLevelEvent(msg.sender, _level, now);\n    }\n    \n    function syncWithOldSC(uint limit) public {\n        require(address(oldSC) != address(0), 'Initialize closed');\n        require(msg.sender == ownerWallet, 'Access denied');\n\n        for(uint i = 0; i < limit; i++) {\n            address user = oldSC.userList(oldSCUserId);\n            (bool isExist,, uint referrerID) = oldSC.users(user);\n\n            if(isExist) {\n                oldSCUserId++;\n                \n                address ref = oldSC.userList(referrerID);\n\n                if(!users[user].isExist && users[ref].isExist) {\n                    users[user].isExist = true;\n                    users[user].id = ++currUserID;\n                    users[user].referrerID = users[ref].id;\n\n                    userList[currUserID] = user;\n                    users[ref].referral.push(user);\n\n                    for(uint j = 1; j <= 8; j++) {\n                        users[user].levelExpired[j] = oldSC.viewUserLevelExpired(user, j);\n                    }\n\n                    emit regLevelEvent(user, ref, block.timestamp);\n                }\n            }\n            else break;\n        }\n    }\n\n    function syncClose() external {\n        require(address(oldSC) != address(0), 'Initialize already closed');\n        require(msg.sender == ownerWallet, 'Access denied');\n\n        oldSC = ETHRUN(0);\n    }\n\n    function payForLevel(uint _level, address _user) internal {\n        address referer;\n        address referer1;\n        address referer2;\n        address referer3;\n        address referer4;\n\n        if(_level == 1 || _level == 6) {\n            referer = userList[users[_user].referrerID];\n        }\n        else if(_level == 2 || _level == 7) {\n            referer1 = userList[users[_user].referrerID];\n            referer = userList[users[referer1].referrerID];\n        }\n        else if(_level == 3 || _level == 8) {\n            referer1 = userList[users[_user].referrerID];\n            referer2 = userList[users[referer1].referrerID];\n            referer = userList[users[referer2].referrerID];\n        }\n        else if(_level == 4 || _level == 9) {\n            referer1 = userList[users[_user].referrerID];\n            referer2 = userList[users[referer1].referrerID];\n            referer3 = userList[users[referer2].referrerID];\n            referer = userList[users[referer3].referrerID];\n        }\n        else if(_level == 5 || _level == 10) {\n            referer1 = userList[users[_user].referrerID];\n            referer2 = userList[users[referer1].referrerID];\n            referer3 = userList[users[referer2].referrerID];\n            referer4 = userList[users[referer3].referrerID];\n            referer = userList[users[referer4].referrerID];\n        }\n\n        if(!users[referer].isExist) referer = userList[1];\n\n        bool sent = false;\n        if(users[referer].levelExpired[_level] >= now) {\n            sent = address(uint160(referer)).send(LEVEL_PRICE[_level]);\n\n            if (sent) {\n                emit getMoneyForLevelEvent(referer, msg.sender, _level, now);\n            }\n        }\n        if(!sent) {\n            emit lostMoneyForLevelEvent(referer, msg.sender, _level, now);\n\n            payForLevel(_level, referer);\n        }\n    }\n\n    function findFreeReferrer(address _user) public view returns(address) {\n        if(users[_user].referral.length < REFERRER_1_LEVEL_LIMIT) return _user;\n\n        address[] memory referrals = new address[](126);\n        referrals[0] = users[_user].referral[0];\n        referrals[1] = users[_user].referral[1];\n\n        address freeReferrer;\n        bool noFreeReferrer = true;\n\n        for(uint i = 0; i < 126; i++) {\n            if(users[referrals[i]].referral.length == REFERRER_1_LEVEL_LIMIT) {\n                if(i < 62) {\n                    referrals[(i+1)*2] = users[referrals[i]].referral[0];\n                    referrals[(i+1)*2+1] = users[referrals[i]].referral[1];\n                }\n            }\n            else {\n                noFreeReferrer = false;\n                freeReferrer = referrals[i];\n                break;\n            }\n        }\n\n        require(!noFreeReferrer, 'No Free Referrer');\n\n        return freeReferrer;\n    }\n\n    function viewUserReferral(address _user) public view returns(address[] memory) {\n        return users[_user].referral;\n    }\n\n    function viewUserLevelExpired(address _user, uint _level) public view returns(uint) {\n        return users[_user].levelExpired[_level];\n    }\n\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\n        assembly {\n            addr := mload(add(bys, 20))\n        }\n    }\n}", "debug": "mem_mem_288 +\n32*Concat(0, Extract(255, 5, 31 + calldatasize_ETHRUN)) +\n96: 0x7f6fc32c410701432cb30000000000000000000dfffffff3fc0000000000000\nmem_288 +\n32*Concat(0, Extract(255, 5, 31 + calldatasize_ETHRUN)) +\n96: 0x7fffffffffffffffffffffffffffffffffffffdaffffffffbfff7fffffffffe0\nstorage_3 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_storage_38357942052654430511805280289652572966474101887281969759642760585367641502969,\n_____256): 0x0\nstorage_38357942052654430511805280289652572966474101887281969759642760585367641502969: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x1\nstorage_8: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1: 0x0\nstorage_38357942052654430511805280289652572966474101887281969759642760585367641502968: 0xff00\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncalldatasize_ETHRUN: 0x3\nstorage_9247535584797915451057180664748820695544591120644449140157971996739901653371: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/Ethrun-0.sol", "function": "fallback", "lineno": 44, "title": "Integer Overflow ", "type": "Warning"}], "success": true}
