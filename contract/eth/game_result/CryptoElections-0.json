{"error": null, "issues": [{"address": 345, "code": "yCreator()\n    {\n        countriesCities[countryId] = _cities;\n        for (uint i = 0;i<_cities.length;i++) {\n            citiesCountries[_cities[i]] = countryId;\n\n        }\n    }\n    function setMaintenanceMode(bool _maintenance) public\n    onlyCreator()\n   ", "debug": "calldata_CryptoElections_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_CryptoElections_0: 0x36eccee00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoElections: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x036eccee`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/CryptoElections-0.sol", "function": "_function_0x036eccee", "lineno": 74, "title": "Integer Overflow ", "type": "Warning"}, {"address": 522, "code": ".picture = _picture;\n    }\n\n\n    function withdraw() public {\n        if (maintenance) revert();\n        uint amount = userPendingWithdrawals[msg.s", "debug": "calldata_CryptoElections_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_CryptoElections_0: 0x788f69c00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoElections: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setCityPicture(uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/CryptoElections-0.sol", "function": "setCityPicture(uint256,string)", "lineno": 121, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1017, "code": "ies[user].length; i++) {\n            if (userCities[user][i]==0) {\n                userCities[user][i] = cit", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_CryptoElections_4: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_CryptoElections_0: 0xbcd069400000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoElections: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getUserCities(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/CryptoElections-0.sol", "function": "getUserCities(address)", "lineno": 239, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1258, "code": "untry(uint countryId)    private returns (bool) {\n        uint  totalPopulation;\n        uint  controlledPopulation;\n\n        uint  popu", "debug": "calldata_CryptoElections_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_CryptoElections_0: 0x1c5d9faa00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoElections: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setNickname(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/CryptoElections-0.sol", "function": "setNickname(string)", "lineno": 163, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1373, "code": "{\n        countries[countryId].slogan = slogan;\n    }\n\n    function setCountryPicture(uint countryId,string _flagUrl) public\n    onlyCountryOwner(countryId)", "debug": "calldata_CryptoElections_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_CryptoElections_0: 0x1fa62fb700000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoElections: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setCountrySlogan(uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/CryptoElections-0.sol", "function": "setCountrySlogan(uint256,string)", "lineno": 102, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1488, "code": "yId].slogan = _slogan;\n    }\n\n    function setCityPicture(uint256 cityId,string _picture) public\n    onlyCityOwner(cityId)\n    {\n        cities", "debug": "calldata_CryptoElections_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_CryptoElections_0: 0x2acefd0f00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoElections: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setCitySlogan(uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/CryptoElections-0.sol", "function": "setCitySlogan(uint256,string)", "lineno": 115, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1714, "code": "\n    {\n\n        for (uint i = 0;i<_cities.length;i++) {\n\n            cityPopulation[_cities[i]] = _populations[i];\n        }\n    }\n\n    function setCountrySlogan(uint countryId,string slogan) public\n    onlyCountryOwner(country", "debug": "calldata_CryptoElections_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_CryptoElections_0: 0x436a81d700000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoElections: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x436a81d7`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/CryptoElections-0.sol", "function": "_function_0x436a81d7", "lineno": 91, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3710, "code": "      userCities[user][", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_CryptoElections_4: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\ncalldata_CryptoElections_0: 0xbcd069400000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoElections: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getUserCities(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/CryptoElections-0.sol", "function": "getUserCities(address)", "lineno": 241, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3712, "code": "      userCities[user][", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_CryptoElections_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_CryptoElections_0: 0xbcd069400000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoElections: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getUserCities(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/CryptoElections-0.sol", "function": "getUserCities(address)", "lineno": 241, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4742, "code": "iesCities ;\n    mapping(uint =>  uint) public c", "debug": "The exception is triggered under the following conditions:\n\ncalldata_CryptoElections_32 + 4: 0x0\nstorage_keccac_calldata_CryptoElections_4: 0x0\ncalldata_CryptoElections_0: 0x3e9bf56d00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoElections: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/CryptoElections-0.sol", "function": "_function_0x3e9bf56d", "lineno": 39, "title": "Exception state", "type": "Informational"}, {"address": 5033, "code": "ublic\n    onlyC", "debug": "The exception is triggered under the following conditions:\n\ncalldata_CryptoElections_4 + calldata_CryptoElections_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_CryptoElections_0: 0x436a81d700000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoElections: 0x4\nmem_128 +\n32 +\n32*calldata_CryptoElections_4 + calldata_CryptoElections_4: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/CryptoElections-0.sol", "function": "_function_0x436a81d7", "lineno": 100, "title": "Exception state", "type": "Informational"}, {"address": 5310, "code": "s;\n    mapping(address => uint) public userP", "debug": "The exception is triggered under the following conditions:\n\ncalldata_CryptoElections_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\ncalldata_CryptoElections_4: 0x0\ncalldata_CryptoElections_0: 0x61a9631400000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoElections: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/CryptoElections-0.sol", "function": "_function_0x61a96314", "lineno": 44, "title": "Exception state", "type": "Informational"}, {"address": 9772, "code": "ntract CryptoElections {\n\n    /* Define variable owner of the type address */\n    address creator;\n\n    modifier onlyCreator() {\n        require(msg.sender == creator);\n        _;\n    }\n\n    modifier onlyCountryOwner(uint256 countryId) {\n        require(countries[countryId].president==msg.sender);\n        _;\n    }\n    modifier onlyCityOwner(uint cityId) {\n        require(cities[cityId].mayor==msg.sender);\n        _;\n    }\n\n    struct Country {\n        address president;\n        string slogan;\n        string flagUrl;\n    }\n    struct City {\n        address mayor;\n        string slogan;\n        string picture;\n        uint purchases;\n    }\n    bool maintenance=false;\n    event withdrawalEvent(address user,uint value);\n    event pendingWithdrawalEvent(address user,uint value);\n    event assignCountryEvent(address user,uint countryId);\n    event buyCityEvent(address user,uint cityId);\n    mapping(uint => Country) public countries ;\n    mapping(uint =>  uint[]) public countriesCities ;\n    mapping(uint =>  uint) public citiesCountries ;\n\n    mapping(uint =>  uint) public cityPopulation ;\n    mapping(uint => City) public cities;\n    mapping(address => uint[]) public userCities;\n    mapping(address => uint) public userPendingWithdrawals;\n    mapping(address => string) public userNicknames;\n\n    function CryptoElections() public {\n        creator = msg.sender;\n    }\n\n    function () public payable {\n        revert();\n    }\n\n    /* This function is executed at initialization and sets the owner of the contract */\n    /* Function to recover the funds on the contract */\n    function kill() public\n    onlyCreator()\n    {\n        selfdestruct(creator);\n    }\n\n    function transfer(address newCreator) public\n    onlyCreator()\n    {\n        creator=newCreator;\n    }\n\n\n\n    // Contract initialisation\n    function addCountryCities(uint countryId,uint[] _cities)  public\n    onlyCreator()\n    {\n        countriesCities[countryId] = _cities;\n        for (uint i = 0;i<_cities.length;i++) {\n            citiesCountries[_cities[i]] = countryId;\n\n        }\n    }\n    function setMaintenanceMode(bool _maintenance) public\n    onlyCreator()\n    {\n        maintenance=_maintenance;\n    }\n\n\n    // Contract initialisation\n    function addCitiesPopulation(uint[] _cities,uint[]_populations)  public\n    onlyCreator()\n    {\n\n        for (uint i = 0;i<_cities.length;i++) {\n\n            cityPopulation[_cities[i]] = _populations[i];\n        }\n    }\n\n    function setCountrySlogan(uint countryId,string slogan) public\n    onlyCountryOwner(countryId)\n    {\n        countries[countryId].slogan = slogan;\n    }\n\n    function setCountryPicture(uint countryId,string _flagUrl) public\n    onlyCountryOwner(countryId)\n    {\n        countries[countryId].flagUrl = _flagUrl;\n    }\n\n    function setCitySlogan(uint256 cityId,string _slogan) public\n    onlyCityOwner(cityId)\n    {\n        cities[cityId].slogan = _slogan;\n    }\n\n    function setCityPicture(uint256 cityId,string _picture) public\n    onlyCityOwner(cityId)\n    {\n        cities[cityId].picture = _picture;\n    }\n\n\n    function withdraw() public {\n        if (maintenance) revert();\n        uint amount = userPendingWithdrawals[msg.sender];\n        // Remember to zero the pending refund before\n        // sending to prevent re-entrancy attacks\n\n        userPendingWithdrawals[msg.sender] = 0;\n        withdrawalEvent(msg.sender,amount);\n        msg.sender.transfer(amount);\n    }\n\n    function getPrices(uint purchases) public pure returns (uint[4]) {\n        uint price = 20000000000000000; // 16x0\n        uint pricePrev = 20000000000000000;\n        uint systemCommission = 19000000000000000;\n        uint presidentCommission = 1000000000000000;\n        uint ownerCommission;\n\n        for (uint i = 1;i<=purchases;i++) {\n            if (i<=7)\n                price = price*2;\n            else\n                price = (price*12)/10;\n\n            presidentCommission = price/100;\n            systemCommission = (price-pricePrev)*2/10;\n            ownerCommission = price-presidentCommission-systemCommission;\n\n            pricePrev = price;\n        }\n        return [price,systemCommission,presidentCommission,ownerCommission];\n    }\n\n    function setNickname(string nickname) public {\n        if (maintenance) revert();\n        userNicknames[msg.sender] = nickname;\n    }\n\n    function _assignCountry(uint countryId)    private returns (bool) {\n        uint  totalPopulation;\n        uint  controlledPopulation;\n\n        uint  population;\n        for (uint i = 0;i<countriesCities[countryId].length;i++) {\n            population = cityPopulation[countriesCities[countryId][i]];\n            if (cities[countriesCities[countryId][i]].mayor==msg.sender) {\n                controlledPopulation += population;\n            }\n            totalPopulation += population;\n        }\n        if (controlledPopulation*2>(totalPopulation)) {\n            countries[countryId].president = msg.sender;\n            assignCountryEvent(msg.sender,countryId);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function buyCity(uint cityId) payable  public  {\n        if (maintenance) revert();\n        uint[4] memory prices = getPrices(cities[cityId].purchases);\n\n        if (cities[cityId].mayor==msg.sender) {\n            revert();\n        }\n        if (cityPopulation[cityId]==0) {\n            revert();\n        }\n\n        if ( msg.value+userPendingWithdrawals[msg.sender]>=prices[0]) {\n            // use user limit\n            userPendingWithdrawals[msg.sender] = userPendingWithdrawals[msg.sender]+msg.value-prices[0];\n            pendingWithdrawalEvent(msg.sender,userPendingWithdrawals[msg.sender]+msg.value-prices[0]);\n\n            cities[cityId].purchases = cities[cityId].purchases+1;\n\n            userPendingWithdrawals[cities[cityId].mayor] += prices[3];\n            pendingWithdrawalEvent(cities[cityId].mayor,prices[3]);\n\n            if (countries[citiesCountries[cityId]].president==0) {\n                userPendingWithdrawals[creator] += prices[2];\n                pendingWithdrawalEvent(creator,prices[2]);\n\n            } else {\n                userPendingWithdrawals[countries[citiesCountries[cityId]].president] += prices[2];\n                pendingWithdrawalEvent(countries[citiesCountries[cityId]].president,prices[2]);\n            }\n            // change mayor\n            if (cities[cityId].mayor>0) {\n                _removeUserCity(cities[cityId].mayor,cityId);\n            }\n\n\n\n            cities[cityId].mayor = msg.sender;\n            _addUserCity(msg.sender,cityId);\n\n            _assignCountry(citiesCountries[cityId]);\n\n            //send money to creator\n            creator.transfer(prices[1]);\n            buyCityEvent(msg.sender,cityId);\n\n        } else {\n            revert();\n        }\n    }\n    function getUserCities(address user) public view returns (uint[]) {\n        return userCities[user];\n    }\n\n    function _addUserCity(address user,uint cityId) private {\n        bool added = false;\n        for (uint i = 0; i<userCities[user].length; i++) {\n            if (userCities[user][i]==0) {\n                userCities[user][i] = cityId;\n                added = true;\n                break;\n            }\n        }\n        if (!added)\n            userCities[user].push(cityId);\n    }\n\n    function _removeUserCity(address user,uint cityId) private {\n        for (uint i = 0; i<userCities[user].length; i++) {\n            if (userCities[user][i]==cityId) {\n                delete userCities[user][i];\n            }\n        }\n    }\n\n}", "debug": "keccac_keccac_calldata_CryptoElections_4: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_keccac_calldata_CryptoElections_4: 0x57f25cd000000000000000000000000000000000000000000000000000000000\nstorage_0: 0x0\ncaller: 0x0\ncalldata_CryptoElections_0: 0x36eccee00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoElections: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x036eccee`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/CryptoElections-0.sol", "function": "_function_0x036eccee", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9783, "code": "ntract CryptoElections {\n\n    /* Define variable owner of the type address */\n    address creator;\n\n    modifier onlyCreator() {\n        require(msg.sender == creator);\n        _;\n    }\n\n    modifier onlyCountryOwner(uint256 countryId) {\n        require(countries[countryId].president==msg.sender);\n        _;\n    }\n    modifier onlyCityOwner(uint cityId) {\n        require(cities[cityId].mayor==msg.sender);\n        _;\n    }\n\n    struct Country {\n        address president;\n        string slogan;\n        string flagUrl;\n    }\n    struct City {\n        address mayor;\n        string slogan;\n        string picture;\n        uint purchases;\n    }\n    bool maintenance=false;\n    event withdrawalEvent(address user,uint value);\n    event pendingWithdrawalEvent(address user,uint value);\n    event assignCountryEvent(address user,uint countryId);\n    event buyCityEvent(address user,uint cityId);\n    mapping(uint => Country) public countries ;\n    mapping(uint =>  uint[]) public countriesCities ;\n    mapping(uint =>  uint) public citiesCountries ;\n\n    mapping(uint =>  uint) public cityPopulation ;\n    mapping(uint => City) public cities;\n    mapping(address => uint[]) public userCities;\n    mapping(address => uint) public userPendingWithdrawals;\n    mapping(address => string) public userNicknames;\n\n    function CryptoElections() public {\n        creator = msg.sender;\n    }\n\n    function () public payable {\n        revert();\n    }\n\n    /* This function is executed at initialization and sets the owner of the contract */\n    /* Function to recover the funds on the contract */\n    function kill() public\n    onlyCreator()\n    {\n        selfdestruct(creator);\n    }\n\n    function transfer(address newCreator) public\n    onlyCreator()\n    {\n        creator=newCreator;\n    }\n\n\n\n    // Contract initialisation\n    function addCountryCities(uint countryId,uint[] _cities)  public\n    onlyCreator()\n    {\n        countriesCities[countryId] = _cities;\n        for (uint i = 0;i<_cities.length;i++) {\n            citiesCountries[_cities[i]] = countryId;\n\n        }\n    }\n    function setMaintenanceMode(bool _maintenance) public\n    onlyCreator()\n    {\n        maintenance=_maintenance;\n    }\n\n\n    // Contract initialisation\n    function addCitiesPopulation(uint[] _cities,uint[]_populations)  public\n    onlyCreator()\n    {\n\n        for (uint i = 0;i<_cities.length;i++) {\n\n            cityPopulation[_cities[i]] = _populations[i];\n        }\n    }\n\n    function setCountrySlogan(uint countryId,string slogan) public\n    onlyCountryOwner(countryId)\n    {\n        countries[countryId].slogan = slogan;\n    }\n\n    function setCountryPicture(uint countryId,string _flagUrl) public\n    onlyCountryOwner(countryId)\n    {\n        countries[countryId].flagUrl = _flagUrl;\n    }\n\n    function setCitySlogan(uint256 cityId,string _slogan) public\n    onlyCityOwner(cityId)\n    {\n        cities[cityId].slogan = _slogan;\n    }\n\n    function setCityPicture(uint256 cityId,string _picture) public\n    onlyCityOwner(cityId)\n    {\n        cities[cityId].picture = _picture;\n    }\n\n\n    function withdraw() public {\n        if (maintenance) revert();\n        uint amount = userPendingWithdrawals[msg.sender];\n        // Remember to zero the pending refund before\n        // sending to prevent re-entrancy attacks\n\n        userPendingWithdrawals[msg.sender] = 0;\n        withdrawalEvent(msg.sender,amount);\n        msg.sender.transfer(amount);\n    }\n\n    function getPrices(uint purchases) public pure returns (uint[4]) {\n        uint price = 20000000000000000; // 16x0\n        uint pricePrev = 20000000000000000;\n        uint systemCommission = 19000000000000000;\n        uint presidentCommission = 1000000000000000;\n        uint ownerCommission;\n\n        for (uint i = 1;i<=purchases;i++) {\n            if (i<=7)\n                price = price*2;\n            else\n                price = (price*12)/10;\n\n            presidentCommission = price/100;\n            systemCommission = (price-pricePrev)*2/10;\n            ownerCommission = price-presidentCommission-systemCommission;\n\n            pricePrev = price;\n        }\n        return [price,systemCommission,presidentCommission,ownerCommission];\n    }\n\n    function setNickname(string nickname) public {\n        if (maintenance) revert();\n        userNicknames[msg.sender] = nickname;\n    }\n\n    function _assignCountry(uint countryId)    private returns (bool) {\n        uint  totalPopulation;\n        uint  controlledPopulation;\n\n        uint  population;\n        for (uint i = 0;i<countriesCities[countryId].length;i++) {\n            population = cityPopulation[countriesCities[countryId][i]];\n            if (cities[countriesCities[countryId][i]].mayor==msg.sender) {\n                controlledPopulation += population;\n            }\n            totalPopulation += population;\n        }\n        if (controlledPopulation*2>(totalPopulation)) {\n            countries[countryId].president = msg.sender;\n            assignCountryEvent(msg.sender,countryId);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function buyCity(uint cityId) payable  public  {\n        if (maintenance) revert();\n        uint[4] memory prices = getPrices(cities[cityId].purchases);\n\n        if (cities[cityId].mayor==msg.sender) {\n            revert();\n        }\n        if (cityPopulation[cityId]==0) {\n            revert();\n        }\n\n        if ( msg.value+userPendingWithdrawals[msg.sender]>=prices[0]) {\n            // use user limit\n            userPendingWithdrawals[msg.sender] = userPendingWithdrawals[msg.sender]+msg.value-prices[0];\n            pendingWithdrawalEvent(msg.sender,userPendingWithdrawals[msg.sender]+msg.value-prices[0]);\n\n            cities[cityId].purchases = cities[cityId].purchases+1;\n\n            userPendingWithdrawals[cities[cityId].mayor] += prices[3];\n            pendingWithdrawalEvent(cities[cityId].mayor,prices[3]);\n\n            if (countries[citiesCountries[cityId]].president==0) {\n                userPendingWithdrawals[creator] += prices[2];\n                pendingWithdrawalEvent(creator,prices[2]);\n\n            } else {\n                userPendingWithdrawals[countries[citiesCountries[cityId]].president] += prices[2];\n                pendingWithdrawalEvent(countries[citiesCountries[cityId]].president,prices[2]);\n            }\n            // change mayor\n            if (cities[cityId].mayor>0) {\n                _removeUserCity(cities[cityId].mayor,cityId);\n            }\n\n\n\n            cities[cityId].mayor = msg.sender;\n            _addUserCity(msg.sender,cityId);\n\n            _assignCountry(citiesCountries[cityId]);\n\n            //send money to creator\n            creator.transfer(prices[1]);\n            buyCityEvent(msg.sender,cityId);\n\n        } else {\n            revert();\n        }\n    }\n    function getUserCities(address user) public view returns (uint[]) {\n        return userCities[user];\n    }\n\n    function _addUserCity(address user,uint cityId) private {\n        bool added = false;\n        for (uint i = 0; i<userCities[user].length; i++) {\n            if (userCities[user][i]==0) {\n                userCities[user][i] = cityId;\n                added = true;\n                break;\n            }\n        }\n        if (!added)\n            userCities[user].push(cityId);\n    }\n\n    function _removeUserCity(address user,uint cityId) private {\n        for (uint i = 0; i<userCities[user].length; i++) {\n            if (userCities[user][i]==cityId) {\n                delete userCities[user][i];\n            }\n        }\n    }\n\n}", "debug": "calldata_CryptoElections_4 + calldata_CryptoElections_32 + 4: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\nstorage_0: 0x0\ncaller: 0x0\ncalldata_CryptoElections_0: 0x36eccee00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoElections: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x036eccee`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/CryptoElections-0.sol", "function": "_function_0x036eccee", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9785, "code": "ntract CryptoElections {\n\n    /* Define variable owner of the type address */\n    address creator;\n\n    modifier onlyCreator() {\n        require(msg.sender == creator);\n        _;\n    }\n\n    modifier onlyCountryOwner(uint256 countryId) {\n        require(countries[countryId].president==msg.sender);\n        _;\n    }\n    modifier onlyCityOwner(uint cityId) {\n        require(cities[cityId].mayor==msg.sender);\n        _;\n    }\n\n    struct Country {\n        address president;\n        string slogan;\n        string flagUrl;\n    }\n    struct City {\n        address mayor;\n        string slogan;\n        string picture;\n        uint purchases;\n    }\n    bool maintenance=false;\n    event withdrawalEvent(address user,uint value);\n    event pendingWithdrawalEvent(address user,uint value);\n    event assignCountryEvent(address user,uint countryId);\n    event buyCityEvent(address user,uint cityId);\n    mapping(uint => Country) public countries ;\n    mapping(uint =>  uint[]) public countriesCities ;\n    mapping(uint =>  uint) public citiesCountries ;\n\n    mapping(uint =>  uint) public cityPopulation ;\n    mapping(uint => City) public cities;\n    mapping(address => uint[]) public userCities;\n    mapping(address => uint) public userPendingWithdrawals;\n    mapping(address => string) public userNicknames;\n\n    function CryptoElections() public {\n        creator = msg.sender;\n    }\n\n    function () public payable {\n        revert();\n    }\n\n    /* This function is executed at initialization and sets the owner of the contract */\n    /* Function to recover the funds on the contract */\n    function kill() public\n    onlyCreator()\n    {\n        selfdestruct(creator);\n    }\n\n    function transfer(address newCreator) public\n    onlyCreator()\n    {\n        creator=newCreator;\n    }\n\n\n\n    // Contract initialisation\n    function addCountryCities(uint countryId,uint[] _cities)  public\n    onlyCreator()\n    {\n        countriesCities[countryId] = _cities;\n        for (uint i = 0;i<_cities.length;i++) {\n            citiesCountries[_cities[i]] = countryId;\n\n        }\n    }\n    function setMaintenanceMode(bool _maintenance) public\n    onlyCreator()\n    {\n        maintenance=_maintenance;\n    }\n\n\n    // Contract initialisation\n    function addCitiesPopulation(uint[] _cities,uint[]_populations)  public\n    onlyCreator()\n    {\n\n        for (uint i = 0;i<_cities.length;i++) {\n\n            cityPopulation[_cities[i]] = _populations[i];\n        }\n    }\n\n    function setCountrySlogan(uint countryId,string slogan) public\n    onlyCountryOwner(countryId)\n    {\n        countries[countryId].slogan = slogan;\n    }\n\n    function setCountryPicture(uint countryId,string _flagUrl) public\n    onlyCountryOwner(countryId)\n    {\n        countries[countryId].flagUrl = _flagUrl;\n    }\n\n    function setCitySlogan(uint256 cityId,string _slogan) public\n    onlyCityOwner(cityId)\n    {\n        cities[cityId].slogan = _slogan;\n    }\n\n    function setCityPicture(uint256 cityId,string _picture) public\n    onlyCityOwner(cityId)\n    {\n        cities[cityId].picture = _picture;\n    }\n\n\n    function withdraw() public {\n        if (maintenance) revert();\n        uint amount = userPendingWithdrawals[msg.sender];\n        // Remember to zero the pending refund before\n        // sending to prevent re-entrancy attacks\n\n        userPendingWithdrawals[msg.sender] = 0;\n        withdrawalEvent(msg.sender,amount);\n        msg.sender.transfer(amount);\n    }\n\n    function getPrices(uint purchases) public pure returns (uint[4]) {\n        uint price = 20000000000000000; // 16x0\n        uint pricePrev = 20000000000000000;\n        uint systemCommission = 19000000000000000;\n        uint presidentCommission = 1000000000000000;\n        uint ownerCommission;\n\n        for (uint i = 1;i<=purchases;i++) {\n            if (i<=7)\n                price = price*2;\n            else\n                price = (price*12)/10;\n\n            presidentCommission = price/100;\n            systemCommission = (price-pricePrev)*2/10;\n            ownerCommission = price-presidentCommission-systemCommission;\n\n            pricePrev = price;\n        }\n        return [price,systemCommission,presidentCommission,ownerCommission];\n    }\n\n    function setNickname(string nickname) public {\n        if (maintenance) revert();\n        userNicknames[msg.sender] = nickname;\n    }\n\n    function _assignCountry(uint countryId)    private returns (bool) {\n        uint  totalPopulation;\n        uint  controlledPopulation;\n\n        uint  population;\n        for (uint i = 0;i<countriesCities[countryId].length;i++) {\n            population = cityPopulation[countriesCities[countryId][i]];\n            if (cities[countriesCities[countryId][i]].mayor==msg.sender) {\n                controlledPopulation += population;\n            }\n            totalPopulation += population;\n        }\n        if (controlledPopulation*2>(totalPopulation)) {\n            countries[countryId].president = msg.sender;\n            assignCountryEvent(msg.sender,countryId);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function buyCity(uint cityId) payable  public  {\n        if (maintenance) revert();\n        uint[4] memory prices = getPrices(cities[cityId].purchases);\n\n        if (cities[cityId].mayor==msg.sender) {\n            revert();\n        }\n        if (cityPopulation[cityId]==0) {\n            revert();\n        }\n\n        if ( msg.value+userPendingWithdrawals[msg.sender]>=prices[0]) {\n            // use user limit\n            userPendingWithdrawals[msg.sender] = userPendingWithdrawals[msg.sender]+msg.value-prices[0];\n            pendingWithdrawalEvent(msg.sender,userPendingWithdrawals[msg.sender]+msg.value-prices[0]);\n\n            cities[cityId].purchases = cities[cityId].purchases+1;\n\n            userPendingWithdrawals[cities[cityId].mayor] += prices[3];\n            pendingWithdrawalEvent(cities[cityId].mayor,prices[3]);\n\n            if (countries[citiesCountries[cityId]].president==0) {\n                userPendingWithdrawals[creator] += prices[2];\n                pendingWithdrawalEvent(creator,prices[2]);\n\n            } else {\n                userPendingWithdrawals[countries[citiesCountries[cityId]].president] += prices[2];\n                pendingWithdrawalEvent(countries[citiesCountries[cityId]].president,prices[2]);\n            }\n            // change mayor\n            if (cities[cityId].mayor>0) {\n                _removeUserCity(cities[cityId].mayor,cityId);\n            }\n\n\n\n            cities[cityId].mayor = msg.sender;\n            _addUserCity(msg.sender,cityId);\n\n            _assignCountry(citiesCountries[cityId]);\n\n            //send money to creator\n            creator.transfer(prices[1]);\n            buyCityEvent(msg.sender,cityId);\n\n        } else {\n            revert();\n        }\n    }\n    function getUserCities(address user) public view returns (uint[]) {\n        return userCities[user];\n    }\n\n    function _addUserCity(address user,uint cityId) private {\n        bool added = false;\n        for (uint i = 0; i<userCities[user].length; i++) {\n            if (userCities[user][i]==0) {\n                userCities[user][i] = cityId;\n                added = true;\n                break;\n            }\n        }\n        if (!added)\n            userCities[user].push(cityId);\n    }\n\n    function _removeUserCity(address user,uint cityId) private {\n        for (uint i = 0; i<userCities[user].length; i++) {\n            if (userCities[user][i]==cityId) {\n                delete userCities[user][i];\n            }\n        }\n    }\n\n}", "debug": "calldata_CryptoElections_4 + calldata_CryptoElections_32 + 4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\nstorage_0: 0x0\ncaller: 0x0\ncalldata_CryptoElections_0: 0x36eccee00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoElections: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x036eccee`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/CryptoElections-0.sol", "function": "_function_0x036eccee", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9807, "code": "ntract CryptoElections {\n\n    /* Define variable owner of the type address */\n    address creator;\n\n    modifier onlyCreator() {\n        require(msg.sender == creator);\n        _;\n    }\n\n    modifier onlyCountryOwner(uint256 countryId) {\n        require(countries[countryId].president==msg.sender);\n        _;\n    }\n    modifier onlyCityOwner(uint cityId) {\n        require(cities[cityId].mayor==msg.sender);\n        _;\n    }\n\n    struct Country {\n        address president;\n        string slogan;\n        string flagUrl;\n    }\n    struct City {\n        address mayor;\n        string slogan;\n        string picture;\n        uint purchases;\n    }\n    bool maintenance=false;\n    event withdrawalEvent(address user,uint value);\n    event pendingWithdrawalEvent(address user,uint value);\n    event assignCountryEvent(address user,uint countryId);\n    event buyCityEvent(address user,uint cityId);\n    mapping(uint => Country) public countries ;\n    mapping(uint =>  uint[]) public countriesCities ;\n    mapping(uint =>  uint) public citiesCountries ;\n\n    mapping(uint =>  uint) public cityPopulation ;\n    mapping(uint => City) public cities;\n    mapping(address => uint[]) public userCities;\n    mapping(address => uint) public userPendingWithdrawals;\n    mapping(address => string) public userNicknames;\n\n    function CryptoElections() public {\n        creator = msg.sender;\n    }\n\n    function () public payable {\n        revert();\n    }\n\n    /* This function is executed at initialization and sets the owner of the contract */\n    /* Function to recover the funds on the contract */\n    function kill() public\n    onlyCreator()\n    {\n        selfdestruct(creator);\n    }\n\n    function transfer(address newCreator) public\n    onlyCreator()\n    {\n        creator=newCreator;\n    }\n\n\n\n    // Contract initialisation\n    function addCountryCities(uint countryId,uint[] _cities)  public\n    onlyCreator()\n    {\n        countriesCities[countryId] = _cities;\n        for (uint i = 0;i<_cities.length;i++) {\n            citiesCountries[_cities[i]] = countryId;\n\n        }\n    }\n    function setMaintenanceMode(bool _maintenance) public\n    onlyCreator()\n    {\n        maintenance=_maintenance;\n    }\n\n\n    // Contract initialisation\n    function addCitiesPopulation(uint[] _cities,uint[]_populations)  public\n    onlyCreator()\n    {\n\n        for (uint i = 0;i<_cities.length;i++) {\n\n            cityPopulation[_cities[i]] = _populations[i];\n        }\n    }\n\n    function setCountrySlogan(uint countryId,string slogan) public\n    onlyCountryOwner(countryId)\n    {\n        countries[countryId].slogan = slogan;\n    }\n\n    function setCountryPicture(uint countryId,string _flagUrl) public\n    onlyCountryOwner(countryId)\n    {\n        countries[countryId].flagUrl = _flagUrl;\n    }\n\n    function setCitySlogan(uint256 cityId,string _slogan) public\n    onlyCityOwner(cityId)\n    {\n        cities[cityId].slogan = _slogan;\n    }\n\n    function setCityPicture(uint256 cityId,string _picture) public\n    onlyCityOwner(cityId)\n    {\n        cities[cityId].picture = _picture;\n    }\n\n\n    function withdraw() public {\n        if (maintenance) revert();\n        uint amount = userPendingWithdrawals[msg.sender];\n        // Remember to zero the pending refund before\n        // sending to prevent re-entrancy attacks\n\n        userPendingWithdrawals[msg.sender] = 0;\n        withdrawalEvent(msg.sender,amount);\n        msg.sender.transfer(amount);\n    }\n\n    function getPrices(uint purchases) public pure returns (uint[4]) {\n        uint price = 20000000000000000; // 16x0\n        uint pricePrev = 20000000000000000;\n        uint systemCommission = 19000000000000000;\n        uint presidentCommission = 1000000000000000;\n        uint ownerCommission;\n\n        for (uint i = 1;i<=purchases;i++) {\n            if (i<=7)\n                price = price*2;\n            else\n                price = (price*12)/10;\n\n            presidentCommission = price/100;\n            systemCommission = (price-pricePrev)*2/10;\n            ownerCommission = price-presidentCommission-systemCommission;\n\n            pricePrev = price;\n        }\n        return [price,systemCommission,presidentCommission,ownerCommission];\n    }\n\n    function setNickname(string nickname) public {\n        if (maintenance) revert();\n        userNicknames[msg.sender] = nickname;\n    }\n\n    function _assignCountry(uint countryId)    private returns (bool) {\n        uint  totalPopulation;\n        uint  controlledPopulation;\n\n        uint  population;\n        for (uint i = 0;i<countriesCities[countryId].length;i++) {\n            population = cityPopulation[countriesCities[countryId][i]];\n            if (cities[countriesCities[countryId][i]].mayor==msg.sender) {\n                controlledPopulation += population;\n            }\n            totalPopulation += population;\n        }\n        if (controlledPopulation*2>(totalPopulation)) {\n            countries[countryId].president = msg.sender;\n            assignCountryEvent(msg.sender,countryId);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function buyCity(uint cityId) payable  public  {\n        if (maintenance) revert();\n        uint[4] memory prices = getPrices(cities[cityId].purchases);\n\n        if (cities[cityId].mayor==msg.sender) {\n            revert();\n        }\n        if (cityPopulation[cityId]==0) {\n            revert();\n        }\n\n        if ( msg.value+userPendingWithdrawals[msg.sender]>=prices[0]) {\n            // use user limit\n            userPendingWithdrawals[msg.sender] = userPendingWithdrawals[msg.sender]+msg.value-prices[0];\n            pendingWithdrawalEvent(msg.sender,userPendingWithdrawals[msg.sender]+msg.value-prices[0]);\n\n            cities[cityId].purchases = cities[cityId].purchases+1;\n\n            userPendingWithdrawals[cities[cityId].mayor] += prices[3];\n            pendingWithdrawalEvent(cities[cityId].mayor,prices[3]);\n\n            if (countries[citiesCountries[cityId]].president==0) {\n                userPendingWithdrawals[creator] += prices[2];\n                pendingWithdrawalEvent(creator,prices[2]);\n\n            } else {\n                userPendingWithdrawals[countries[citiesCountries[cityId]].president] += prices[2];\n                pendingWithdrawalEvent(countries[citiesCountries[cityId]].president,prices[2]);\n            }\n            // change mayor\n            if (cities[cityId].mayor>0) {\n                _removeUserCity(cities[cityId].mayor,cityId);\n            }\n\n\n\n            cities[cityId].mayor = msg.sender;\n            _addUserCity(msg.sender,cityId);\n\n            _assignCountry(citiesCountries[cityId]);\n\n            //send money to creator\n            creator.transfer(prices[1]);\n            buyCityEvent(msg.sender,cityId);\n\n        } else {\n            revert();\n        }\n    }\n    function getUserCities(address user) public view returns (uint[]) {\n        return userCities[user];\n    }\n\n    function _addUserCity(address user,uint cityId) private {\n        bool added = false;\n        for (uint i = 0; i<userCities[user].length; i++) {\n            if (userCities[user][i]==0) {\n                userCities[user][i] = cityId;\n                added = true;\n                break;\n            }\n        }\n        if (!added)\n            userCities[user].push(cityId);\n    }\n\n    function _removeUserCity(address user,uint cityId) private {\n        for (uint i = 0; i<userCities[user].length; i++) {\n            if (userCities[user][i]==cityId) {\n                delete userCities[user][i];\n            }\n        }\n    }\n\n}", "debug": "keccac_keccac_calldata_CryptoElections_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_CryptoElections_4 + calldata_CryptoElections_32 + 4: 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\nstorage_0: 0x0\ncaller: 0x0\ncalldata_CryptoElections_0: 0x36eccee00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoElections: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x036eccee`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/CryptoElections-0.sol", "function": "_function_0x036eccee", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9870, "code": "ntract CryptoElections {\n\n    /* Define variable owner of the type address */\n    address creator;\n\n    modifier onlyCreator() {\n        require(msg.sender == creator);\n        _;\n    }\n\n    modifier onlyCountryOwner(uint256 countryId) {\n        require(countries[countryId].president==msg.sender);\n        _;\n    }\n    modifier onlyCityOwner(uint cityId) {\n        require(cities[cityId].mayor==msg.sender);\n        _;\n    }\n\n    struct Country {\n        address president;\n        string slogan;\n        string flagUrl;\n    }\n    struct City {\n        address mayor;\n        string slogan;\n        string picture;\n        uint purchases;\n    }\n    bool maintenance=false;\n    event withdrawalEvent(address user,uint value);\n    event pendingWithdrawalEvent(address user,uint value);\n    event assignCountryEvent(address user,uint countryId);\n    event buyCityEvent(address user,uint cityId);\n    mapping(uint => Country) public countries ;\n    mapping(uint =>  uint[]) public countriesCities ;\n    mapping(uint =>  uint) public citiesCountries ;\n\n    mapping(uint =>  uint) public cityPopulation ;\n    mapping(uint => City) public cities;\n    mapping(address => uint[]) public userCities;\n    mapping(address => uint) public userPendingWithdrawals;\n    mapping(address => string) public userNicknames;\n\n    function CryptoElections() public {\n        creator = msg.sender;\n    }\n\n    function () public payable {\n        revert();\n    }\n\n    /* This function is executed at initialization and sets the owner of the contract */\n    /* Function to recover the funds on the contract */\n    function kill() public\n    onlyCreator()\n    {\n        selfdestruct(creator);\n    }\n\n    function transfer(address newCreator) public\n    onlyCreator()\n    {\n        creator=newCreator;\n    }\n\n\n\n    // Contract initialisation\n    function addCountryCities(uint countryId,uint[] _cities)  public\n    onlyCreator()\n    {\n        countriesCities[countryId] = _cities;\n        for (uint i = 0;i<_cities.length;i++) {\n            citiesCountries[_cities[i]] = countryId;\n\n        }\n    }\n    function setMaintenanceMode(bool _maintenance) public\n    onlyCreator()\n    {\n        maintenance=_maintenance;\n    }\n\n\n    // Contract initialisation\n    function addCitiesPopulation(uint[] _cities,uint[]_populations)  public\n    onlyCreator()\n    {\n\n        for (uint i = 0;i<_cities.length;i++) {\n\n            cityPopulation[_cities[i]] = _populations[i];\n        }\n    }\n\n    function setCountrySlogan(uint countryId,string slogan) public\n    onlyCountryOwner(countryId)\n    {\n        countries[countryId].slogan = slogan;\n    }\n\n    function setCountryPicture(uint countryId,string _flagUrl) public\n    onlyCountryOwner(countryId)\n    {\n        countries[countryId].flagUrl = _flagUrl;\n    }\n\n    function setCitySlogan(uint256 cityId,string _slogan) public\n    onlyCityOwner(cityId)\n    {\n        cities[cityId].slogan = _slogan;\n    }\n\n    function setCityPicture(uint256 cityId,string _picture) public\n    onlyCityOwner(cityId)\n    {\n        cities[cityId].picture = _picture;\n    }\n\n\n    function withdraw() public {\n        if (maintenance) revert();\n        uint amount = userPendingWithdrawals[msg.sender];\n        // Remember to zero the pending refund before\n        // sending to prevent re-entrancy attacks\n\n        userPendingWithdrawals[msg.sender] = 0;\n        withdrawalEvent(msg.sender,amount);\n        msg.sender.transfer(amount);\n    }\n\n    function getPrices(uint purchases) public pure returns (uint[4]) {\n        uint price = 20000000000000000; // 16x0\n        uint pricePrev = 20000000000000000;\n        uint systemCommission = 19000000000000000;\n        uint presidentCommission = 1000000000000000;\n        uint ownerCommission;\n\n        for (uint i = 1;i<=purchases;i++) {\n            if (i<=7)\n                price = price*2;\n            else\n                price = (price*12)/10;\n\n            presidentCommission = price/100;\n            systemCommission = (price-pricePrev)*2/10;\n            ownerCommission = price-presidentCommission-systemCommission;\n\n            pricePrev = price;\n        }\n        return [price,systemCommission,presidentCommission,ownerCommission];\n    }\n\n    function setNickname(string nickname) public {\n        if (maintenance) revert();\n        userNicknames[msg.sender] = nickname;\n    }\n\n    function _assignCountry(uint countryId)    private returns (bool) {\n        uint  totalPopulation;\n        uint  controlledPopulation;\n\n        uint  population;\n        for (uint i = 0;i<countriesCities[countryId].length;i++) {\n            population = cityPopulation[countriesCities[countryId][i]];\n            if (cities[countriesCities[countryId][i]].mayor==msg.sender) {\n                controlledPopulation += population;\n            }\n            totalPopulation += population;\n        }\n        if (controlledPopulation*2>(totalPopulation)) {\n            countries[countryId].president = msg.sender;\n            assignCountryEvent(msg.sender,countryId);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function buyCity(uint cityId) payable  public  {\n        if (maintenance) revert();\n        uint[4] memory prices = getPrices(cities[cityId].purchases);\n\n        if (cities[cityId].mayor==msg.sender) {\n            revert();\n        }\n        if (cityPopulation[cityId]==0) {\n            revert();\n        }\n\n        if ( msg.value+userPendingWithdrawals[msg.sender]>=prices[0]) {\n            // use user limit\n            userPendingWithdrawals[msg.sender] = userPendingWithdrawals[msg.sender]+msg.value-prices[0];\n            pendingWithdrawalEvent(msg.sender,userPendingWithdrawals[msg.sender]+msg.value-prices[0]);\n\n            cities[cityId].purchases = cities[cityId].purchases+1;\n\n            userPendingWithdrawals[cities[cityId].mayor] += prices[3];\n            pendingWithdrawalEvent(cities[cityId].mayor,prices[3]);\n\n            if (countries[citiesCountries[cityId]].president==0) {\n                userPendingWithdrawals[creator] += prices[2];\n                pendingWithdrawalEvent(creator,prices[2]);\n\n            } else {\n                userPendingWithdrawals[countries[citiesCountries[cityId]].president] += prices[2];\n                pendingWithdrawalEvent(countries[citiesCountries[cityId]].president,prices[2]);\n            }\n            // change mayor\n            if (cities[cityId].mayor>0) {\n                _removeUserCity(cities[cityId].mayor,cityId);\n            }\n\n\n\n            cities[cityId].mayor = msg.sender;\n            _addUserCity(msg.sender,cityId);\n\n            _assignCountry(citiesCountries[cityId]);\n\n            //send money to creator\n            creator.transfer(prices[1]);\n            buyCityEvent(msg.sender,cityId);\n\n        } else {\n            revert();\n        }\n    }\n    function getUserCities(address user) public view returns (uint[]) {\n        return userCities[user];\n    }\n\n    function _addUserCity(address user,uint cityId) private {\n        bool added = false;\n        for (uint i = 0; i<userCities[user].length; i++) {\n            if (userCities[user][i]==0) {\n                userCities[user][i] = cityId;\n                added = true;\n                break;\n            }\n        }\n        if (!added)\n            userCities[user].push(cityId);\n    }\n\n    function _removeUserCity(address user,uint cityId) private {\n        for (uint i = 0; i<userCities[user].length; i++) {\n            if (userCities[user][i]==cityId) {\n                delete userCities[user][i];\n            }\n        }\n    }\n\n}", "debug": "keccac_1_+_keccac_calldata_CryptoElections_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_1 + keccac_calldata_CryptoElections_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\ncaller: 0x0\nstorage_0 + keccac_calldata_CryptoElections_4: 0x0\ncalldata_CryptoElections_0: 0x2acefd0f00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoElections: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setCitySlogan(uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/CryptoElections-0.sol", "function": "setCitySlogan(uint256,string)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9899, "code": "ntract CryptoElections {\n\n    /* Define variable owner of the type address */\n    address creator;\n\n    modifier onlyCreator() {\n        require(msg.sender == creator);\n        _;\n    }\n\n    modifier onlyCountryOwner(uint256 countryId) {\n        require(countries[countryId].president==msg.sender);\n        _;\n    }\n    modifier onlyCityOwner(uint cityId) {\n        require(cities[cityId].mayor==msg.sender);\n        _;\n    }\n\n    struct Country {\n        address president;\n        string slogan;\n        string flagUrl;\n    }\n    struct City {\n        address mayor;\n        string slogan;\n        string picture;\n        uint purchases;\n    }\n    bool maintenance=false;\n    event withdrawalEvent(address user,uint value);\n    event pendingWithdrawalEvent(address user,uint value);\n    event assignCountryEvent(address user,uint countryId);\n    event buyCityEvent(address user,uint cityId);\n    mapping(uint => Country) public countries ;\n    mapping(uint =>  uint[]) public countriesCities ;\n    mapping(uint =>  uint) public citiesCountries ;\n\n    mapping(uint =>  uint) public cityPopulation ;\n    mapping(uint => City) public cities;\n    mapping(address => uint[]) public userCities;\n    mapping(address => uint) public userPendingWithdrawals;\n    mapping(address => string) public userNicknames;\n\n    function CryptoElections() public {\n        creator = msg.sender;\n    }\n\n    function () public payable {\n        revert();\n    }\n\n    /* This function is executed at initialization and sets the owner of the contract */\n    /* Function to recover the funds on the contract */\n    function kill() public\n    onlyCreator()\n    {\n        selfdestruct(creator);\n    }\n\n    function transfer(address newCreator) public\n    onlyCreator()\n    {\n        creator=newCreator;\n    }\n\n\n\n    // Contract initialisation\n    function addCountryCities(uint countryId,uint[] _cities)  public\n    onlyCreator()\n    {\n        countriesCities[countryId] = _cities;\n        for (uint i = 0;i<_cities.length;i++) {\n            citiesCountries[_cities[i]] = countryId;\n\n        }\n    }\n    function setMaintenanceMode(bool _maintenance) public\n    onlyCreator()\n    {\n        maintenance=_maintenance;\n    }\n\n\n    // Contract initialisation\n    function addCitiesPopulation(uint[] _cities,uint[]_populations)  public\n    onlyCreator()\n    {\n\n        for (uint i = 0;i<_cities.length;i++) {\n\n            cityPopulation[_cities[i]] = _populations[i];\n        }\n    }\n\n    function setCountrySlogan(uint countryId,string slogan) public\n    onlyCountryOwner(countryId)\n    {\n        countries[countryId].slogan = slogan;\n    }\n\n    function setCountryPicture(uint countryId,string _flagUrl) public\n    onlyCountryOwner(countryId)\n    {\n        countries[countryId].flagUrl = _flagUrl;\n    }\n\n    function setCitySlogan(uint256 cityId,string _slogan) public\n    onlyCityOwner(cityId)\n    {\n        cities[cityId].slogan = _slogan;\n    }\n\n    function setCityPicture(uint256 cityId,string _picture) public\n    onlyCityOwner(cityId)\n    {\n        cities[cityId].picture = _picture;\n    }\n\n\n    function withdraw() public {\n        if (maintenance) revert();\n        uint amount = userPendingWithdrawals[msg.sender];\n        // Remember to zero the pending refund before\n        // sending to prevent re-entrancy attacks\n\n        userPendingWithdrawals[msg.sender] = 0;\n        withdrawalEvent(msg.sender,amount);\n        msg.sender.transfer(amount);\n    }\n\n    function getPrices(uint purchases) public pure returns (uint[4]) {\n        uint price = 20000000000000000; // 16x0\n        uint pricePrev = 20000000000000000;\n        uint systemCommission = 19000000000000000;\n        uint presidentCommission = 1000000000000000;\n        uint ownerCommission;\n\n        for (uint i = 1;i<=purchases;i++) {\n            if (i<=7)\n                price = price*2;\n            else\n                price = (price*12)/10;\n\n            presidentCommission = price/100;\n            systemCommission = (price-pricePrev)*2/10;\n            ownerCommission = price-presidentCommission-systemCommission;\n\n            pricePrev = price;\n        }\n        return [price,systemCommission,presidentCommission,ownerCommission];\n    }\n\n    function setNickname(string nickname) public {\n        if (maintenance) revert();\n        userNicknames[msg.sender] = nickname;\n    }\n\n    function _assignCountry(uint countryId)    private returns (bool) {\n        uint  totalPopulation;\n        uint  controlledPopulation;\n\n        uint  population;\n        for (uint i = 0;i<countriesCities[countryId].length;i++) {\n            population = cityPopulation[countriesCities[countryId][i]];\n            if (cities[countriesCities[countryId][i]].mayor==msg.sender) {\n                controlledPopulation += population;\n            }\n            totalPopulation += population;\n        }\n        if (controlledPopulation*2>(totalPopulation)) {\n            countries[countryId].president = msg.sender;\n            assignCountryEvent(msg.sender,countryId);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function buyCity(uint cityId) payable  public  {\n        if (maintenance) revert();\n        uint[4] memory prices = getPrices(cities[cityId].purchases);\n\n        if (cities[cityId].mayor==msg.sender) {\n            revert();\n        }\n        if (cityPopulation[cityId]==0) {\n            revert();\n        }\n\n        if ( msg.value+userPendingWithdrawals[msg.sender]>=prices[0]) {\n            // use user limit\n            userPendingWithdrawals[msg.sender] = userPendingWithdrawals[msg.sender]+msg.value-prices[0];\n            pendingWithdrawalEvent(msg.sender,userPendingWithdrawals[msg.sender]+msg.value-prices[0]);\n\n            cities[cityId].purchases = cities[cityId].purchases+1;\n\n            userPendingWithdrawals[cities[cityId].mayor] += prices[3];\n            pendingWithdrawalEvent(cities[cityId].mayor,prices[3]);\n\n            if (countries[citiesCountries[cityId]].president==0) {\n                userPendingWithdrawals[creator] += prices[2];\n                pendingWithdrawalEvent(creator,prices[2]);\n\n            } else {\n                userPendingWithdrawals[countries[citiesCountries[cityId]].president] += prices[2];\n                pendingWithdrawalEvent(countries[citiesCountries[cityId]].president,prices[2]);\n            }\n            // change mayor\n            if (cities[cityId].mayor>0) {\n                _removeUserCity(cities[cityId].mayor,cityId);\n            }\n\n\n\n            cities[cityId].mayor = msg.sender;\n            _addUserCity(msg.sender,cityId);\n\n            _assignCountry(citiesCountries[cityId]);\n\n            //send money to creator\n            creator.transfer(prices[1]);\n            buyCityEvent(msg.sender,cityId);\n\n        } else {\n            revert();\n        }\n    }\n    function getUserCities(address user) public view returns (uint[]) {\n        return userCities[user];\n    }\n\n    function _addUserCity(address user,uint cityId) private {\n        bool added = false;\n        for (uint i = 0; i<userCities[user].length; i++) {\n            if (userCities[user][i]==0) {\n                userCities[user][i] = cityId;\n                added = true;\n                break;\n            }\n        }\n        if (!added)\n            userCities[user].push(cityId);\n    }\n\n    function _removeUserCity(address user,uint cityId) private {\n        for (uint i = 0; i<userCities[user].length; i++) {\n            if (userCities[user][i]==cityId) {\n                delete userCities[user][i];\n            }\n        }\n    }\n\n}", "debug": "calldata_CryptoElections_4 + calldata_CryptoElections_32 + 4: 0x8000000000000000000000000000000000000000000000000000000000000000\ncaller: 0x0\nstorage_0 + keccac_calldata_CryptoElections_4: 0x0\ncalldata_CryptoElections_0: 0x2acefd0f00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoElections: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setCitySlogan(uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/CryptoElections-0.sol", "function": "setCitySlogan(uint256,string)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9913, "code": "ntract CryptoElections {\n\n    /* Define variable owner of the type address */\n    address creator;\n\n    modifier onlyCreator() {\n        require(msg.sender == creator);\n        _;\n    }\n\n    modifier onlyCountryOwner(uint256 countryId) {\n        require(countries[countryId].president==msg.sender);\n        _;\n    }\n    modifier onlyCityOwner(uint cityId) {\n        require(cities[cityId].mayor==msg.sender);\n        _;\n    }\n\n    struct Country {\n        address president;\n        string slogan;\n        string flagUrl;\n    }\n    struct City {\n        address mayor;\n        string slogan;\n        string picture;\n        uint purchases;\n    }\n    bool maintenance=false;\n    event withdrawalEvent(address user,uint value);\n    event pendingWithdrawalEvent(address user,uint value);\n    event assignCountryEvent(address user,uint countryId);\n    event buyCityEvent(address user,uint cityId);\n    mapping(uint => Country) public countries ;\n    mapping(uint =>  uint[]) public countriesCities ;\n    mapping(uint =>  uint) public citiesCountries ;\n\n    mapping(uint =>  uint) public cityPopulation ;\n    mapping(uint => City) public cities;\n    mapping(address => uint[]) public userCities;\n    mapping(address => uint) public userPendingWithdrawals;\n    mapping(address => string) public userNicknames;\n\n    function CryptoElections() public {\n        creator = msg.sender;\n    }\n\n    function () public payable {\n        revert();\n    }\n\n    /* This function is executed at initialization and sets the owner of the contract */\n    /* Function to recover the funds on the contract */\n    function kill() public\n    onlyCreator()\n    {\n        selfdestruct(creator);\n    }\n\n    function transfer(address newCreator) public\n    onlyCreator()\n    {\n        creator=newCreator;\n    }\n\n\n\n    // Contract initialisation\n    function addCountryCities(uint countryId,uint[] _cities)  public\n    onlyCreator()\n    {\n        countriesCities[countryId] = _cities;\n        for (uint i = 0;i<_cities.length;i++) {\n            citiesCountries[_cities[i]] = countryId;\n\n        }\n    }\n    function setMaintenanceMode(bool _maintenance) public\n    onlyCreator()\n    {\n        maintenance=_maintenance;\n    }\n\n\n    // Contract initialisation\n    function addCitiesPopulation(uint[] _cities,uint[]_populations)  public\n    onlyCreator()\n    {\n\n        for (uint i = 0;i<_cities.length;i++) {\n\n            cityPopulation[_cities[i]] = _populations[i];\n        }\n    }\n\n    function setCountrySlogan(uint countryId,string slogan) public\n    onlyCountryOwner(countryId)\n    {\n        countries[countryId].slogan = slogan;\n    }\n\n    function setCountryPicture(uint countryId,string _flagUrl) public\n    onlyCountryOwner(countryId)\n    {\n        countries[countryId].flagUrl = _flagUrl;\n    }\n\n    function setCitySlogan(uint256 cityId,string _slogan) public\n    onlyCityOwner(cityId)\n    {\n        cities[cityId].slogan = _slogan;\n    }\n\n    function setCityPicture(uint256 cityId,string _picture) public\n    onlyCityOwner(cityId)\n    {\n        cities[cityId].picture = _picture;\n    }\n\n\n    function withdraw() public {\n        if (maintenance) revert();\n        uint amount = userPendingWithdrawals[msg.sender];\n        // Remember to zero the pending refund before\n        // sending to prevent re-entrancy attacks\n\n        userPendingWithdrawals[msg.sender] = 0;\n        withdrawalEvent(msg.sender,amount);\n        msg.sender.transfer(amount);\n    }\n\n    function getPrices(uint purchases) public pure returns (uint[4]) {\n        uint price = 20000000000000000; // 16x0\n        uint pricePrev = 20000000000000000;\n        uint systemCommission = 19000000000000000;\n        uint presidentCommission = 1000000000000000;\n        uint ownerCommission;\n\n        for (uint i = 1;i<=purchases;i++) {\n            if (i<=7)\n                price = price*2;\n            else\n                price = (price*12)/10;\n\n            presidentCommission = price/100;\n            systemCommission = (price-pricePrev)*2/10;\n            ownerCommission = price-presidentCommission-systemCommission;\n\n            pricePrev = price;\n        }\n        return [price,systemCommission,presidentCommission,ownerCommission];\n    }\n\n    function setNickname(string nickname) public {\n        if (maintenance) revert();\n        userNicknames[msg.sender] = nickname;\n    }\n\n    function _assignCountry(uint countryId)    private returns (bool) {\n        uint  totalPopulation;\n        uint  controlledPopulation;\n\n        uint  population;\n        for (uint i = 0;i<countriesCities[countryId].length;i++) {\n            population = cityPopulation[countriesCities[countryId][i]];\n            if (cities[countriesCities[countryId][i]].mayor==msg.sender) {\n                controlledPopulation += population;\n            }\n            totalPopulation += population;\n        }\n        if (controlledPopulation*2>(totalPopulation)) {\n            countries[countryId].president = msg.sender;\n            assignCountryEvent(msg.sender,countryId);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function buyCity(uint cityId) payable  public  {\n        if (maintenance) revert();\n        uint[4] memory prices = getPrices(cities[cityId].purchases);\n\n        if (cities[cityId].mayor==msg.sender) {\n            revert();\n        }\n        if (cityPopulation[cityId]==0) {\n            revert();\n        }\n\n        if ( msg.value+userPendingWithdrawals[msg.sender]>=prices[0]) {\n            // use user limit\n            userPendingWithdrawals[msg.sender] = userPendingWithdrawals[msg.sender]+msg.value-prices[0];\n            pendingWithdrawalEvent(msg.sender,userPendingWithdrawals[msg.sender]+msg.value-prices[0]);\n\n            cities[cityId].purchases = cities[cityId].purchases+1;\n\n            userPendingWithdrawals[cities[cityId].mayor] += prices[3];\n            pendingWithdrawalEvent(cities[cityId].mayor,prices[3]);\n\n            if (countries[citiesCountries[cityId]].president==0) {\n                userPendingWithdrawals[creator] += prices[2];\n                pendingWithdrawalEvent(creator,prices[2]);\n\n            } else {\n                userPendingWithdrawals[countries[citiesCountries[cityId]].president] += prices[2];\n                pendingWithdrawalEvent(countries[citiesCountries[cityId]].president,prices[2]);\n            }\n            // change mayor\n            if (cities[cityId].mayor>0) {\n                _removeUserCity(cities[cityId].mayor,cityId);\n            }\n\n\n\n            cities[cityId].mayor = msg.sender;\n            _addUserCity(msg.sender,cityId);\n\n            _assignCountry(citiesCountries[cityId]);\n\n            //send money to creator\n            creator.transfer(prices[1]);\n            buyCityEvent(msg.sender,cityId);\n\n        } else {\n            revert();\n        }\n    }\n    function getUserCities(address user) public view returns (uint[]) {\n        return userCities[user];\n    }\n\n    function _addUserCity(address user,uint cityId) private {\n        bool added = false;\n        for (uint i = 0; i<userCities[user].length; i++) {\n            if (userCities[user][i]==0) {\n                userCities[user][i] = cityId;\n                added = true;\n                break;\n            }\n        }\n        if (!added)\n            userCities[user].push(cityId);\n    }\n\n    function _removeUserCity(address user,uint cityId) private {\n        for (uint i = 0; i<userCities[user].length; i++) {\n            if (userCities[user][i]==cityId) {\n                delete userCities[user][i];\n            }\n        }\n    }\n\n}", "debug": "calldata_CryptoElections_4 + calldata_CryptoElections_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncaller: 0x0\nstorage_0 + keccac_calldata_CryptoElections_4: 0x0\ncalldata_CryptoElections_0: 0x2acefd0f00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoElections: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setCitySlogan(uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/CryptoElections-0.sol", "function": "setCitySlogan(uint256,string)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9935, "code": "ntract CryptoElections {\n\n    /* Define variable owner of the type address */\n    address creator;\n\n    modifier onlyCreator() {\n        require(msg.sender == creator);\n        _;\n    }\n\n    modifier onlyCountryOwner(uint256 countryId) {\n        require(countries[countryId].president==msg.sender);\n        _;\n    }\n    modifier onlyCityOwner(uint cityId) {\n        require(cities[cityId].mayor==msg.sender);\n        _;\n    }\n\n    struct Country {\n        address president;\n        string slogan;\n        string flagUrl;\n    }\n    struct City {\n        address mayor;\n        string slogan;\n        string picture;\n        uint purchases;\n    }\n    bool maintenance=false;\n    event withdrawalEvent(address user,uint value);\n    event pendingWithdrawalEvent(address user,uint value);\n    event assignCountryEvent(address user,uint countryId);\n    event buyCityEvent(address user,uint cityId);\n    mapping(uint => Country) public countries ;\n    mapping(uint =>  uint[]) public countriesCities ;\n    mapping(uint =>  uint) public citiesCountries ;\n\n    mapping(uint =>  uint) public cityPopulation ;\n    mapping(uint => City) public cities;\n    mapping(address => uint[]) public userCities;\n    mapping(address => uint) public userPendingWithdrawals;\n    mapping(address => string) public userNicknames;\n\n    function CryptoElections() public {\n        creator = msg.sender;\n    }\n\n    function () public payable {\n        revert();\n    }\n\n    /* This function is executed at initialization and sets the owner of the contract */\n    /* Function to recover the funds on the contract */\n    function kill() public\n    onlyCreator()\n    {\n        selfdestruct(creator);\n    }\n\n    function transfer(address newCreator) public\n    onlyCreator()\n    {\n        creator=newCreator;\n    }\n\n\n\n    // Contract initialisation\n    function addCountryCities(uint countryId,uint[] _cities)  public\n    onlyCreator()\n    {\n        countriesCities[countryId] = _cities;\n        for (uint i = 0;i<_cities.length;i++) {\n            citiesCountries[_cities[i]] = countryId;\n\n        }\n    }\n    function setMaintenanceMode(bool _maintenance) public\n    onlyCreator()\n    {\n        maintenance=_maintenance;\n    }\n\n\n    // Contract initialisation\n    function addCitiesPopulation(uint[] _cities,uint[]_populations)  public\n    onlyCreator()\n    {\n\n        for (uint i = 0;i<_cities.length;i++) {\n\n            cityPopulation[_cities[i]] = _populations[i];\n        }\n    }\n\n    function setCountrySlogan(uint countryId,string slogan) public\n    onlyCountryOwner(countryId)\n    {\n        countries[countryId].slogan = slogan;\n    }\n\n    function setCountryPicture(uint countryId,string _flagUrl) public\n    onlyCountryOwner(countryId)\n    {\n        countries[countryId].flagUrl = _flagUrl;\n    }\n\n    function setCitySlogan(uint256 cityId,string _slogan) public\n    onlyCityOwner(cityId)\n    {\n        cities[cityId].slogan = _slogan;\n    }\n\n    function setCityPicture(uint256 cityId,string _picture) public\n    onlyCityOwner(cityId)\n    {\n        cities[cityId].picture = _picture;\n    }\n\n\n    function withdraw() public {\n        if (maintenance) revert();\n        uint amount = userPendingWithdrawals[msg.sender];\n        // Remember to zero the pending refund before\n        // sending to prevent re-entrancy attacks\n\n        userPendingWithdrawals[msg.sender] = 0;\n        withdrawalEvent(msg.sender,amount);\n        msg.sender.transfer(amount);\n    }\n\n    function getPrices(uint purchases) public pure returns (uint[4]) {\n        uint price = 20000000000000000; // 16x0\n        uint pricePrev = 20000000000000000;\n        uint systemCommission = 19000000000000000;\n        uint presidentCommission = 1000000000000000;\n        uint ownerCommission;\n\n        for (uint i = 1;i<=purchases;i++) {\n            if (i<=7)\n                price = price*2;\n            else\n                price = (price*12)/10;\n\n            presidentCommission = price/100;\n            systemCommission = (price-pricePrev)*2/10;\n            ownerCommission = price-presidentCommission-systemCommission;\n\n            pricePrev = price;\n        }\n        return [price,systemCommission,presidentCommission,ownerCommission];\n    }\n\n    function setNickname(string nickname) public {\n        if (maintenance) revert();\n        userNicknames[msg.sender] = nickname;\n    }\n\n    function _assignCountry(uint countryId)    private returns (bool) {\n        uint  totalPopulation;\n        uint  controlledPopulation;\n\n        uint  population;\n        for (uint i = 0;i<countriesCities[countryId].length;i++) {\n            population = cityPopulation[countriesCities[countryId][i]];\n            if (cities[countriesCities[countryId][i]].mayor==msg.sender) {\n                controlledPopulation += population;\n            }\n            totalPopulation += population;\n        }\n        if (controlledPopulation*2>(totalPopulation)) {\n            countries[countryId].president = msg.sender;\n            assignCountryEvent(msg.sender,countryId);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function buyCity(uint cityId) payable  public  {\n        if (maintenance) revert();\n        uint[4] memory prices = getPrices(cities[cityId].purchases);\n\n        if (cities[cityId].mayor==msg.sender) {\n            revert();\n        }\n        if (cityPopulation[cityId]==0) {\n            revert();\n        }\n\n        if ( msg.value+userPendingWithdrawals[msg.sender]>=prices[0]) {\n            // use user limit\n            userPendingWithdrawals[msg.sender] = userPendingWithdrawals[msg.sender]+msg.value-prices[0];\n            pendingWithdrawalEvent(msg.sender,userPendingWithdrawals[msg.sender]+msg.value-prices[0]);\n\n            cities[cityId].purchases = cities[cityId].purchases+1;\n\n            userPendingWithdrawals[cities[cityId].mayor] += prices[3];\n            pendingWithdrawalEvent(cities[cityId].mayor,prices[3]);\n\n            if (countries[citiesCountries[cityId]].president==0) {\n                userPendingWithdrawals[creator] += prices[2];\n                pendingWithdrawalEvent(creator,prices[2]);\n\n            } else {\n                userPendingWithdrawals[countries[citiesCountries[cityId]].president] += prices[2];\n                pendingWithdrawalEvent(countries[citiesCountries[cityId]].president,prices[2]);\n            }\n            // change mayor\n            if (cities[cityId].mayor>0) {\n                _removeUserCity(cities[cityId].mayor,cityId);\n            }\n\n\n\n            cities[cityId].mayor = msg.sender;\n            _addUserCity(msg.sender,cityId);\n\n            _assignCountry(citiesCountries[cityId]);\n\n            //send money to creator\n            creator.transfer(prices[1]);\n            buyCityEvent(msg.sender,cityId);\n\n        } else {\n            revert();\n        }\n    }\n    function getUserCities(address user) public view returns (uint[]) {\n        return userCities[user];\n    }\n\n    function _addUserCity(address user,uint cityId) private {\n        bool added = false;\n        for (uint i = 0; i<userCities[user].length; i++) {\n            if (userCities[user][i]==0) {\n                userCities[user][i] = cityId;\n                added = true;\n                break;\n            }\n        }\n        if (!added)\n            userCities[user].push(cityId);\n    }\n\n    function _removeUserCity(address user,uint cityId) private {\n        for (uint i = 0; i<userCities[user].length; i++) {\n            if (userCities[user][i]==cityId) {\n                delete userCities[user][i];\n            }\n        }\n    }\n\n}", "debug": "keccac_1_+_keccac_calldata_CryptoElections_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_CryptoElections_4 + calldata_CryptoElections_32 + 4: 0x4000f04100100000000000000000000000000000d6401413fffffffffffffe0\ncaller: 0x0\nstorage_0 + keccac_calldata_CryptoElections_4: 0x0\ncalldata_CryptoElections_0: 0x2acefd0f00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoElections: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setCitySlogan(uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/CryptoElections-0.sol", "function": "setCitySlogan(uint256,string)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}], "success": true}
