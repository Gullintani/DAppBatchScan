{"error": null, "issues": [{"address": 3343, "code": "serMonstersCount[oldOwner]; i++) {\n\t        if(oldUserMo", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_calldata_EthMonsters_4,_256): 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\ncalldata_EthMonsters_0: 0x1d30ffca00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthMonsters: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferMonster(uint256,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/EthMonsters-0.sol", "function": "transferMonster(uint256,address)", "lineno": 82, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3345, "code": "serMonstersCount[oldOwner]; i++) {\n\t        if(oldUserMo", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_calldata_EthMonsters_4,_256): 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_EthMonsters_0: 0x1d30ffca00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthMonsters: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferMonster(uint256,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/EthMonsters-0.sol", "function": "transferMonster(uint256,address)", "lineno": 82, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3944, "code": " = newOwner;\n\t    monsterToOw", "debug": "calldata_EthMonsters_0: 0x1d30ffca00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthMonsters: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_calldata_EthMonsters_4,_256): 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `transferMonster(uint256,address)`.\nThe subtraction may result in a value < 0.", "filename": "/temp/EthMonsters-0.sol", "function": "transferMonster(uint256,address)", "lineno": 94, "title": "Integer Underflow", "type": "Warning"}, {"address": 4023, "code": " = newOwner;\n\t}\n\t\n\tfunction h", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_calldata_EthMonsters_4,_256): 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_EthMonsters_32_+_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_EthMonsters_4: 0x0\nstorage_keccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_calldata_EthMonsters_4,_256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_EthMonsters_0: 0x1d30ffca00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthMonsters: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferMonster(uint256,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/EthMonsters-0.sol", "function": "transferMonster(uint256,address)", "lineno": 95, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4043, "code": "uint _id, uin", "debug": "The exception is triggered under the following conditions:\n\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_calldata_EthMonsters_4,_256): 0x1\ncalldata_EthMonsters_4: 0x0\nstorage_5: 0x0\nstorage_keccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_calldata_EthMonsters_4,_256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_EthMonsters_0: 0x1d30ffca00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthMonsters: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/EthMonsters-0.sol", "function": "transferMonster(uint256,address)", "lineno": 98, "title": "Exception state", "type": "Informational"}, {"address": 4311, "code": "ss newOwner) ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_EthMonsters_4: 0x0\nstorage_5: 0x0\ncalldata_EthMonsters_0: 0x223ce43700000000000000000000000000000000000000000000000000000000\ncalldatasize_EthMonsters: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/EthMonsters-0.sol", "function": "addExpToMonster(uint256,uint256)", "lineno": 79, "title": "Exception state", "type": "Informational"}, {"address": 4335, "code": "ss newOwner) public allowed", "debug": "calldata_EthMonsters_32 + 4: 0x57f25cd000000000000000000000000000000000000000000000000000000000\nstorage_6 +\n1546678032441257452667456735582814959992782782816731922691272282333561699760 +\n12*calldata_EthMonsters_4: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncalldata_EthMonsters_4: 0x0\nstorage_5: 0x1\ncalldata_EthMonsters_0: 0x223ce43700000000000000000000000000000000000000000000000000000000\ncalldatasize_EthMonsters: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `addExpToMonster(uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/EthMonsters-0.sol", "function": "addExpToMonster(uint256,uint256)", "lineno": 79, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4659, "debug": "The exception is triggered under the following conditions:\n\ncalldata_EthMonsters_4: 0x0\nstorage_10: 0x0\ncalldata_EthMonsters_0: 0x4036ab7800000000000000000000000000000000000000000000000000000000\ncalldatasize_EthMonsters: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/EthMonsters-0.sol", "function": "getType(uint256)", "lineno": 184, "title": "Exception state", "type": "Informational"}, {"address": 5331, "code": "string _name", "debug": "The exception is triggered under the following conditions:\n\ncalldata_EthMonsters_4: 0x0\nstorage_5: 0x0\ncalldata_EthMonsters_0: 0x62fb6fe100000000000000000000000000000000000000000000000000000000\ncalldatasize_EthMonsters: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/EthMonsters-0.sol", "function": "getMonster(uint256)", "lineno": 175, "title": "Exception state", "type": "Informational"}, {"address": 5968, "code": "\t\n\tfunction c", "debug": "The exception is triggered under the following conditions:\n\ncalldata_EthMonsters_4: 0x0\nstorage_5: 0x0\ncalldata_EthMonsters_0: 0x6fc2790e00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthMonsters: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/EthMonsters-0.sol", "function": "hatchEgg(uint256,uint256)", "lineno": 103, "title": "Exception state", "type": "Informational"}, {"address": 6378, "code": "tion getMonster(uint id) p", "debug": "The exception is triggered under the following conditions:\n\ncalldata_EthMonsters_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_EthMonsters_32_+_4: 0x0\ncalldata_EthMonsters_0: 0x984b7dc500000000000000000000000000000000000000000000000000000000\ncalldatasize_EthMonsters: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/EthMonsters-0.sol", "function": "getUserMonster(uint256,address)", "lineno": 170, "title": "Exception state", "type": "Informational"}, {"address": 6401, "code": "}\n\t\n\tfunction getMonster(uint id) pu", "debug": "The exception is triggered under the following conditions:\n\ncalldata_EthMonsters_4: 0x0\nstorage_keccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_EthMonsters_32_+_4 +\ncalldata_EthMonsters_4: 0x0\nstorage_5: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_EthMonsters_32_+_4: 0x1\ncalldata_EthMonsters_0: 0x984b7dc500000000000000000000000000000000000000000000000000000000\ncalldatasize_EthMonsters: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/EthMonsters-0.sol", "function": "getUserMonster(uint256,address)", "lineno": 168, "title": "Exception state", "type": "Informational"}, {"address": 7012, "code": "ce\n\t\t\tuserBa", "debug": "The exception is triggered under the following conditions:\n\ncalldata_EthMonsters_32 + 4: 0x0\nstorage_10: 0x0\nstorage_1: 0x1\ncalldata_EthMonsters_0: 0xae678cbb00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthMonsters: 0x4\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/EthMonsters-0.sol", "function": "buyMonster(string,uint256)", "lineno": 112, "title": "Exception state", "type": "Informational"}, {"address": 7108, "code": "price, \n\t\t\tuserBalance[msg.sender] +", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncallvalue: 0x57f25cd000000000000000000000000000000000000000000000000000000000\ncalldata_EthMonsters_32 + 4: 0x0\nstorage_1 +\n89717814153306320011181716697424560163256864414616650038987186496166826726056 +\n6*calldata_EthMonsters_32 + 4: 0x57f25cd000000000000000000000000000000000000000000000000000000001\nstorage_10: 0x1\nstorage_1: 0x1\ncalldata_EthMonsters_0: 0xae678cbb00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthMonsters: 0x4\n", "description": "A possible integer overflow exists in the function `buyMonster(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/EthMonsters-0.sol", "function": "buyMonster(string,uint256)", "lineno": 115, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7280, "code": "random(1, 3);\n\t\t\tfor(uint _i=0; _i<numberOfEggs; _i++)\n\t\t\t    crea", "debug": "storage_1 +\n89717814153306320011181716697424560163256864414616650038987186496166826726056 +\n6*calldata_EthMonsters_32 + 4: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfffffffff7fffffe7fffffefffdeffff00000000000000000000000000000000\ncallvalue: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_EthMonsters_32 + 4: 0x0\nstorage_10: 0x1\nstorage_1: 0x1\ncalldata_EthMonsters_0: 0xae678cbb00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthMonsters: 0x4\n", "description": "A possible integer overflow exists in the function `buyMonster(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/EthMonsters-0.sol", "function": "buyMonster(string,uint256)", "lineno": 118, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7676, "code": "c monsters;\n   \tmapping (", "debug": "The exception is triggered under the following conditions:\n\ncalldata_EthMonsters_4: 0x0\nstorage_5: 0x0\ncalldata_EthMonsters_0: 0xc0576b7300000000000000000000000000000000000000000000000000000000\ncalldatasize_EthMonsters: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/EthMonsters-0.sol", "function": "_function_0xc0576b73", "lineno": 16, "title": "Exception state", "type": "Informational"}, {"address": 10303, "code": "ntract EthMonsters {\n\n\taddress public owner;\n\n\n    event BuyMonsterEvent(\n        uint price\n    );\n\n\tuint public typesNumber = 0;\n\tuint public monstersNumber = 0;\n\tmapping (address => uint) public userMonstersCount;\n\tmapping (address => uint) goodContracts; \n    monster[] public monsters;\n   \tmapping (uint => address) public monsterToOwner;\n   \tmapping (address => uint) public userBalance;\n   \tmapping (address => uint[]) public userToMonsters;\n   \tuint public contractFees = 0;\n\t\n\tmonsterType[] public types;\n\n\tconstructor() public {\n      \towner = msg.sender;\n   \t}\n    \n\tmodifier onlyOwner { \n    \trequire(msg.sender == owner);\n    \t_;\n  \t}\n  \t\n  \tmodifier allowedContract { \n  \t    address contractAddress = msg.sender;\n  \t\trequire(goodContracts[contractAddress] == 1);\n  \t\t_;\n  \t}\n\n  \tstruct monsterType {\n  \t\tstring name;\n  \t\tuint currentPrice;\n  \t\tuint basePrice;\n  \t\tuint sales;\n  \t\tuint id;\n  \t\tuint maxPower;\n   \t}\n   \t\n   \tstruct monster {\n  \t\tstring name;\n  \t\tuint purchasePrice;\n  \t\tuint earnings;\n  \t\tuint monsterType;\n  \t\tuint id;\n  \t\tuint power;\n  \t\tuint exp;\n  \t\tuint eggs;\n  \t\tuint gen;\n  \t\taddress creator;\n  \t\taddress owner;\n  \t\tuint isEgg;\n   \t}\n\n    function random(uint min, uint max) private view returns (uint) {\n        return uint8(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty)))%(max-min+1))+min;\n    }\n    \n    function addGoodContract(address _con) public onlyOwner { //add address of a contract to be whitelisted\n\t\tgoodContracts[_con] = 1;\n\t}\n\n\tfunction removeGoodContract(address _con) public onlyOwner { //remove address of a contract from whitelist\n\t\tgoodContracts[_con] = 0;\n\t}\n\t\n\tfunction addExpToMonster(uint _id, uint amount) public allowedContract {\n\t    monsters[_id].exp += amount;\n\t}\n\t\n\tfunction transferMonster(uint _id, address newOwner) public allowedContract {\n\t    address oldOwner = monsterToOwner[_id];\n\t    uint[] memory oldUserMonsters = userToMonsters[oldOwner];\n\t    for(uint i=0; i<userMonstersCount[oldOwner]; i++) {\n\t        if(oldUserMonsters[i] == _id) {\n\t            oldUserMonsters[i] = oldUserMonsters[oldUserMonsters.length-1];\n\t            delete oldUserMonsters[oldUserMonsters.length-1];\n\t            userToMonsters[oldOwner] = oldUserMonsters;\n\t            userToMonsters[oldOwner].length--;\n\t            userToMonsters[newOwner].push(_id);\n\t            break;\n\t        }\n\t    }\n\t    userMonstersCount[oldOwner]--;\n\t    userMonstersCount[newOwner]++;\n\t    monsters[_id].owner = newOwner;\n\t    monsterToOwner[_id] = newOwner;\n\t}\n\t\n\tfunction hatchEgg(uint _id, uint _newPower) public allowedContract {\n\t    require(monsters[_id].isEgg == 1);\n\t    monsters[_id].isEgg = 0;\n\t    monsters[_id].power = _newPower;\n\t}\n\t\n\tfunction changeMonsterName(string _newName, uint _id) public allowedContract {\n\t    monsters[_id].name = _newName;\n\t}\n\n\t\n    function buyMonster(string _name, uint _type) public payable { //starts with 0; public function to buy a monsters \n\t\trequire(_type < typesNumber);\n\t\trequire(_type >= 0);\n\t\tif(msg.value < types[_type].currentPrice) { //if sent amount < the monster's price, the amount is added to the address's balance\n\t\t\tuserBalance[msg.sender] += msg.value;\n\t\t\temit BuyMonsterEvent(0);\n\t\t} else { //if the sent amount >= the kind's price, \n\t\t\tuserBalance[msg.sender] += (msg.value - types[_type].currentPrice);\n\t\t\tsendEarnings(_type);\n\t\t\tuint numberOfEggs = random(1, 3);\n\t\t\tfor(uint _i=0; _i<numberOfEggs; _i++)\n\t\t\t    createMonster(_name, _type, 1, msg.sender, 100, 0, 1);\n\t\t\tcreateMonster(_name, _type, 0, msg.sender, types[_type].maxPower, types[_type].currentPrice, 0);\n\t\t\temit BuyMonsterEvent(types[_type].currentPrice);\n\t\t\ttypes[_type].currentPrice += types[_type].basePrice;\n\t\t}\n\t\ttypes[_type].sales++;\n\t}\n\t\n\tfunction sendEarnings(uint _type) private { \n\t\trequire(_type < typesNumber);\n\t\trequire(_type >= 0);\n\t\tcontractFees += types[_type].basePrice;\n\t\tfor(uint _id=0; _id<monsters.length; _id++)\n \t\t\tif(monsters[_id].monsterType == _type && monsters[_id].gen == 0) {\n \t\t\t\tuserBalance[monsterToOwner[_id]] += types[_type].basePrice;\n \t\t\t\tmonsters[_id].earnings += types[_type].basePrice;\n \t\t\t}\n\t}\n\t\n\tfunction withdrawFees() public onlyOwner payable {\n\t    require(contractFees > 0);\n\t    uint amount = contractFees;\n\t    contractFees = 0;\n\t    msg.sender.transfer(amount);\n\t}\n\t\n\tfunction withdraw() public payable{\n\t    require(userBalance[msg.sender] > 0);\n\t    uint amount = userBalance[msg.sender];\n\t    userBalance[msg.sender] = 0;\n\t    msg.sender.transfer(amount);\n\t}\n\t\n    function createMonster(string _name, uint _type, uint _gen, address _owner, uint _power, uint _purchasePrice, uint _isEgg) private { \n\t\tmonsters.push(monster(_name, _purchasePrice, 0, _type, monstersNumber, _power, 0, 0 ,_gen ,_owner, _owner, _isEgg));\n\t\tmonsterToOwner[monstersNumber] = _owner;\n\t\tuserToMonsters[_owner].push(monstersNumber);\n\t\tmonstersNumber++;\n\t\tuserMonstersCount[_owner]++;\n\t}\n\t\n\tfunction getUserMonstersCount(address _address) public view returns(uint) {\n\t    return userMonstersCount[_address];\n\t}\n\t\n\tfunction getUserMonster(uint id, address _owner) public view returns (string, uint, uint, uint, uint, uint, uint, address, address) {\n\t    monster memory mon = monsters[userToMonsters[_owner][id]];\n\t\treturn (mon.name, mon.purchasePrice, mon.earnings, mon.gen, mon.monsterType, mon.power, mon.isEgg, mon.creator, mon.owner);\n\t}\n\t\n\tfunction getMonster(uint id) public view returns (string, uint, uint, uint, uint, uint, uint, address, address) {\n\t    monster memory mon = monsters[id];\n\t\treturn (mon.name, mon.purchasePrice, mon.earnings, mon.gen, mon.monsterType, mon.power, mon.isEgg, mon.creator, mon.owner);\n\t} \n\t\n   \tfunction addNewType(string _name, uint _basePrice, uint _maxPower) public onlyOwner { //add new kind\n\t\trequire(_maxPower > 0);\n\t\ttypes.push(monsterType(_name, _basePrice, _basePrice, 0, typesNumber, _maxPower));\n\t\ttypesNumber++;\n\t}\n\n\tfunction getType(uint id) public view returns (string, uint, uint, uint, uint, uint) {\n\t\treturn (types[id].name, types[id].currentPrice, types[id].basePrice, types[id].sales, types[id].id, types[id].maxPower);\n\t} \n}", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_calldata_EthMonsters_4,_256): 0x77fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_calldata_EthMonsters_4,_256): 0x8f9de864e46000bfa536e1ffffe74c8114800400c84823c00000000000000000\ncalldata_EthMonsters_0: 0x1d30ffca00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthMonsters: 0x4\ncalldata_EthMonsters_4: 0x0\nstorage_keccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_calldata_EthMonsters_4,_256): 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferMonster(uint256,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/EthMonsters-0.sol", "function": "transferMonster(uint256,address)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 10314, "code": "ntract EthMonsters {\n\n\taddress public owner;\n\n\n    event BuyMonsterEvent(\n        uint price\n    );\n\n\tuint public typesNumber = 0;\n\tuint public monstersNumber = 0;\n\tmapping (address => uint) public userMonstersCount;\n\tmapping (address => uint) goodContracts; \n    monster[] public monsters;\n   \tmapping (uint => address) public monsterToOwner;\n   \tmapping (address => uint) public userBalance;\n   \tmapping (address => uint[]) public userToMonsters;\n   \tuint public contractFees = 0;\n\t\n\tmonsterType[] public types;\n\n\tconstructor() public {\n      \towner = msg.sender;\n   \t}\n    \n\tmodifier onlyOwner { \n    \trequire(msg.sender == owner);\n    \t_;\n  \t}\n  \t\n  \tmodifier allowedContract { \n  \t    address contractAddress = msg.sender;\n  \t\trequire(goodContracts[contractAddress] == 1);\n  \t\t_;\n  \t}\n\n  \tstruct monsterType {\n  \t\tstring name;\n  \t\tuint currentPrice;\n  \t\tuint basePrice;\n  \t\tuint sales;\n  \t\tuint id;\n  \t\tuint maxPower;\n   \t}\n   \t\n   \tstruct monster {\n  \t\tstring name;\n  \t\tuint purchasePrice;\n  \t\tuint earnings;\n  \t\tuint monsterType;\n  \t\tuint id;\n  \t\tuint power;\n  \t\tuint exp;\n  \t\tuint eggs;\n  \t\tuint gen;\n  \t\taddress creator;\n  \t\taddress owner;\n  \t\tuint isEgg;\n   \t}\n\n    function random(uint min, uint max) private view returns (uint) {\n        return uint8(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty)))%(max-min+1))+min;\n    }\n    \n    function addGoodContract(address _con) public onlyOwner { //add address of a contract to be whitelisted\n\t\tgoodContracts[_con] = 1;\n\t}\n\n\tfunction removeGoodContract(address _con) public onlyOwner { //remove address of a contract from whitelist\n\t\tgoodContracts[_con] = 0;\n\t}\n\t\n\tfunction addExpToMonster(uint _id, uint amount) public allowedContract {\n\t    monsters[_id].exp += amount;\n\t}\n\t\n\tfunction transferMonster(uint _id, address newOwner) public allowedContract {\n\t    address oldOwner = monsterToOwner[_id];\n\t    uint[] memory oldUserMonsters = userToMonsters[oldOwner];\n\t    for(uint i=0; i<userMonstersCount[oldOwner]; i++) {\n\t        if(oldUserMonsters[i] == _id) {\n\t            oldUserMonsters[i] = oldUserMonsters[oldUserMonsters.length-1];\n\t            delete oldUserMonsters[oldUserMonsters.length-1];\n\t            userToMonsters[oldOwner] = oldUserMonsters;\n\t            userToMonsters[oldOwner].length--;\n\t            userToMonsters[newOwner].push(_id);\n\t            break;\n\t        }\n\t    }\n\t    userMonstersCount[oldOwner]--;\n\t    userMonstersCount[newOwner]++;\n\t    monsters[_id].owner = newOwner;\n\t    monsterToOwner[_id] = newOwner;\n\t}\n\t\n\tfunction hatchEgg(uint _id, uint _newPower) public allowedContract {\n\t    require(monsters[_id].isEgg == 1);\n\t    monsters[_id].isEgg = 0;\n\t    monsters[_id].power = _newPower;\n\t}\n\t\n\tfunction changeMonsterName(string _newName, uint _id) public allowedContract {\n\t    monsters[_id].name = _newName;\n\t}\n\n\t\n    function buyMonster(string _name, uint _type) public payable { //starts with 0; public function to buy a monsters \n\t\trequire(_type < typesNumber);\n\t\trequire(_type >= 0);\n\t\tif(msg.value < types[_type].currentPrice) { //if sent amount < the monster's price, the amount is added to the address's balance\n\t\t\tuserBalance[msg.sender] += msg.value;\n\t\t\temit BuyMonsterEvent(0);\n\t\t} else { //if the sent amount >= the kind's price, \n\t\t\tuserBalance[msg.sender] += (msg.value - types[_type].currentPrice);\n\t\t\tsendEarnings(_type);\n\t\t\tuint numberOfEggs = random(1, 3);\n\t\t\tfor(uint _i=0; _i<numberOfEggs; _i++)\n\t\t\t    createMonster(_name, _type, 1, msg.sender, 100, 0, 1);\n\t\t\tcreateMonster(_name, _type, 0, msg.sender, types[_type].maxPower, types[_type].currentPrice, 0);\n\t\t\temit BuyMonsterEvent(types[_type].currentPrice);\n\t\t\ttypes[_type].currentPrice += types[_type].basePrice;\n\t\t}\n\t\ttypes[_type].sales++;\n\t}\n\t\n\tfunction sendEarnings(uint _type) private { \n\t\trequire(_type < typesNumber);\n\t\trequire(_type >= 0);\n\t\tcontractFees += types[_type].basePrice;\n\t\tfor(uint _id=0; _id<monsters.length; _id++)\n \t\t\tif(monsters[_id].monsterType == _type && monsters[_id].gen == 0) {\n \t\t\t\tuserBalance[monsterToOwner[_id]] += types[_type].basePrice;\n \t\t\t\tmonsters[_id].earnings += types[_type].basePrice;\n \t\t\t}\n\t}\n\t\n\tfunction withdrawFees() public onlyOwner payable {\n\t    require(contractFees > 0);\n\t    uint amount = contractFees;\n\t    contractFees = 0;\n\t    msg.sender.transfer(amount);\n\t}\n\t\n\tfunction withdraw() public payable{\n\t    require(userBalance[msg.sender] > 0);\n\t    uint amount = userBalance[msg.sender];\n\t    userBalance[msg.sender] = 0;\n\t    msg.sender.transfer(amount);\n\t}\n\t\n    function createMonster(string _name, uint _type, uint _gen, address _owner, uint _power, uint _purchasePrice, uint _isEgg) private { \n\t\tmonsters.push(monster(_name, _purchasePrice, 0, _type, monstersNumber, _power, 0, 0 ,_gen ,_owner, _owner, _isEgg));\n\t\tmonsterToOwner[monstersNumber] = _owner;\n\t\tuserToMonsters[_owner].push(monstersNumber);\n\t\tmonstersNumber++;\n\t\tuserMonstersCount[_owner]++;\n\t}\n\t\n\tfunction getUserMonstersCount(address _address) public view returns(uint) {\n\t    return userMonstersCount[_address];\n\t}\n\t\n\tfunction getUserMonster(uint id, address _owner) public view returns (string, uint, uint, uint, uint, uint, uint, address, address) {\n\t    monster memory mon = monsters[userToMonsters[_owner][id]];\n\t\treturn (mon.name, mon.purchasePrice, mon.earnings, mon.gen, mon.monsterType, mon.power, mon.isEgg, mon.creator, mon.owner);\n\t}\n\t\n\tfunction getMonster(uint id) public view returns (string, uint, uint, uint, uint, uint, uint, address, address) {\n\t    monster memory mon = monsters[id];\n\t\treturn (mon.name, mon.purchasePrice, mon.earnings, mon.gen, mon.monsterType, mon.power, mon.isEgg, mon.creator, mon.owner);\n\t} \n\t\n   \tfunction addNewType(string _name, uint _basePrice, uint _maxPower) public onlyOwner { //add new kind\n\t\trequire(_maxPower > 0);\n\t\ttypes.push(monsterType(_name, _basePrice, _basePrice, 0, typesNumber, _maxPower));\n\t\ttypesNumber++;\n\t}\n\n\tfunction getType(uint id) public view returns (string, uint, uint, uint, uint, uint) {\n\t\treturn (types[id].name, types[id].currentPrice, types[id].basePrice, types[id].sales, types[id].id, types[id].maxPower);\n\t} \n}", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_calldata_EthMonsters_4,_256): 0xf800000000000000000000000000000000000000000000000000000000000000\ncalldata_EthMonsters_0: 0x1d30ffca00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthMonsters: 0x4\ncalldata_EthMonsters_4: 0x0\nstorage_keccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_calldata_EthMonsters_4,_256): 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferMonster(uint256,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/EthMonsters-0.sol", "function": "transferMonster(uint256,address)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 10316, "code": "ntract EthMonsters {\n\n\taddress public owner;\n\n\n    event BuyMonsterEvent(\n        uint price\n    );\n\n\tuint public typesNumber = 0;\n\tuint public monstersNumber = 0;\n\tmapping (address => uint) public userMonstersCount;\n\tmapping (address => uint) goodContracts; \n    monster[] public monsters;\n   \tmapping (uint => address) public monsterToOwner;\n   \tmapping (address => uint) public userBalance;\n   \tmapping (address => uint[]) public userToMonsters;\n   \tuint public contractFees = 0;\n\t\n\tmonsterType[] public types;\n\n\tconstructor() public {\n      \towner = msg.sender;\n   \t}\n    \n\tmodifier onlyOwner { \n    \trequire(msg.sender == owner);\n    \t_;\n  \t}\n  \t\n  \tmodifier allowedContract { \n  \t    address contractAddress = msg.sender;\n  \t\trequire(goodContracts[contractAddress] == 1);\n  \t\t_;\n  \t}\n\n  \tstruct monsterType {\n  \t\tstring name;\n  \t\tuint currentPrice;\n  \t\tuint basePrice;\n  \t\tuint sales;\n  \t\tuint id;\n  \t\tuint maxPower;\n   \t}\n   \t\n   \tstruct monster {\n  \t\tstring name;\n  \t\tuint purchasePrice;\n  \t\tuint earnings;\n  \t\tuint monsterType;\n  \t\tuint id;\n  \t\tuint power;\n  \t\tuint exp;\n  \t\tuint eggs;\n  \t\tuint gen;\n  \t\taddress creator;\n  \t\taddress owner;\n  \t\tuint isEgg;\n   \t}\n\n    function random(uint min, uint max) private view returns (uint) {\n        return uint8(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty)))%(max-min+1))+min;\n    }\n    \n    function addGoodContract(address _con) public onlyOwner { //add address of a contract to be whitelisted\n\t\tgoodContracts[_con] = 1;\n\t}\n\n\tfunction removeGoodContract(address _con) public onlyOwner { //remove address of a contract from whitelist\n\t\tgoodContracts[_con] = 0;\n\t}\n\t\n\tfunction addExpToMonster(uint _id, uint amount) public allowedContract {\n\t    monsters[_id].exp += amount;\n\t}\n\t\n\tfunction transferMonster(uint _id, address newOwner) public allowedContract {\n\t    address oldOwner = monsterToOwner[_id];\n\t    uint[] memory oldUserMonsters = userToMonsters[oldOwner];\n\t    for(uint i=0; i<userMonstersCount[oldOwner]; i++) {\n\t        if(oldUserMonsters[i] == _id) {\n\t            oldUserMonsters[i] = oldUserMonsters[oldUserMonsters.length-1];\n\t            delete oldUserMonsters[oldUserMonsters.length-1];\n\t            userToMonsters[oldOwner] = oldUserMonsters;\n\t            userToMonsters[oldOwner].length--;\n\t            userToMonsters[newOwner].push(_id);\n\t            break;\n\t        }\n\t    }\n\t    userMonstersCount[oldOwner]--;\n\t    userMonstersCount[newOwner]++;\n\t    monsters[_id].owner = newOwner;\n\t    monsterToOwner[_id] = newOwner;\n\t}\n\t\n\tfunction hatchEgg(uint _id, uint _newPower) public allowedContract {\n\t    require(monsters[_id].isEgg == 1);\n\t    monsters[_id].isEgg = 0;\n\t    monsters[_id].power = _newPower;\n\t}\n\t\n\tfunction changeMonsterName(string _newName, uint _id) public allowedContract {\n\t    monsters[_id].name = _newName;\n\t}\n\n\t\n    function buyMonster(string _name, uint _type) public payable { //starts with 0; public function to buy a monsters \n\t\trequire(_type < typesNumber);\n\t\trequire(_type >= 0);\n\t\tif(msg.value < types[_type].currentPrice) { //if sent amount < the monster's price, the amount is added to the address's balance\n\t\t\tuserBalance[msg.sender] += msg.value;\n\t\t\temit BuyMonsterEvent(0);\n\t\t} else { //if the sent amount >= the kind's price, \n\t\t\tuserBalance[msg.sender] += (msg.value - types[_type].currentPrice);\n\t\t\tsendEarnings(_type);\n\t\t\tuint numberOfEggs = random(1, 3);\n\t\t\tfor(uint _i=0; _i<numberOfEggs; _i++)\n\t\t\t    createMonster(_name, _type, 1, msg.sender, 100, 0, 1);\n\t\t\tcreateMonster(_name, _type, 0, msg.sender, types[_type].maxPower, types[_type].currentPrice, 0);\n\t\t\temit BuyMonsterEvent(types[_type].currentPrice);\n\t\t\ttypes[_type].currentPrice += types[_type].basePrice;\n\t\t}\n\t\ttypes[_type].sales++;\n\t}\n\t\n\tfunction sendEarnings(uint _type) private { \n\t\trequire(_type < typesNumber);\n\t\trequire(_type >= 0);\n\t\tcontractFees += types[_type].basePrice;\n\t\tfor(uint _id=0; _id<monsters.length; _id++)\n \t\t\tif(monsters[_id].monsterType == _type && monsters[_id].gen == 0) {\n \t\t\t\tuserBalance[monsterToOwner[_id]] += types[_type].basePrice;\n \t\t\t\tmonsters[_id].earnings += types[_type].basePrice;\n \t\t\t}\n\t}\n\t\n\tfunction withdrawFees() public onlyOwner payable {\n\t    require(contractFees > 0);\n\t    uint amount = contractFees;\n\t    contractFees = 0;\n\t    msg.sender.transfer(amount);\n\t}\n\t\n\tfunction withdraw() public payable{\n\t    require(userBalance[msg.sender] > 0);\n\t    uint amount = userBalance[msg.sender];\n\t    userBalance[msg.sender] = 0;\n\t    msg.sender.transfer(amount);\n\t}\n\t\n    function createMonster(string _name, uint _type, uint _gen, address _owner, uint _power, uint _purchasePrice, uint _isEgg) private { \n\t\tmonsters.push(monster(_name, _purchasePrice, 0, _type, monstersNumber, _power, 0, 0 ,_gen ,_owner, _owner, _isEgg));\n\t\tmonsterToOwner[monstersNumber] = _owner;\n\t\tuserToMonsters[_owner].push(monstersNumber);\n\t\tmonstersNumber++;\n\t\tuserMonstersCount[_owner]++;\n\t}\n\t\n\tfunction getUserMonstersCount(address _address) public view returns(uint) {\n\t    return userMonstersCount[_address];\n\t}\n\t\n\tfunction getUserMonster(uint id, address _owner) public view returns (string, uint, uint, uint, uint, uint, uint, address, address) {\n\t    monster memory mon = monsters[userToMonsters[_owner][id]];\n\t\treturn (mon.name, mon.purchasePrice, mon.earnings, mon.gen, mon.monsterType, mon.power, mon.isEgg, mon.creator, mon.owner);\n\t}\n\t\n\tfunction getMonster(uint id) public view returns (string, uint, uint, uint, uint, uint, uint, address, address) {\n\t    monster memory mon = monsters[id];\n\t\treturn (mon.name, mon.purchasePrice, mon.earnings, mon.gen, mon.monsterType, mon.power, mon.isEgg, mon.creator, mon.owner);\n\t} \n\t\n   \tfunction addNewType(string _name, uint _basePrice, uint _maxPower) public onlyOwner { //add new kind\n\t\trequire(_maxPower > 0);\n\t\ttypes.push(monsterType(_name, _basePrice, _basePrice, 0, typesNumber, _maxPower));\n\t\ttypesNumber++;\n\t}\n\n\tfunction getType(uint id) public view returns (string, uint, uint, uint, uint, uint) {\n\t\treturn (types[id].name, types[id].currentPrice, types[id].basePrice, types[id].sales, types[id].id, types[id].maxPower);\n\t} \n}", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_calldata_EthMonsters_4,_256): 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_EthMonsters_0: 0x1d30ffca00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthMonsters: 0x4\ncalldata_EthMonsters_4: 0x0\nstorage_keccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_calldata_EthMonsters_4,_256): 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferMonster(uint256,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/EthMonsters-0.sol", "function": "transferMonster(uint256,address)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 10338, "code": "ntract EthMonsters {\n\n\taddress public owner;\n\n\n    event BuyMonsterEvent(\n        uint price\n    );\n\n\tuint public typesNumber = 0;\n\tuint public monstersNumber = 0;\n\tmapping (address => uint) public userMonstersCount;\n\tmapping (address => uint) goodContracts; \n    monster[] public monsters;\n   \tmapping (uint => address) public monsterToOwner;\n   \tmapping (address => uint) public userBalance;\n   \tmapping (address => uint[]) public userToMonsters;\n   \tuint public contractFees = 0;\n\t\n\tmonsterType[] public types;\n\n\tconstructor() public {\n      \towner = msg.sender;\n   \t}\n    \n\tmodifier onlyOwner { \n    \trequire(msg.sender == owner);\n    \t_;\n  \t}\n  \t\n  \tmodifier allowedContract { \n  \t    address contractAddress = msg.sender;\n  \t\trequire(goodContracts[contractAddress] == 1);\n  \t\t_;\n  \t}\n\n  \tstruct monsterType {\n  \t\tstring name;\n  \t\tuint currentPrice;\n  \t\tuint basePrice;\n  \t\tuint sales;\n  \t\tuint id;\n  \t\tuint maxPower;\n   \t}\n   \t\n   \tstruct monster {\n  \t\tstring name;\n  \t\tuint purchasePrice;\n  \t\tuint earnings;\n  \t\tuint monsterType;\n  \t\tuint id;\n  \t\tuint power;\n  \t\tuint exp;\n  \t\tuint eggs;\n  \t\tuint gen;\n  \t\taddress creator;\n  \t\taddress owner;\n  \t\tuint isEgg;\n   \t}\n\n    function random(uint min, uint max) private view returns (uint) {\n        return uint8(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty)))%(max-min+1))+min;\n    }\n    \n    function addGoodContract(address _con) public onlyOwner { //add address of a contract to be whitelisted\n\t\tgoodContracts[_con] = 1;\n\t}\n\n\tfunction removeGoodContract(address _con) public onlyOwner { //remove address of a contract from whitelist\n\t\tgoodContracts[_con] = 0;\n\t}\n\t\n\tfunction addExpToMonster(uint _id, uint amount) public allowedContract {\n\t    monsters[_id].exp += amount;\n\t}\n\t\n\tfunction transferMonster(uint _id, address newOwner) public allowedContract {\n\t    address oldOwner = monsterToOwner[_id];\n\t    uint[] memory oldUserMonsters = userToMonsters[oldOwner];\n\t    for(uint i=0; i<userMonstersCount[oldOwner]; i++) {\n\t        if(oldUserMonsters[i] == _id) {\n\t            oldUserMonsters[i] = oldUserMonsters[oldUserMonsters.length-1];\n\t            delete oldUserMonsters[oldUserMonsters.length-1];\n\t            userToMonsters[oldOwner] = oldUserMonsters;\n\t            userToMonsters[oldOwner].length--;\n\t            userToMonsters[newOwner].push(_id);\n\t            break;\n\t        }\n\t    }\n\t    userMonstersCount[oldOwner]--;\n\t    userMonstersCount[newOwner]++;\n\t    monsters[_id].owner = newOwner;\n\t    monsterToOwner[_id] = newOwner;\n\t}\n\t\n\tfunction hatchEgg(uint _id, uint _newPower) public allowedContract {\n\t    require(monsters[_id].isEgg == 1);\n\t    monsters[_id].isEgg = 0;\n\t    monsters[_id].power = _newPower;\n\t}\n\t\n\tfunction changeMonsterName(string _newName, uint _id) public allowedContract {\n\t    monsters[_id].name = _newName;\n\t}\n\n\t\n    function buyMonster(string _name, uint _type) public payable { //starts with 0; public function to buy a monsters \n\t\trequire(_type < typesNumber);\n\t\trequire(_type >= 0);\n\t\tif(msg.value < types[_type].currentPrice) { //if sent amount < the monster's price, the amount is added to the address's balance\n\t\t\tuserBalance[msg.sender] += msg.value;\n\t\t\temit BuyMonsterEvent(0);\n\t\t} else { //if the sent amount >= the kind's price, \n\t\t\tuserBalance[msg.sender] += (msg.value - types[_type].currentPrice);\n\t\t\tsendEarnings(_type);\n\t\t\tuint numberOfEggs = random(1, 3);\n\t\t\tfor(uint _i=0; _i<numberOfEggs; _i++)\n\t\t\t    createMonster(_name, _type, 1, msg.sender, 100, 0, 1);\n\t\t\tcreateMonster(_name, _type, 0, msg.sender, types[_type].maxPower, types[_type].currentPrice, 0);\n\t\t\temit BuyMonsterEvent(types[_type].currentPrice);\n\t\t\ttypes[_type].currentPrice += types[_type].basePrice;\n\t\t}\n\t\ttypes[_type].sales++;\n\t}\n\t\n\tfunction sendEarnings(uint _type) private { \n\t\trequire(_type < typesNumber);\n\t\trequire(_type >= 0);\n\t\tcontractFees += types[_type].basePrice;\n\t\tfor(uint _id=0; _id<monsters.length; _id++)\n \t\t\tif(monsters[_id].monsterType == _type && monsters[_id].gen == 0) {\n \t\t\t\tuserBalance[monsterToOwner[_id]] += types[_type].basePrice;\n \t\t\t\tmonsters[_id].earnings += types[_type].basePrice;\n \t\t\t}\n\t}\n\t\n\tfunction withdrawFees() public onlyOwner payable {\n\t    require(contractFees > 0);\n\t    uint amount = contractFees;\n\t    contractFees = 0;\n\t    msg.sender.transfer(amount);\n\t}\n\t\n\tfunction withdraw() public payable{\n\t    require(userBalance[msg.sender] > 0);\n\t    uint amount = userBalance[msg.sender];\n\t    userBalance[msg.sender] = 0;\n\t    msg.sender.transfer(amount);\n\t}\n\t\n    function createMonster(string _name, uint _type, uint _gen, address _owner, uint _power, uint _purchasePrice, uint _isEgg) private { \n\t\tmonsters.push(monster(_name, _purchasePrice, 0, _type, monstersNumber, _power, 0, 0 ,_gen ,_owner, _owner, _isEgg));\n\t\tmonsterToOwner[monstersNumber] = _owner;\n\t\tuserToMonsters[_owner].push(monstersNumber);\n\t\tmonstersNumber++;\n\t\tuserMonstersCount[_owner]++;\n\t}\n\t\n\tfunction getUserMonstersCount(address _address) public view returns(uint) {\n\t    return userMonstersCount[_address];\n\t}\n\t\n\tfunction getUserMonster(uint id, address _owner) public view returns (string, uint, uint, uint, uint, uint, uint, address, address) {\n\t    monster memory mon = monsters[userToMonsters[_owner][id]];\n\t\treturn (mon.name, mon.purchasePrice, mon.earnings, mon.gen, mon.monsterType, mon.power, mon.isEgg, mon.creator, mon.owner);\n\t}\n\t\n\tfunction getMonster(uint id) public view returns (string, uint, uint, uint, uint, uint, uint, address, address) {\n\t    monster memory mon = monsters[id];\n\t\treturn (mon.name, mon.purchasePrice, mon.earnings, mon.gen, mon.monsterType, mon.power, mon.isEgg, mon.creator, mon.owner);\n\t} \n\t\n   \tfunction addNewType(string _name, uint _basePrice, uint _maxPower) public onlyOwner { //add new kind\n\t\trequire(_maxPower > 0);\n\t\ttypes.push(monsterType(_name, _basePrice, _basePrice, 0, typesNumber, _maxPower));\n\t\ttypesNumber++;\n\t}\n\n\tfunction getType(uint id) public view returns (string, uint, uint, uint, uint, uint) {\n\t\treturn (types[id].name, types[id].currentPrice, types[id].basePrice, types[id].sales, types[id].id, types[id].maxPower);\n\t} \n}", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_calldata_EthMonsters_4,_256): 0x1\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_calldata_EthMonsters_4,_256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_EthMonsters_0: 0x1d30ffca00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthMonsters: 0x4\ncalldata_EthMonsters_4: 0x0\nstorage_keccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_calldata_EthMonsters_4,_256): 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferMonster(uint256,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/EthMonsters-0.sol", "function": "transferMonster(uint256,address)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}], "success": true}
