{"error": null, "issues": [{"address": 524, "code": "&& ranks[ranksCount].priceEth <= _priceEth);\n        ranksCount++;\n        Rank storage r = ranks[ranksCount];\n\n        r.landLimit = _landLimit;\n        r.priceCandy = _priceCandy;\n        r.priceEth = _priceEth;\n        r.title = _title;\n        emit NewRankAdded(ranksCount, _landLimit,_title,_priceCandy,_priceEth);\n    }\n\n\n    function editRank(uint _index, uint _priceCandy, uint _priceEth) onlyManager public  {\n        require(_index > 0 && _index <= ranksCount);\n        if (_index > 1) {\n            require(ranks[_index - 1].priceCandy <= _priceCandy && ranks[_index - 1].priceEth <= _priceEth);\n     ", "debug": "calldata_UserRank_32 + 68: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_UserRank_0: 0x37e822b800000000000000000000000000000000000000000000000000000000\ncalldatasize_UserRank: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `addRank(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/UnicornGO-13.sol", "function": "addRank(uint256,uint256,uint256,string)", "lineno": 231, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2253, "code": "function bytesToBytes4(bytes b) internal pur", "debug": "The exception is triggered under the following conditions:\n\ncalldatasize_UserRank: 0x20\ncaller: 0x0\ncalldata_UserRank_0: 0x3fba44400000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/UnicornGO-13.sol", "function": "_receiveBuyNextRank(address)", "lineno": 169, "title": "Exception state", "type": "Informational"}, {"address": 2403, "code": "g (bytes4 => bool) allo", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/temp/UnicornGO-13.sol", "function": "isGamePaused()", "lineno": 156, "title": "Message call to external contract", "type": "Informational"}, {"address": 2578, "code": "sg.sender == landManagement.m", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/temp/UnicornGO-13.sol", "function": "addRank(uint256,uint256,uint256,string)", "lineno": 102, "title": "Message call to external contract", "type": "Informational"}, {"address": 2744, "code": "function edi", "debug": "storage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_UserRank_32 + 36: 0x0\ncalldata_UserRank_32 + 4: 0x0\nstorage_2 + keccac_storage_4: 0x0\nstorage_1 + keccac_storage_4: 0x0\nmem_96 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_UserRank_4 + calldata_UserRank_32 + 68)): 0x0\ncaller: 0x0\nretval_2578: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_UserRank_0: 0x37e822b800000000000000000000000000000000000000000000000000000000\ncalldatasize_UserRank: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `addRank(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/UnicornGO-13.sol", "function": "addRank(uint256,uint256,uint256,string)", "lineno": 243, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2748, "code": "function edi", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/temp/UnicornGO-13.sol", "function": "addRank(uint256,uint256,uint256,string)", "lineno": 243, "title": "State change after external call", "type": "Warning"}, {"address": 2780, "code": "anager public  {\n       ", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/temp/UnicornGO-13.sol", "function": "addRank(uint256,uint256,uint256,string)", "lineno": 243, "title": "State change after external call", "type": "Warning"}, {"address": 2789, "code": "ndex > 0 && _index <= rank", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/temp/UnicornGO-13.sol", "function": "addRank(uint256,uint256,uint256,string)", "lineno": 244, "title": "State change after external call", "type": "Warning"}, {"address": 2798, "code": "      if (_index > 1) ", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/temp/UnicornGO-13.sol", "function": "addRank(uint256,uint256,uint256,string)", "lineno": 245, "title": "State change after external call", "type": "Warning"}, {"address": 3274, "code": "g.sender == landManagement.comm", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/temp/UnicornGO-13.sol", "function": "getPreSaleRank(address,uint256)", "lineno": 107, "title": "Message call to external contract", "type": "Informational"}, {"address": 3274, "code": "g.sender == landManagement.comm", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 3486\n", "filename": "/temp/UnicornGO-13.sol", "function": "getPreSaleRank(address,uint256)", "lineno": 107, "title": "Multiple Calls", "type": "Information"}, {"address": 3486, "code": "ed();\n    }\n}\n\n\ncontract Can", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/temp/UnicornGO-13.sol", "function": "getPreSaleRank(address,uint256)", "lineno": 148, "title": "Message call to external contract", "type": "Informational"}, {"address": 3679, "code": " }\n\n\n    function getRank", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/temp/UnicornGO-13.sol", "function": "getPreSaleRank(address,uint256)", "lineno": 312, "title": "State change after external call", "type": "Warning"}, {"address": 3965, "code": "g.sender == landManagement.comm", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/temp/UnicornGO-13.sol", "function": "withdrawTokens()", "lineno": 107, "title": "Message call to external contract", "type": "Informational"}, {"address": 3965, "code": "g.sender == landManagement.comm", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 4675\nCall at address: 4464\nCall at address: 4235\n", "filename": "/temp/UnicornGO-13.sol", "function": "withdrawTokens()", "lineno": 107, "title": "Multiple Calls", "type": "Information"}, {"address": 4235, "code": "ss(candyToken));\n        r", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/temp/UnicornGO-13.sol", "function": "withdrawTokens()", "lineno": 379, "title": "Message call to external contract", "type": "Informational"}, {"address": 4235, "code": "ss(candyToken));\n        r", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 4675\nCall at address: 4464\n", "filename": "/temp/UnicornGO-13.sol", "function": "withdrawTokens()", "lineno": 379, "title": "Multiple Calls", "type": "Information"}, {"address": 4464, "code": "xtraData)]);\n        require(a", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/temp/UnicornGO-13.sol", "function": "withdrawTokens()", "lineno": 380, "title": "Message call to external contract", "type": "Informational"}, {"address": 4464, "code": "xtraData)]);\n        require(a", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 4675\n", "filename": "/temp/UnicornGO-13.sol", "function": "withdrawTokens()", "lineno": 380, "title": "Multiple Calls", "type": "Information"}, {"address": 4675, "code": "ress(this).call(_extraData", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/temp/UnicornGO-13.sol", "function": "withdrawTokens()", "lineno": 381, "title": "Message call to external contract", "type": "Informational"}, {"address": 6010, "code": "g.sender == landManagement.comm", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/temp/UnicornGO-13.sol", "function": "editRank(uint256,uint256,uint256)", "lineno": 107, "title": "Message call to external contract", "type": "Informational"}, {"address": 6901, "code": "ss(landManagement.candyLandAddress()));\n    ", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/temp/UnicornGO-13.sol", "function": "getNextRank(address)", "lineno": 137, "title": "Message call to external contract", "type": "Informational"}, {"address": 8632, "code": "        require(_index <= r", "debug": "calldatasize_UserRank: 0x24\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_UserRank_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncaller: 0x0\ncalldata_UserRank_0: 0x3fba44400000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_receiveBuyNextRank(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/UnicornGO-13.sol", "function": "_receiveBuyNextRank(address)", "lineno": 286, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8923, "code": ";\n\n        uint fullPrice = _getPrice(userRanks[_beneficiary], _index", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/temp/UnicornGO-13.sol", "function": "_receiveBuyNextRank(address)", "lineno": 287, "title": "Message call to external contract", "type": "Informational"}, {"address": 9022, "code": "require(candyToken.transferFrom(", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/temp/UnicornGO-13.sol", "function": "_receiveBuyNextRank(address)", "lineno": 291, "title": "State change after external call", "type": "Warning"}, {"address": 9526, "code": "erRanks[_user] = _index;\n        emit BuyRank(_user, _", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/temp/UnicornGO-13.sol", "function": "buyRank(uint256)", "lineno": 300, "title": "Message call to external contract", "type": "Informational"}, {"address": 9625, "code": "}\n\n\n\n    function getNextRank(ad", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/temp/UnicornGO-13.sol", "function": "buyRank(uint256)", "lineno": 302, "title": "State change after external call", "type": "Warning"}, {"address": 9783, "code": "\n   ", "debug": "The exception is triggered under the following conditions:\n\nstorage_2: 0x0\ncaller: 0x0\ncalldata_UserRank_0: 0x8f4ffcb100000000000000000000000000000000000000000000000000000000\ncalldatasize_UserRank: 0x4\ncalldata_UserRank_4 + calldata_UserRank_32 + 68: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/UnicornGO-13.sol", "function": "receiveApproval(address,uint256,address,bytes)", "lineno": 182, "title": "Exception state", "type": "Informational"}, {"address": 10026, "code": "Pri", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncalldata_UserRank_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_UserRank_0: 0x33575f6400000000000000000000000000000000000000000000000000000000\ncalldatasize_UserRank: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `buyRank(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/UnicornGO-13.sol", "function": "buyRank(uint256)", "lineno": 343, "title": "Integer Overflow ", "type": "Warning"}, {"address": 10064, "code": "}\n\ncontract ER", "debug": "The exception is triggered under the following conditions:\n\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x7fffffffffffffffffffffffffffffffffffffffffffff\ncalldata_UserRank_4: 0x7fffffffffffffffff8000000000000000000000000000000000000004200001\nstorage_1 +\nkeccac_storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller_+\n1: 0x1\nstorage_1 +\nkeccac_1_+\n1_+\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_4: 0x7fffffffffffffffff8000000000000000000000000000000000000004200001\ncalldata_UserRank_0: 0x33575f6400000000000000000000000000000000000000000000000000000000\ncalldatasize_UserRank: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/temp/UnicornGO-13.sol", "function": "buyRank(uint256)", "lineno": 44, "title": "Exception state", "type": "Informational"}, {"address": 10114, "code": " priceCandy;\n        uint priceEth;\n        string title;\n    }\n\n    mapping (uint => Rank) public ranks;\n    uint public ranksCount = 0;\n\n    mapping (address => uint) public userRanks;\n\n    event TokensTransferred(address wallet, uint value);\n    event NewRankAdded(uint index, uint _landLimit, string _title, uint _priceCandy, uint _priceEth);\n    event RankChange(uint index, uint priceCandy, uint priceEth);\n    event BuyNextRank(address indexed owner, uint index);\n    event BuyRank(address indexed owner, uint index);\n\n\n\n    function UserRank(address _landManagementAddress) LandAccessControl(_landManagementAddress) public {\n\n        allowedFuncs[bytes4(keccak256(\"_receiveBuyNextRank(address)\"))] = true;\n        allowedFuncs[bytes4(keccak256(\"_receiveBuyRank(address,uint256)\"))] = true;\n        //3350000000000000 for candy\n\n        addRank(1,   36000000000000000000,   120600000000000000,\"Cryptolord\");\n        addRank(5,   144000000000000000000,  482400000000000000,\"Forklord\");\n        addRank(10,  180000000000000000000,  603000000000000000,\"Decentralord\");\n        addRank(20,  360000000000000000000,  1206000000000000000,\"Technomaster\");\n        addRank(50,  1080000000000000000000, 3618000000000000000,\"Bitmaster\");\n        addRank(100, 1800000000000000000000, 6030000000000000000,\"Megamaster\");\n        addRank(200, 3600000000000000000000, 12060000000000000000,\"Cyberduke\");\n        addRank(400, 7200000000000000000000, 24120000000000000000,\"Nanoprince\");\n        addRank(650, 9000000000000000000000, 30150000000000000000,\"Hyperprince\");\n        addRank(1000,12600000000000000000000,42210000000000000000,\"Ethercaesar\");\n\n\n    }\n\n    function init() onlyLandManagement whenPaused external {\n        candyToken = ERC20(landManagement.candyToken());\n    }\n\n\n\n    function addRank(uint _landLimit, uint _priceCandy, uint _priceEth, string _title) onlyOwner public  {\n        //\u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u044c \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c\u043e\u0433\u043e \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u043d\u0435 \u043d\u0438\u0436\u0435 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u0433\u043e\n        require(ranks[ranksCount].priceCandy <= _priceCandy && ranks[ranksCount].priceEth <= _priceEth);\n        ranksCount++;\n        Rank storage r = ranks[ranksCount];\n\n        r.landLimit = _landLimit;\n        r.priceCandy = _priceCandy;\n        r.priceEth = _priceEth;\n        r.title = _title;\n        emit NewRankAdded(ranksCount, _landLimit,_title,_priceCandy,_priceEth);\n    }\n\n\n    function editRank(uint _index, uint _priceCandy, uint _priceEth) onlyManager public  {\n        require(_index > 0 && _index <= ranksCount);\n        if (_index > 1) {\n            require(ranks[_index - 1].priceCandy <= _priceCandy && ranks[_index - 1].priceEth <= _priceEth);\n        }\n        if (_index < ranksCount) {\n            require(ranks[_index + 1].priceCandy >= _priceCandy && ranks[_index + 1].priceEth >= _priceEth);\n        }\n\n        Rank storage r = ranks[_index];\n        r.priceCandy = _priceCandy;\n        r.priceEth = _priceEth;\n        emit RankChange(_index, _priceCandy, _priceEth);\n    }\n\n    function buyNextRank() public {\n        _buyNextRank(msg.sender);\n    }\n\n    function _receiveBuyNextRank(address _beneficiary) onlySelf onlyPayloadSize(1) public {\n        _buyNextRank(_beneficiary);\n    }\n\n    function buyRank(uint _index) public {\n        _buyRank(msg.sender, _index);\n    }\n\n    function _receiveBuyRank(address _beneficiary, uint _index) onlySelf onlyPayloadSize(2) public {\n        _buyRank(_beneficiary, _index);\n    }\n\n\n    function _buyNextRank(address _beneficiary) internal {\n        uint _index = userRanks[_beneficiary] + 1;\n        require(_index <= ranksCount);\n\n        require(candyToken.transferFrom(_beneficiary, this, ranks[_index].priceCandy));\n        userRanks[_beneficiary] = _index;\n        emit BuyNextRank(_beneficiary, _index);\n    }\n\n\n    function _buyRank(address _beneficiary, uint _index) internal {\n        require(_index <= ranksCount);\n        require(userRanks[_beneficiary] < _index);\n\n        uint fullPrice = _getPrice(userRanks[_beneficiary], _index);\n\n        require(candyToken.transferFrom(_beneficiary, this, fullPrice));\n        userRanks[_beneficiary] = _index;\n        emit BuyRank(_beneficiary, _index);\n    }\n\n\n    function getPreSaleRank(address _user, uint _index) onlyManager whilePresaleOpen public {\n        require(_index <= ranksCount);\n        require(userRanks[_user] < _index);\n        userRanks[_user] = _index;\n        emit BuyRank(_user, _index);\n    }\n\n\n\n    function getNextRank(address _user) onlyUnicornContract public returns (uint) {\n        uint _index = userRanks[_user] + 1;\n        require(_index <= ranksCount);\n        userRanks[_user] = _index;\n        return _index;\n        emit BuyNextRank(msg.sender, _index);\n    }\n\n\n    function getRank(address _user, uint _index) onlyUnicornContract public {\n        require(_index <= ranksCount);\n        require(userRanks[_user] <= _index);\n        userRanks[_user] = _index;\n        emit BuyRank(_user, _index);\n    }\n\n\n    function _getPrice(uint _userRank, uint _index) private view returns (uint) {\n        uint fullPrice = 0;\n\n        for(uint i = _userRank+1; i <= _index; i++)\n        {\n            fullPrice = fullPrice.add(ranks[i].priceCandy);\n        }\n\n        return fullPrice;\n    }\n\n\n    function getIndividualPrice(address _user, uint _index) public view returns (uint) {\n        require(_index <= ranksCount);\n        require(userRanks[_user] < _index);\n\n        return _getPrice(userRanks[_user], _index);\n    }\n\n\n    function getRankPriceCandy(uint _index) public view returns (uint) {\n        return ranks[_index].priceCandy;\n    }\n\n\n    function getRankPriceEth(uint _index) public view returns (uint) {\n        return ranks[_index].priceEth;\n    }\n\n    function getRankLandLimit(uint _index) public view returns (uint) {\n        return ranks[_index].landLimit;\n    }\n\n\n    function getRankTitle(uint _index) public view returns (string) {\n        return ranks[_index].title;\n    }\n\n    function getUserRank(address _user) public view returns (uint) {\n        return userRanks[_user];\n    }\n\n    function getUserLandLimit(address _user) public view returns (uint) {\n        return ranks[userRanks[_user]].landLimit;\n    }\n\n\n    function withdrawTokens() public onlyManager  {\n        require(candyToken.balanceOf(this) > 0);\n        candyToken.transfer(landManagement.walletAddress(), candyToken.balanceOf(this));\n        emit TokensTransferred(landManagement.walletAddress(), candyToken.balanceOf(this));\n    }\n\n\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\n        //require(_token == landManagement.candyToken());\n        require(msg.sender == address(candyToken));\n        require(allowedFuncs[bytesToBytes4(_extraData)]);\n        require(address(this).call(_extraData));\n        emit ReceiveApproval(_from, _value, _token);\n    }\n\n}", "debug": "storage_3 + keccac_1_+_storage_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_3_+_keccac_1_+_storage_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\ncalldata_UserRank_32 + 36: 0x0\ncalldata_UserRank_32 + 4: 0x0\nstorage_2 + keccac_storage_4: 0x0\nstorage_1 + keccac_storage_4: 0x0\nmem_96 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_UserRank_4 + calldata_UserRank_32 + 68)): 0x0\ncaller: 0x0\nretval_2578: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_UserRank_0: 0x37e822b800000000000000000000000000000000000000000000000000000000\ncalldatasize_UserRank: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `addRank(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/UnicornGO-13.sol", "function": "addRank(uint256,uint256,uint256,string)", "lineno": 185, "title": "Integer Overflow ", "type": "Warning"}, {"address": 10143, "code": " priceCandy;\n        uint priceEth;\n        string title;\n    }\n\n    mapping (uint => Rank) public ranks;\n    uint public ranksCount = 0;\n\n    mapping (address => uint) public userRanks;\n\n    event TokensTransferred(address wallet, uint value);\n    event NewRankAdded(uint index, uint _landLimit, string _title, uint _priceCandy, uint _priceEth);\n    event RankChange(uint index, uint priceCandy, uint priceEth);\n    event BuyNextRank(address indexed owner, uint index);\n    event BuyRank(address indexed owner, uint index);\n\n\n\n    function UserRank(address _landManagementAddress) LandAccessControl(_landManagementAddress) public {\n\n        allowedFuncs[bytes4(keccak256(\"_receiveBuyNextRank(address)\"))] = true;\n        allowedFuncs[bytes4(keccak256(\"_receiveBuyRank(address,uint256)\"))] = true;\n        //3350000000000000 for candy\n\n        addRank(1,   36000000000000000000,   120600000000000000,\"Cryptolord\");\n        addRank(5,   144000000000000000000,  482400000000000000,\"Forklord\");\n        addRank(10,  180000000000000000000,  603000000000000000,\"Decentralord\");\n        addRank(20,  360000000000000000000,  1206000000000000000,\"Technomaster\");\n        addRank(50,  1080000000000000000000, 3618000000000000000,\"Bitmaster\");\n        addRank(100, 1800000000000000000000, 6030000000000000000,\"Megamaster\");\n        addRank(200, 3600000000000000000000, 12060000000000000000,\"Cyberduke\");\n        addRank(400, 7200000000000000000000, 24120000000000000000,\"Nanoprince\");\n        addRank(650, 9000000000000000000000, 30150000000000000000,\"Hyperprince\");\n        addRank(1000,12600000000000000000000,42210000000000000000,\"Ethercaesar\");\n\n\n    }\n\n    function init() onlyLandManagement whenPaused external {\n        candyToken = ERC20(landManagement.candyToken());\n    }\n\n\n\n    function addRank(uint _landLimit, uint _priceCandy, uint _priceEth, string _title) onlyOwner public  {\n        //\u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u044c \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c\u043e\u0433\u043e \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u043d\u0435 \u043d\u0438\u0436\u0435 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u0433\u043e\n        require(ranks[ranksCount].priceCandy <= _priceCandy && ranks[ranksCount].priceEth <= _priceEth);\n        ranksCount++;\n        Rank storage r = ranks[ranksCount];\n\n        r.landLimit = _landLimit;\n        r.priceCandy = _priceCandy;\n        r.priceEth = _priceEth;\n        r.title = _title;\n        emit NewRankAdded(ranksCount, _landLimit,_title,_priceCandy,_priceEth);\n    }\n\n\n    function editRank(uint _index, uint _priceCandy, uint _priceEth) onlyManager public  {\n        require(_index > 0 && _index <= ranksCount);\n        if (_index > 1) {\n            require(ranks[_index - 1].priceCandy <= _priceCandy && ranks[_index - 1].priceEth <= _priceEth);\n        }\n        if (_index < ranksCount) {\n            require(ranks[_index + 1].priceCandy >= _priceCandy && ranks[_index + 1].priceEth >= _priceEth);\n        }\n\n        Rank storage r = ranks[_index];\n        r.priceCandy = _priceCandy;\n        r.priceEth = _priceEth;\n        emit RankChange(_index, _priceCandy, _priceEth);\n    }\n\n    function buyNextRank() public {\n        _buyNextRank(msg.sender);\n    }\n\n    function _receiveBuyNextRank(address _beneficiary) onlySelf onlyPayloadSize(1) public {\n        _buyNextRank(_beneficiary);\n    }\n\n    function buyRank(uint _index) public {\n        _buyRank(msg.sender, _index);\n    }\n\n    function _receiveBuyRank(address _beneficiary, uint _index) onlySelf onlyPayloadSize(2) public {\n        _buyRank(_beneficiary, _index);\n    }\n\n\n    function _buyNextRank(address _beneficiary) internal {\n        uint _index = userRanks[_beneficiary] + 1;\n        require(_index <= ranksCount);\n\n        require(candyToken.transferFrom(_beneficiary, this, ranks[_index].priceCandy));\n        userRanks[_beneficiary] = _index;\n        emit BuyNextRank(_beneficiary, _index);\n    }\n\n\n    function _buyRank(address _beneficiary, uint _index) internal {\n        require(_index <= ranksCount);\n        require(userRanks[_beneficiary] < _index);\n\n        uint fullPrice = _getPrice(userRanks[_beneficiary], _index);\n\n        require(candyToken.transferFrom(_beneficiary, this, fullPrice));\n        userRanks[_beneficiary] = _index;\n        emit BuyRank(_beneficiary, _index);\n    }\n\n\n    function getPreSaleRank(address _user, uint _index) onlyManager whilePresaleOpen public {\n        require(_index <= ranksCount);\n        require(userRanks[_user] < _index);\n        userRanks[_user] = _index;\n        emit BuyRank(_user, _index);\n    }\n\n\n\n    function getNextRank(address _user) onlyUnicornContract public returns (uint) {\n        uint _index = userRanks[_user] + 1;\n        require(_index <= ranksCount);\n        userRanks[_user] = _index;\n        return _index;\n        emit BuyNextRank(msg.sender, _index);\n    }\n\n\n    function getRank(address _user, uint _index) onlyUnicornContract public {\n        require(_index <= ranksCount);\n        require(userRanks[_user] <= _index);\n        userRanks[_user] = _index;\n        emit BuyRank(_user, _index);\n    }\n\n\n    function _getPrice(uint _userRank, uint _index) private view returns (uint) {\n        uint fullPrice = 0;\n\n        for(uint i = _userRank+1; i <= _index; i++)\n        {\n            fullPrice = fullPrice.add(ranks[i].priceCandy);\n        }\n\n        return fullPrice;\n    }\n\n\n    function getIndividualPrice(address _user, uint _index) public view returns (uint) {\n        require(_index <= ranksCount);\n        require(userRanks[_user] < _index);\n\n        return _getPrice(userRanks[_user], _index);\n    }\n\n\n    function getRankPriceCandy(uint _index) public view returns (uint) {\n        return ranks[_index].priceCandy;\n    }\n\n\n    function getRankPriceEth(uint _index) public view returns (uint) {\n        return ranks[_index].priceEth;\n    }\n\n    function getRankLandLimit(uint _index) public view returns (uint) {\n        return ranks[_index].landLimit;\n    }\n\n\n    function getRankTitle(uint _index) public view returns (string) {\n        return ranks[_index].title;\n    }\n\n    function getUserRank(address _user) public view returns (uint) {\n        return userRanks[_user];\n    }\n\n    function getUserLandLimit(address _user) public view returns (uint) {\n        return ranks[userRanks[_user]].landLimit;\n    }\n\n\n    function withdrawTokens() public onlyManager  {\n        require(candyToken.balanceOf(this) > 0);\n        candyToken.transfer(landManagement.walletAddress(), candyToken.balanceOf(this));\n        emit TokensTransferred(landManagement.walletAddress(), candyToken.balanceOf(this));\n    }\n\n\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\n        //require(_token == landManagement.candyToken());\n        require(msg.sender == address(candyToken));\n        require(allowedFuncs[bytesToBytes4(_extraData)]);\n        require(address(this).call(_extraData));\n        emit ReceiveApproval(_from, _value, _token);\n    }\n\n}", "debug": "calldata_UserRank_4 + calldata_UserRank_32 + 68: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_UserRank_32 + 36: 0x0\ncalldata_UserRank_32 + 4: 0x0\nstorage_2 + keccac_storage_4: 0x0\nstorage_1 + keccac_storage_4: 0x0\nmem_96 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_UserRank_4 + calldata_UserRank_32 + 68)): 0x0\ncaller: 0x0\nretval_2578: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_UserRank_0: 0x37e822b800000000000000000000000000000000000000000000000000000000\ncalldatasize_UserRank: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `addRank(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/UnicornGO-13.sol", "function": "addRank(uint256,uint256,uint256,string)", "lineno": 185, "title": "Integer Overflow ", "type": "Warning"}, {"address": 10148, "code": " priceCandy;\n        uint priceEth;\n        string title;\n    }\n\n    mapping (uint => Rank) public ranks;\n    uint public ranksCount = 0;\n\n    mapping (address => uint) public userRanks;\n\n    event TokensTransferred(address wallet, uint value);\n    event NewRankAdded(uint index, uint _landLimit, string _title, uint _priceCandy, uint _priceEth);\n    event RankChange(uint index, uint priceCandy, uint priceEth);\n    event BuyNextRank(address indexed owner, uint index);\n    event BuyRank(address indexed owner, uint index);\n\n\n\n    function UserRank(address _landManagementAddress) LandAccessControl(_landManagementAddress) public {\n\n        allowedFuncs[bytes4(keccak256(\"_receiveBuyNextRank(address)\"))] = true;\n        allowedFuncs[bytes4(keccak256(\"_receiveBuyRank(address,uint256)\"))] = true;\n        //3350000000000000 for candy\n\n        addRank(1,   36000000000000000000,   120600000000000000,\"Cryptolord\");\n        addRank(5,   144000000000000000000,  482400000000000000,\"Forklord\");\n        addRank(10,  180000000000000000000,  603000000000000000,\"Decentralord\");\n        addRank(20,  360000000000000000000,  1206000000000000000,\"Technomaster\");\n        addRank(50,  1080000000000000000000, 3618000000000000000,\"Bitmaster\");\n        addRank(100, 1800000000000000000000, 6030000000000000000,\"Megamaster\");\n        addRank(200, 3600000000000000000000, 12060000000000000000,\"Cyberduke\");\n        addRank(400, 7200000000000000000000, 24120000000000000000,\"Nanoprince\");\n        addRank(650, 9000000000000000000000, 30150000000000000000,\"Hyperprince\");\n        addRank(1000,12600000000000000000000,42210000000000000000,\"Ethercaesar\");\n\n\n    }\n\n    function init() onlyLandManagement whenPaused external {\n        candyToken = ERC20(landManagement.candyToken());\n    }\n\n\n\n    function addRank(uint _landLimit, uint _priceCandy, uint _priceEth, string _title) onlyOwner public  {\n        //\u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u044c \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c\u043e\u0433\u043e \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u043d\u0435 \u043d\u0438\u0436\u0435 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u0433\u043e\n        require(ranks[ranksCount].priceCandy <= _priceCandy && ranks[ranksCount].priceEth <= _priceEth);\n        ranksCount++;\n        Rank storage r = ranks[ranksCount];\n\n        r.landLimit = _landLimit;\n        r.priceCandy = _priceCandy;\n        r.priceEth = _priceEth;\n        r.title = _title;\n        emit NewRankAdded(ranksCount, _landLimit,_title,_priceCandy,_priceEth);\n    }\n\n\n    function editRank(uint _index, uint _priceCandy, uint _priceEth) onlyManager public  {\n        require(_index > 0 && _index <= ranksCount);\n        if (_index > 1) {\n            require(ranks[_index - 1].priceCandy <= _priceCandy && ranks[_index - 1].priceEth <= _priceEth);\n        }\n        if (_index < ranksCount) {\n            require(ranks[_index + 1].priceCandy >= _priceCandy && ranks[_index + 1].priceEth >= _priceEth);\n        }\n\n        Rank storage r = ranks[_index];\n        r.priceCandy = _priceCandy;\n        r.priceEth = _priceEth;\n        emit RankChange(_index, _priceCandy, _priceEth);\n    }\n\n    function buyNextRank() public {\n        _buyNextRank(msg.sender);\n    }\n\n    function _receiveBuyNextRank(address _beneficiary) onlySelf onlyPayloadSize(1) public {\n        _buyNextRank(_beneficiary);\n    }\n\n    function buyRank(uint _index) public {\n        _buyRank(msg.sender, _index);\n    }\n\n    function _receiveBuyRank(address _beneficiary, uint _index) onlySelf onlyPayloadSize(2) public {\n        _buyRank(_beneficiary, _index);\n    }\n\n\n    function _buyNextRank(address _beneficiary) internal {\n        uint _index = userRanks[_beneficiary] + 1;\n        require(_index <= ranksCount);\n\n        require(candyToken.transferFrom(_beneficiary, this, ranks[_index].priceCandy));\n        userRanks[_beneficiary] = _index;\n        emit BuyNextRank(_beneficiary, _index);\n    }\n\n\n    function _buyRank(address _beneficiary, uint _index) internal {\n        require(_index <= ranksCount);\n        require(userRanks[_beneficiary] < _index);\n\n        uint fullPrice = _getPrice(userRanks[_beneficiary], _index);\n\n        require(candyToken.transferFrom(_beneficiary, this, fullPrice));\n        userRanks[_beneficiary] = _index;\n        emit BuyRank(_beneficiary, _index);\n    }\n\n\n    function getPreSaleRank(address _user, uint _index) onlyManager whilePresaleOpen public {\n        require(_index <= ranksCount);\n        require(userRanks[_user] < _index);\n        userRanks[_user] = _index;\n        emit BuyRank(_user, _index);\n    }\n\n\n\n    function getNextRank(address _user) onlyUnicornContract public returns (uint) {\n        uint _index = userRanks[_user] + 1;\n        require(_index <= ranksCount);\n        userRanks[_user] = _index;\n        return _index;\n        emit BuyNextRank(msg.sender, _index);\n    }\n\n\n    function getRank(address _user, uint _index) onlyUnicornContract public {\n        require(_index <= ranksCount);\n        require(userRanks[_user] <= _index);\n        userRanks[_user] = _index;\n        emit BuyRank(_user, _index);\n    }\n\n\n    function _getPrice(uint _userRank, uint _index) private view returns (uint) {\n        uint fullPrice = 0;\n\n        for(uint i = _userRank+1; i <= _index; i++)\n        {\n            fullPrice = fullPrice.add(ranks[i].priceCandy);\n        }\n\n        return fullPrice;\n    }\n\n\n    function getIndividualPrice(address _user, uint _index) public view returns (uint) {\n        require(_index <= ranksCount);\n        require(userRanks[_user] < _index);\n\n        return _getPrice(userRanks[_user], _index);\n    }\n\n\n    function getRankPriceCandy(uint _index) public view returns (uint) {\n        return ranks[_index].priceCandy;\n    }\n\n\n    function getRankPriceEth(uint _index) public view returns (uint) {\n        return ranks[_index].priceEth;\n    }\n\n    function getRankLandLimit(uint _index) public view returns (uint) {\n        return ranks[_index].landLimit;\n    }\n\n\n    function getRankTitle(uint _index) public view returns (string) {\n        return ranks[_index].title;\n    }\n\n    function getUserRank(address _user) public view returns (uint) {\n        return userRanks[_user];\n    }\n\n    function getUserLandLimit(address _user) public view returns (uint) {\n        return ranks[userRanks[_user]].landLimit;\n    }\n\n\n    function withdrawTokens() public onlyManager  {\n        require(candyToken.balanceOf(this) > 0);\n        candyToken.transfer(landManagement.walletAddress(), candyToken.balanceOf(this));\n        emit TokensTransferred(landManagement.walletAddress(), candyToken.balanceOf(this));\n    }\n\n\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\n        //require(_token == landManagement.candyToken());\n        require(msg.sender == address(candyToken));\n        require(allowedFuncs[bytesToBytes4(_extraData)]);\n        require(address(this).call(_extraData));\n        emit ReceiveApproval(_from, _value, _token);\n    }\n\n}", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/temp/UnicornGO-13.sol", "function": "addRank(uint256,uint256,uint256,string)", "lineno": 185, "title": "State change after external call", "type": "Warning"}, {"address": 10157, "code": " priceCandy;\n        uint priceEth;\n        string title;\n    }\n\n    mapping (uint => Rank) public ranks;\n    uint public ranksCount = 0;\n\n    mapping (address => uint) public userRanks;\n\n    event TokensTransferred(address wallet, uint value);\n    event NewRankAdded(uint index, uint _landLimit, string _title, uint _priceCandy, uint _priceEth);\n    event RankChange(uint index, uint priceCandy, uint priceEth);\n    event BuyNextRank(address indexed owner, uint index);\n    event BuyRank(address indexed owner, uint index);\n\n\n\n    function UserRank(address _landManagementAddress) LandAccessControl(_landManagementAddress) public {\n\n        allowedFuncs[bytes4(keccak256(\"_receiveBuyNextRank(address)\"))] = true;\n        allowedFuncs[bytes4(keccak256(\"_receiveBuyRank(address,uint256)\"))] = true;\n        //3350000000000000 for candy\n\n        addRank(1,   36000000000000000000,   120600000000000000,\"Cryptolord\");\n        addRank(5,   144000000000000000000,  482400000000000000,\"Forklord\");\n        addRank(10,  180000000000000000000,  603000000000000000,\"Decentralord\");\n        addRank(20,  360000000000000000000,  1206000000000000000,\"Technomaster\");\n        addRank(50,  1080000000000000000000, 3618000000000000000,\"Bitmaster\");\n        addRank(100, 1800000000000000000000, 6030000000000000000,\"Megamaster\");\n        addRank(200, 3600000000000000000000, 12060000000000000000,\"Cyberduke\");\n        addRank(400, 7200000000000000000000, 24120000000000000000,\"Nanoprince\");\n        addRank(650, 9000000000000000000000, 30150000000000000000,\"Hyperprince\");\n        addRank(1000,12600000000000000000000,42210000000000000000,\"Ethercaesar\");\n\n\n    }\n\n    function init() onlyLandManagement whenPaused external {\n        candyToken = ERC20(landManagement.candyToken());\n    }\n\n\n\n    function addRank(uint _landLimit, uint _priceCandy, uint _priceEth, string _title) onlyOwner public  {\n        //\u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u044c \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c\u043e\u0433\u043e \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u043d\u0435 \u043d\u0438\u0436\u0435 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u0433\u043e\n        require(ranks[ranksCount].priceCandy <= _priceCandy && ranks[ranksCount].priceEth <= _priceEth);\n        ranksCount++;\n        Rank storage r = ranks[ranksCount];\n\n        r.landLimit = _landLimit;\n        r.priceCandy = _priceCandy;\n        r.priceEth = _priceEth;\n        r.title = _title;\n        emit NewRankAdded(ranksCount, _landLimit,_title,_priceCandy,_priceEth);\n    }\n\n\n    function editRank(uint _index, uint _priceCandy, uint _priceEth) onlyManager public  {\n        require(_index > 0 && _index <= ranksCount);\n        if (_index > 1) {\n            require(ranks[_index - 1].priceCandy <= _priceCandy && ranks[_index - 1].priceEth <= _priceEth);\n        }\n        if (_index < ranksCount) {\n            require(ranks[_index + 1].priceCandy >= _priceCandy && ranks[_index + 1].priceEth >= _priceEth);\n        }\n\n        Rank storage r = ranks[_index];\n        r.priceCandy = _priceCandy;\n        r.priceEth = _priceEth;\n        emit RankChange(_index, _priceCandy, _priceEth);\n    }\n\n    function buyNextRank() public {\n        _buyNextRank(msg.sender);\n    }\n\n    function _receiveBuyNextRank(address _beneficiary) onlySelf onlyPayloadSize(1) public {\n        _buyNextRank(_beneficiary);\n    }\n\n    function buyRank(uint _index) public {\n        _buyRank(msg.sender, _index);\n    }\n\n    function _receiveBuyRank(address _beneficiary, uint _index) onlySelf onlyPayloadSize(2) public {\n        _buyRank(_beneficiary, _index);\n    }\n\n\n    function _buyNextRank(address _beneficiary) internal {\n        uint _index = userRanks[_beneficiary] + 1;\n        require(_index <= ranksCount);\n\n        require(candyToken.transferFrom(_beneficiary, this, ranks[_index].priceCandy));\n        userRanks[_beneficiary] = _index;\n        emit BuyNextRank(_beneficiary, _index);\n    }\n\n\n    function _buyRank(address _beneficiary, uint _index) internal {\n        require(_index <= ranksCount);\n        require(userRanks[_beneficiary] < _index);\n\n        uint fullPrice = _getPrice(userRanks[_beneficiary], _index);\n\n        require(candyToken.transferFrom(_beneficiary, this, fullPrice));\n        userRanks[_beneficiary] = _index;\n        emit BuyRank(_beneficiary, _index);\n    }\n\n\n    function getPreSaleRank(address _user, uint _index) onlyManager whilePresaleOpen public {\n        require(_index <= ranksCount);\n        require(userRanks[_user] < _index);\n        userRanks[_user] = _index;\n        emit BuyRank(_user, _index);\n    }\n\n\n\n    function getNextRank(address _user) onlyUnicornContract public returns (uint) {\n        uint _index = userRanks[_user] + 1;\n        require(_index <= ranksCount);\n        userRanks[_user] = _index;\n        return _index;\n        emit BuyNextRank(msg.sender, _index);\n    }\n\n\n    function getRank(address _user, uint _index) onlyUnicornContract public {\n        require(_index <= ranksCount);\n        require(userRanks[_user] <= _index);\n        userRanks[_user] = _index;\n        emit BuyRank(_user, _index);\n    }\n\n\n    function _getPrice(uint _userRank, uint _index) private view returns (uint) {\n        uint fullPrice = 0;\n\n        for(uint i = _userRank+1; i <= _index; i++)\n        {\n            fullPrice = fullPrice.add(ranks[i].priceCandy);\n        }\n\n        return fullPrice;\n    }\n\n\n    function getIndividualPrice(address _user, uint _index) public view returns (uint) {\n        require(_index <= ranksCount);\n        require(userRanks[_user] < _index);\n\n        return _getPrice(userRanks[_user], _index);\n    }\n\n\n    function getRankPriceCandy(uint _index) public view returns (uint) {\n        return ranks[_index].priceCandy;\n    }\n\n\n    function getRankPriceEth(uint _index) public view returns (uint) {\n        return ranks[_index].priceEth;\n    }\n\n    function getRankLandLimit(uint _index) public view returns (uint) {\n        return ranks[_index].landLimit;\n    }\n\n\n    function getRankTitle(uint _index) public view returns (string) {\n        return ranks[_index].title;\n    }\n\n    function getUserRank(address _user) public view returns (uint) {\n        return userRanks[_user];\n    }\n\n    function getUserLandLimit(address _user) public view returns (uint) {\n        return ranks[userRanks[_user]].landLimit;\n    }\n\n\n    function withdrawTokens() public onlyManager  {\n        require(candyToken.balanceOf(this) > 0);\n        candyToken.transfer(landManagement.walletAddress(), candyToken.balanceOf(this));\n        emit TokensTransferred(landManagement.walletAddress(), candyToken.balanceOf(this));\n    }\n\n\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\n        //require(_token == landManagement.candyToken());\n        require(msg.sender == address(candyToken));\n        require(allowedFuncs[bytesToBytes4(_extraData)]);\n        require(address(this).call(_extraData));\n        emit ReceiveApproval(_from, _value, _token);\n    }\n\n}", "debug": "calldata_UserRank_4 + calldata_UserRank_32 + 68: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80\ncalldata_UserRank_32 + 36: 0x0\ncalldata_UserRank_32 + 4: 0x0\nstorage_2 + keccac_storage_4: 0x0\nstorage_1 + keccac_storage_4: 0x0\nmem_96 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_UserRank_4 + calldata_UserRank_32 + 68)): 0x0\ncaller: 0x0\nretval_2578: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_UserRank_0: 0x37e822b800000000000000000000000000000000000000000000000000000000\ncalldatasize_UserRank: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `addRank(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/UnicornGO-13.sol", "function": "addRank(uint256,uint256,uint256,string)", "lineno": 185, "title": "Integer Overflow ", "type": "Warning"}, {"address": 10179, "code": " priceCandy;\n        uint priceEth;\n        string title;\n    }\n\n    mapping (uint => Rank) public ranks;\n    uint public ranksCount = 0;\n\n    mapping (address => uint) public userRanks;\n\n    event TokensTransferred(address wallet, uint value);\n    event NewRankAdded(uint index, uint _landLimit, string _title, uint _priceCandy, uint _priceEth);\n    event RankChange(uint index, uint priceCandy, uint priceEth);\n    event BuyNextRank(address indexed owner, uint index);\n    event BuyRank(address indexed owner, uint index);\n\n\n\n    function UserRank(address _landManagementAddress) LandAccessControl(_landManagementAddress) public {\n\n        allowedFuncs[bytes4(keccak256(\"_receiveBuyNextRank(address)\"))] = true;\n        allowedFuncs[bytes4(keccak256(\"_receiveBuyRank(address,uint256)\"))] = true;\n        //3350000000000000 for candy\n\n        addRank(1,   36000000000000000000,   120600000000000000,\"Cryptolord\");\n        addRank(5,   144000000000000000000,  482400000000000000,\"Forklord\");\n        addRank(10,  180000000000000000000,  603000000000000000,\"Decentralord\");\n        addRank(20,  360000000000000000000,  1206000000000000000,\"Technomaster\");\n        addRank(50,  1080000000000000000000, 3618000000000000000,\"Bitmaster\");\n        addRank(100, 1800000000000000000000, 6030000000000000000,\"Megamaster\");\n        addRank(200, 3600000000000000000000, 12060000000000000000,\"Cyberduke\");\n        addRank(400, 7200000000000000000000, 24120000000000000000,\"Nanoprince\");\n        addRank(650, 9000000000000000000000, 30150000000000000000,\"Hyperprince\");\n        addRank(1000,12600000000000000000000,42210000000000000000,\"Ethercaesar\");\n\n\n    }\n\n    function init() onlyLandManagement whenPaused external {\n        candyToken = ERC20(landManagement.candyToken());\n    }\n\n\n\n    function addRank(uint _landLimit, uint _priceCandy, uint _priceEth, string _title) onlyOwner public  {\n        //\u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u044c \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c\u043e\u0433\u043e \u0434\u043e\u043b\u0436\u043d\u0430 \u0431\u044b\u0442\u044c \u043d\u0435 \u043d\u0438\u0436\u0435 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u0433\u043e\n        require(ranks[ranksCount].priceCandy <= _priceCandy && ranks[ranksCount].priceEth <= _priceEth);\n        ranksCount++;\n        Rank storage r = ranks[ranksCount];\n\n        r.landLimit = _landLimit;\n        r.priceCandy = _priceCandy;\n        r.priceEth = _priceEth;\n        r.title = _title;\n        emit NewRankAdded(ranksCount, _landLimit,_title,_priceCandy,_priceEth);\n    }\n\n\n    function editRank(uint _index, uint _priceCandy, uint _priceEth) onlyManager public  {\n        require(_index > 0 && _index <= ranksCount);\n        if (_index > 1) {\n            require(ranks[_index - 1].priceCandy <= _priceCandy && ranks[_index - 1].priceEth <= _priceEth);\n        }\n        if (_index < ranksCount) {\n            require(ranks[_index + 1].priceCandy >= _priceCandy && ranks[_index + 1].priceEth >= _priceEth);\n        }\n\n        Rank storage r = ranks[_index];\n        r.priceCandy = _priceCandy;\n        r.priceEth = _priceEth;\n        emit RankChange(_index, _priceCandy, _priceEth);\n    }\n\n    function buyNextRank() public {\n        _buyNextRank(msg.sender);\n    }\n\n    function _receiveBuyNextRank(address _beneficiary) onlySelf onlyPayloadSize(1) public {\n        _buyNextRank(_beneficiary);\n    }\n\n    function buyRank(uint _index) public {\n        _buyRank(msg.sender, _index);\n    }\n\n    function _receiveBuyRank(address _beneficiary, uint _index) onlySelf onlyPayloadSize(2) public {\n        _buyRank(_beneficiary, _index);\n    }\n\n\n    function _buyNextRank(address _beneficiary) internal {\n        uint _index = userRanks[_beneficiary] + 1;\n        require(_index <= ranksCount);\n\n        require(candyToken.transferFrom(_beneficiary, this, ranks[_index].priceCandy));\n        userRanks[_beneficiary] = _index;\n        emit BuyNextRank(_beneficiary, _index);\n    }\n\n\n    function _buyRank(address _beneficiary, uint _index) internal {\n        require(_index <= ranksCount);\n        require(userRanks[_beneficiary] < _index);\n\n        uint fullPrice = _getPrice(userRanks[_beneficiary], _index);\n\n        require(candyToken.transferFrom(_beneficiary, this, fullPrice));\n        userRanks[_beneficiary] = _index;\n        emit BuyRank(_beneficiary, _index);\n    }\n\n\n    function getPreSaleRank(address _user, uint _index) onlyManager whilePresaleOpen public {\n        require(_index <= ranksCount);\n        require(userRanks[_user] < _index);\n        userRanks[_user] = _index;\n        emit BuyRank(_user, _index);\n    }\n\n\n\n    function getNextRank(address _user) onlyUnicornContract public returns (uint) {\n        uint _index = userRanks[_user] + 1;\n        require(_index <= ranksCount);\n        userRanks[_user] = _index;\n        return _index;\n        emit BuyNextRank(msg.sender, _index);\n    }\n\n\n    function getRank(address _user, uint _index) onlyUnicornContract public {\n        require(_index <= ranksCount);\n        require(userRanks[_user] <= _index);\n        userRanks[_user] = _index;\n        emit BuyRank(_user, _index);\n    }\n\n\n    function _getPrice(uint _userRank, uint _index) private view returns (uint) {\n        uint fullPrice = 0;\n\n        for(uint i = _userRank+1; i <= _index; i++)\n        {\n            fullPrice = fullPrice.add(ranks[i].priceCandy);\n        }\n\n        return fullPrice;\n    }\n\n\n    function getIndividualPrice(address _user, uint _index) public view returns (uint) {\n        require(_index <= ranksCount);\n        require(userRanks[_user] < _index);\n\n        return _getPrice(userRanks[_user], _index);\n    }\n\n\n    function getRankPriceCandy(uint _index) public view returns (uint) {\n        return ranks[_index].priceCandy;\n    }\n\n\n    function getRankPriceEth(uint _index) public view returns (uint) {\n        return ranks[_index].priceEth;\n    }\n\n    function getRankLandLimit(uint _index) public view returns (uint) {\n        return ranks[_index].landLimit;\n    }\n\n\n    function getRankTitle(uint _index) public view returns (string) {\n        return ranks[_index].title;\n    }\n\n    function getUserRank(address _user) public view returns (uint) {\n        return userRanks[_user];\n    }\n\n    function getUserLandLimit(address _user) public view returns (uint) {\n        return ranks[userRanks[_user]].landLimit;\n    }\n\n\n    function withdrawTokens() public onlyManager  {\n        require(candyToken.balanceOf(this) > 0);\n        candyToken.transfer(landManagement.walletAddress(), candyToken.balanceOf(this));\n        emit TokensTransferred(landManagement.walletAddress(), candyToken.balanceOf(this));\n    }\n\n\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\n        //require(_token == landManagement.candyToken());\n        require(msg.sender == address(candyToken));\n        require(allowedFuncs[bytesToBytes4(_extraData)]);\n        require(address(this).call(_extraData));\n        emit ReceiveApproval(_from, _value, _token);\n    }\n\n}", "debug": "calldata_UserRank_4 + calldata_UserRank_32 + 68: 0xffc7ffffffffffffffffffffffffffffffffffffffffffffffff80\nkeccac_3_+_keccac_1_+_storage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_UserRank_32 + 36: 0x0\ncalldata_UserRank_32 + 4: 0x0\nstorage_2 + keccac_storage_4: 0x0\nstorage_1 + keccac_storage_4: 0x0\nmem_96 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_UserRank_4 + calldata_UserRank_32 + 68)): 0x0\ncaller: 0x0\nretval_2578: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_UserRank_0: 0x37e822b800000000000000000000000000000000000000000000000000000000\ncalldatasize_UserRank: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `addRank(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/temp/UnicornGO-13.sol", "function": "addRank(uint256,uint256,uint256,string)", "lineno": 185, "title": "Integer Overflow ", "type": "Warning"}], "success": true}
